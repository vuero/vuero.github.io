var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
import { _ as __unplugin_components_0, a as _sfc_main$1 } from "./DocumentationItem.6b7c9a35.js";
import { o as openBlock, N as createBlock, x as withCtx, e as createBaseVNode, B as createTextVNode, as as vue, aj as getDefaultExportFromCjs, r as ref, d as defineComponent, K as useHead, b as createElementBlock, v as createVNode, t as unref, A as isRef } from "./vendor.9ec557a4.js";
import { p as pageTitle } from "./sidebarLayoutState.883cc242.js";
import "./VIcon.85cce7bc.js";
import "./index.4d6c8e1a.js";
const _hoisted_1$1 = /* @__PURE__ */ createBaseVNode("h3", {
  id: "ckeditor",
  tabindex: "-1"
}, "CKEditor", -1);
const _hoisted_2$1 = /* @__PURE__ */ createBaseVNode("p", null, [
  /* @__PURE__ */ createTextVNode("Every application needs a rich text editor component. Vuero is bundled with the "),
  /* @__PURE__ */ createBaseVNode("a", { href: "https://ckeditor.com/docs/ckeditor5/latest/index.html" }, "CK Editor"),
  /* @__PURE__ */ createTextVNode(" plugin. The example below shows the default editor mode. There are many more, but the plugin doesn\u2019t support importing all editor variations. You have to chose one and keep on with it. Other available layouts can be found "),
  /* @__PURE__ */ createBaseVNode("a", { href: "https://ckeditor.com/docs/ckeditor5/latest/index.html" }, "here"),
  /* @__PURE__ */ createTextVNode(".")
], -1);
const _hoisted_3$1 = /* @__PURE__ */ createBaseVNode("div", { class: "language-vue line-numbers-mode" }, [
  /* @__PURE__ */ createBaseVNode("pre", null, [
    /* @__PURE__ */ createBaseVNode("code", null, [
      /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--tag" }, [
        /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--tag" }, [
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--punctuation" }, "<"),
          /* @__PURE__ */ createTextVNode("script")
        ]),
        /* @__PURE__ */ createTextVNode(),
        /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--attr-name" }, "setup"),
        /* @__PURE__ */ createTextVNode(),
        /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--attr-name" }, "lang"),
        /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--attr-value" }, [
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--punctuation prism--attr-equals" }, "="),
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--punctuation" }, '"'),
          /* @__PURE__ */ createTextVNode("ts"),
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--punctuation" }, '"')
        ]),
        /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--punctuation" }, ">")
      ]),
      /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--script" }, [
        /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--language-javascript" }, [
          /* @__PURE__ */ createTextVNode("\n"),
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--keyword" }, "import"),
          /* @__PURE__ */ createTextVNode(),
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--punctuation" }, "{"),
          /* @__PURE__ */ createTextVNode(" ref "),
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--punctuation" }, "}"),
          /* @__PURE__ */ createTextVNode(),
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--keyword" }, "from"),
          /* @__PURE__ */ createTextVNode(),
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--string" }, "'vue'"),
          /* @__PURE__ */ createTextVNode("\n"),
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--keyword" }, "import"),
          /* @__PURE__ */ createTextVNode(),
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--constant" }, "CKE"),
          /* @__PURE__ */ createTextVNode(),
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--keyword" }, "from"),
          /* @__PURE__ */ createTextVNode(),
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--string" }, "'@ckeditor/ckeditor5-vue'"),
          /* @__PURE__ */ createTextVNode("\n"),
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--keyword" }, "import"),
          /* @__PURE__ */ createTextVNode(" ClassicEditor "),
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--keyword" }, "from"),
          /* @__PURE__ */ createTextVNode(),
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--string" }, "'@ckeditor/ckeditor5-build-classic'"),
          /* @__PURE__ */ createTextVNode("\n\n"),
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--keyword" }, "const"),
          /* @__PURE__ */ createTextVNode(" CKEditor "),
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--operator" }, "="),
          /* @__PURE__ */ createTextVNode(),
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--constant" }, "CKE"),
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--punctuation" }, "."),
          /* @__PURE__ */ createTextVNode("component\n"),
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--keyword" }, "const"),
          /* @__PURE__ */ createTextVNode(" editorData "),
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--operator" }, "="),
          /* @__PURE__ */ createTextVNode(),
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--function" }, "ref"),
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--punctuation" }, "("),
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--template-string" }, [
            /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--template-punctuation prism--string" }, "`"),
            /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--string" }, "<h2>Your HTML Content</h2>"),
            /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--template-punctuation prism--string" }, "`")
          ]),
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--punctuation" }, ")"),
          /* @__PURE__ */ createTextVNode("\n"),
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--keyword" }, "const"),
          /* @__PURE__ */ createTextVNode(" config "),
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--operator" }, "="),
          /* @__PURE__ */ createTextVNode(),
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--punctuation" }, "{"),
          /* @__PURE__ */ createTextVNode("\n  fontFamily"),
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--operator" }, ":"),
          /* @__PURE__ */ createTextVNode(),
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--punctuation" }, "{"),
          /* @__PURE__ */ createTextVNode("\n    options"),
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--operator" }, ":"),
          /* @__PURE__ */ createTextVNode(),
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--punctuation" }, "["),
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--string" }, `'"Montserrat", sans-serif'`),
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--punctuation" }, ","),
          /* @__PURE__ */ createTextVNode(),
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--string" }, `'"Roboto", sans-serif'`),
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--punctuation" }, "]"),
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--punctuation" }, ","),
          /* @__PURE__ */ createTextVNode("\n  "),
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--punctuation" }, "}"),
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--punctuation" }, ","),
          /* @__PURE__ */ createTextVNode("\n"),
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--punctuation" }, "}"),
          /* @__PURE__ */ createTextVNode("\n")
        ])
      ]),
      /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--tag" }, [
        /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--tag" }, [
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--punctuation" }, "</"),
          /* @__PURE__ */ createTextVNode("script")
        ]),
        /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--punctuation" }, ">")
      ]),
      /* @__PURE__ */ createTextVNode("\n\n"),
      /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--tag" }, [
        /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--tag" }, [
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--punctuation" }, "<"),
          /* @__PURE__ */ createTextVNode("template")
        ]),
        /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--punctuation" }, ">")
      ]),
      /* @__PURE__ */ createTextVNode("\n  "),
      /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--tag" }, [
        /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--tag" }, [
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--punctuation" }, "<"),
          /* @__PURE__ */ createTextVNode("div")
        ]),
        /* @__PURE__ */ createTextVNode(),
        /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--attr-name" }, "class"),
        /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--attr-value" }, [
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--punctuation prism--attr-equals" }, "="),
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--punctuation" }, '"'),
          /* @__PURE__ */ createTextVNode("content"),
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--punctuation" }, '"')
        ]),
        /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--punctuation" }, ">")
      ]),
      /* @__PURE__ */ createTextVNode("\n    "),
      /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--tag" }, [
        /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--tag" }, [
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--punctuation" }, "<"),
          /* @__PURE__ */ createTextVNode("CKEditor")
        ]),
        /* @__PURE__ */ createTextVNode("\n      "),
        /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--attr-name" }, "v-model"),
        /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--attr-value" }, [
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--punctuation prism--attr-equals" }, "="),
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--punctuation" }, '"'),
          /* @__PURE__ */ createTextVNode("content"),
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--punctuation" }, '"')
        ]),
        /* @__PURE__ */ createTextVNode("\n      "),
        /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--attr-name" }, ":editor"),
        /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--attr-value" }, [
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--punctuation prism--attr-equals" }, "="),
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--punctuation" }, '"'),
          /* @__PURE__ */ createTextVNode("ClassicEditor"),
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--punctuation" }, '"')
        ]),
        /* @__PURE__ */ createTextVNode("\n      "),
        /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--attr-name" }, ":config"),
        /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--attr-value" }, [
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--punctuation prism--attr-equals" }, "="),
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--punctuation" }, '"'),
          /* @__PURE__ */ createTextVNode("config"),
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--punctuation" }, '"')
        ]),
        /* @__PURE__ */ createTextVNode("\n    "),
        /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--punctuation" }, ">")
      ]),
      /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--tag" }, [
        /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--tag" }, [
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--punctuation" }, "</"),
          /* @__PURE__ */ createTextVNode("CKEditor")
        ]),
        /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--punctuation" }, ">")
      ]),
      /* @__PURE__ */ createTextVNode("\n  "),
      /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--tag" }, [
        /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--tag" }, [
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--punctuation" }, "</"),
          /* @__PURE__ */ createTextVNode("div")
        ]),
        /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--punctuation" }, ">")
      ]),
      /* @__PURE__ */ createTextVNode("\n"),
      /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--tag" }, [
        /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--tag" }, [
          /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--punctuation" }, "</"),
          /* @__PURE__ */ createTextVNode("template")
        ]),
        /* @__PURE__ */ createBaseVNode("span", { class: "prism--token prism--punctuation" }, ">")
      ]),
      /* @__PURE__ */ createTextVNode("\n")
    ])
  ]),
  /* @__PURE__ */ createBaseVNode("div", { class: "line-numbers-wrapper" }, [
    /* @__PURE__ */ createBaseVNode("span", { class: "line-number" }, "1"),
    /* @__PURE__ */ createBaseVNode("br"),
    /* @__PURE__ */ createBaseVNode("span", { class: "line-number" }, "2"),
    /* @__PURE__ */ createBaseVNode("br"),
    /* @__PURE__ */ createBaseVNode("span", { class: "line-number" }, "3"),
    /* @__PURE__ */ createBaseVNode("br"),
    /* @__PURE__ */ createBaseVNode("span", { class: "line-number" }, "4"),
    /* @__PURE__ */ createBaseVNode("br"),
    /* @__PURE__ */ createBaseVNode("span", { class: "line-number" }, "5"),
    /* @__PURE__ */ createBaseVNode("br"),
    /* @__PURE__ */ createBaseVNode("span", { class: "line-number" }, "6"),
    /* @__PURE__ */ createBaseVNode("br"),
    /* @__PURE__ */ createBaseVNode("span", { class: "line-number" }, "7"),
    /* @__PURE__ */ createBaseVNode("br"),
    /* @__PURE__ */ createBaseVNode("span", { class: "line-number" }, "8"),
    /* @__PURE__ */ createBaseVNode("br"),
    /* @__PURE__ */ createBaseVNode("span", { class: "line-number" }, "9"),
    /* @__PURE__ */ createBaseVNode("br"),
    /* @__PURE__ */ createBaseVNode("span", { class: "line-number" }, "10"),
    /* @__PURE__ */ createBaseVNode("br"),
    /* @__PURE__ */ createBaseVNode("span", { class: "line-number" }, "11"),
    /* @__PURE__ */ createBaseVNode("br"),
    /* @__PURE__ */ createBaseVNode("span", { class: "line-number" }, "12"),
    /* @__PURE__ */ createBaseVNode("br"),
    /* @__PURE__ */ createBaseVNode("span", { class: "line-number" }, "13"),
    /* @__PURE__ */ createBaseVNode("br"),
    /* @__PURE__ */ createBaseVNode("span", { class: "line-number" }, "14"),
    /* @__PURE__ */ createBaseVNode("br"),
    /* @__PURE__ */ createBaseVNode("span", { class: "line-number" }, "15"),
    /* @__PURE__ */ createBaseVNode("br"),
    /* @__PURE__ */ createBaseVNode("span", { class: "line-number" }, "16"),
    /* @__PURE__ */ createBaseVNode("br"),
    /* @__PURE__ */ createBaseVNode("span", { class: "line-number" }, "17"),
    /* @__PURE__ */ createBaseVNode("br"),
    /* @__PURE__ */ createBaseVNode("span", { class: "line-number" }, "18"),
    /* @__PURE__ */ createBaseVNode("br"),
    /* @__PURE__ */ createBaseVNode("span", { class: "line-number" }, "19"),
    /* @__PURE__ */ createBaseVNode("br"),
    /* @__PURE__ */ createBaseVNode("span", { class: "line-number" }, "20"),
    /* @__PURE__ */ createBaseVNode("br"),
    /* @__PURE__ */ createBaseVNode("span", { class: "line-number" }, "21"),
    /* @__PURE__ */ createBaseVNode("br"),
    /* @__PURE__ */ createBaseVNode("span", { class: "line-number" }, "22"),
    /* @__PURE__ */ createBaseVNode("br"),
    /* @__PURE__ */ createBaseVNode("span", { class: "line-number" }, "23"),
    /* @__PURE__ */ createBaseVNode("br")
  ])
], -1);
function render(_ctx, _cache) {
  const _component_DocumentationItem = __unplugin_components_0;
  return openBlock(), createBlock(_component_DocumentationItem, { frontmatter: _ctx.frontmatter }, {
    code: withCtx(() => [
      _hoisted_3$1
    ]),
    default: withCtx(() => [
      _hoisted_1$1,
      _hoisted_2$1
    ]),
    _: 1
  }, 8, ["frontmatter"]);
}
const __matter = {};
const data = () => ({ frontmatter: __matter });
const __script = { render, data };
var ckeditor$1 = { exports: {} };
/*!
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */
(function(module, exports) {
  !function(t, e) {
    module.exports = e(vue.exports);
  }(window, function(t) {
    return function(t2) {
      var e = {};
      function n(o) {
        if (e[o])
          return e[o].exports;
        var i = e[o] = { i: o, l: false, exports: {} };
        return t2[o].call(i.exports, i, i.exports, n), i.l = true, i.exports;
      }
      return n.m = t2, n.c = e, n.d = function(t3, e2, o) {
        n.o(t3, e2) || Object.defineProperty(t3, e2, { enumerable: true, get: o });
      }, n.r = function(t3) {
        typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(t3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t3, "__esModule", { value: true });
      }, n.t = function(t3, e2) {
        if (1 & e2 && (t3 = n(t3)), 8 & e2)
          return t3;
        if (4 & e2 && typeof t3 == "object" && t3 && t3.__esModule)
          return t3;
        var o = Object.create(null);
        if (n.r(o), Object.defineProperty(o, "default", { enumerable: true, value: t3 }), 2 & e2 && typeof t3 != "string")
          for (var i in t3)
            n.d(o, i, function(e3) {
              return t3[e3];
            }.bind(null, i));
        return o;
      }, n.n = function(t3) {
        var e2 = t3 && t3.__esModule ? function() {
          return t3.default;
        } : function() {
          return t3;
        };
        return n.d(e2, "a", e2), e2;
      }, n.o = function(t3, e2) {
        return Object.prototype.hasOwnProperty.call(t3, e2);
      }, n.p = "", n(n.s = 3);
    }([function(e, n) {
      e.exports = t;
    }, function(t2, e, n) {
      (function(t3) {
        var n2 = typeof t3 == "object" && t3 && t3.Object === Object && t3;
        e.a = n2;
      }).call(this, n(2));
    }, function(t2, e) {
      var n;
      n = function() {
        return this;
      }();
      try {
        n = n || new Function("return this")();
      } catch (t3) {
        typeof window == "object" && (n = window);
      }
      t2.exports = n;
    }, function(t2, e, n) {
      n.r(e);
      var o = n(0), i = n.n(o);
      var r = function(t3) {
        var e2 = typeof t3;
        return t3 != null && (e2 == "object" || e2 == "function");
      }, u = n(1), a = typeof self == "object" && self && self.Object === Object && self, c = u.a || a || Function("return this")(), s = function() {
        return c.Date.now();
      }, l = c.Symbol, f = Object.prototype, d = f.hasOwnProperty, p = f.toString, v = l ? l.toStringTag : void 0;
      var m = function(t3) {
        var e2 = d.call(t3, v), n2 = t3[v];
        try {
          t3[v] = void 0;
          var o2 = true;
        } catch (t4) {
        }
        var i2 = p.call(t3);
        return o2 && (e2 ? t3[v] = n2 : delete t3[v]), i2;
      }, h = Object.prototype.toString;
      var y = function(t3) {
        return h.call(t3);
      }, b = l ? l.toStringTag : void 0;
      var g = function(t3) {
        return t3 == null ? t3 === void 0 ? "[object Undefined]" : "[object Null]" : b && b in Object(t3) ? m(t3) : y(t3);
      };
      var j = function(t3) {
        return t3 != null && typeof t3 == "object";
      };
      var $ = function(t3) {
        return typeof t3 == "symbol" || j(t3) && g(t3) == "[object Symbol]";
      }, O = /^\s+|\s+$/g, w = /^[-+]0x[0-9a-f]+$/i, _ = /^0b[01]+$/i, x = /^0o[0-7]+$/i, S = parseInt;
      var E = function(t3) {
        if (typeof t3 == "number")
          return t3;
        if ($(t3))
          return NaN;
        if (r(t3)) {
          var e2 = typeof t3.valueOf == "function" ? t3.valueOf() : t3;
          t3 = r(e2) ? e2 + "" : e2;
        }
        if (typeof t3 != "string")
          return t3 === 0 ? t3 : +t3;
        t3 = t3.replace(O, "");
        var n2 = _.test(t3);
        return n2 || x.test(t3) ? S(t3.slice(2), n2 ? 2 : 8) : w.test(t3) ? NaN : +t3;
      }, T = Math.max, V = Math.min;
      var D = function(t3, e2, n2) {
        var o2, i2, u2, a2, c2, l2, f2 = 0, d2 = false, p2 = false, v2 = true;
        if (typeof t3 != "function")
          throw new TypeError("Expected a function");
        function m2(e3) {
          var n3 = o2, r2 = i2;
          return o2 = i2 = void 0, f2 = e3, a2 = t3.apply(r2, n3);
        }
        function h2(t4) {
          return f2 = t4, c2 = setTimeout(b2, e2), d2 ? m2(t4) : a2;
        }
        function y2(t4) {
          var n3 = t4 - l2;
          return l2 === void 0 || n3 >= e2 || n3 < 0 || p2 && t4 - f2 >= u2;
        }
        function b2() {
          var t4 = s();
          if (y2(t4))
            return g2(t4);
          c2 = setTimeout(b2, function(t5) {
            var n3 = e2 - (t5 - l2);
            return p2 ? V(n3, u2 - (t5 - f2)) : n3;
          }(t4));
        }
        function g2(t4) {
          return c2 = void 0, v2 && o2 ? m2(t4) : (o2 = i2 = void 0, a2);
        }
        function j2() {
          var t4 = s(), n3 = y2(t4);
          if (o2 = arguments, i2 = this, l2 = t4, n3) {
            if (c2 === void 0)
              return h2(l2);
            if (p2)
              return clearTimeout(c2), c2 = setTimeout(b2, e2), m2(l2);
          }
          return c2 === void 0 && (c2 = setTimeout(b2, e2)), a2;
        }
        return e2 = E(e2) || 0, r(n2) && (d2 = !!n2.leading, u2 = (p2 = "maxWait" in n2) ? T(E(n2.maxWait) || 0, e2) : u2, v2 = "trailing" in n2 ? !!n2.trailing : v2), j2.cancel = function() {
          c2 !== void 0 && clearTimeout(c2), f2 = 0, o2 = l2 = i2 = c2 = void 0;
        }, j2.flush = function() {
          return c2 === void 0 ? a2 : g2(s());
        }, j2;
      };
      var N = { name: "ckeditor", render() {
        return Object(o.h)(this.tagName);
      }, model: { prop: "modelValue", event: "update:modelValue" }, props: { editor: { type: Function, default: null }, modelValue: { type: String, default: "" }, config: { type: Object, default: () => ({}) }, tagName: { type: String, default: "div" }, disabled: { type: Boolean, default: false } }, data: () => ({ $_instance: null, $_lastEditorData: { type: String, default: "" } }), mounted() {
        const t3 = Object.assign({}, this.config);
        this.modelValue && (t3.initialData = this.modelValue), this.editor.create(this.$el, t3).then((t4) => {
          this.$_instance = t4, t4.isReadOnly = this.disabled, this.$_setUpEditorEvents(), this.$emit("ready", t4);
        }).catch((t4) => {
          console.error(t4);
        });
      }, beforeUnmount() {
        this.$_instance && (this.$_instance.destroy(), this.$_instance = null), this.$emit("destroy", this.$_instance);
      }, watch: { modelValue(t3, e2) {
        t3 !== e2 && t3 !== this.$_lastEditorData && this.$_instance.setData(t3);
      }, disabled(t3) {
        this.$_instance.isReadOnly = t3;
      } }, methods: { $_setUpEditorEvents() {
        const t3 = this.$_instance, e2 = D((e3) => {
          const n2 = this.$_lastEditorData = t3.getData();
          this.$emit("update:modelValue", n2, e3, t3), this.$emit("input", n2, e3, t3);
        }, 300, { leading: true });
        t3.model.document.on("change:data", e2), t3.editing.view.document.on("focus", (e3) => {
          this.$emit("focus", e3, t3);
        }), t3.editing.view.document.on("blur", (e3) => {
          this.$emit("blur", e3, t3);
        });
      } } };
      const k = i.a ? i.a.version : o.version, [M] = k.split(".").map((t3) => parseInt(t3, 10));
      if (M < 3)
        throw new Error("The CKEditor plugin works only with Vue 3+. For more information, please refer to https://ckeditor.com/docs/ckeditor5/latest/builds/guides/integration/frameworks/vuejs-v3.html");
      const P = { install(t3) {
        t3.component("ckeditor", N);
      }, component: N };
      e.default = P;
    }]).default;
  });
})(ckeditor$1);
var CKE = /* @__PURE__ */ getDefaultExportFromCjs(ckeditor$1.exports);
var ckeditor = { exports: {} };
/*!
 * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */
(function(module, exports) {
  !function(e) {
    const t = e.en = e.en || {};
    t.dictionary = Object.assign(t.dictionary || {}, { "%0 of %1": "%0 of %1", Aquamarine: "Aquamarine", Black: "Black", "Block quote": "Block quote", Blue: "Blue", Bold: "Bold", "Break text": "Break text", "Bulleted List": "Bulleted List", Cancel: "Cancel", "Cannot upload file:": "Cannot upload file:", "Centered image": "Centered image", "Change image text alternative": "Change image text alternative", "Choose heading": "Choose heading", Column: "Column", "Could not insert image at the current position.": "Could not insert image at the current position.", "Could not obtain resized image URL.": "Could not obtain resized image URL.", "Decrease indent": "Decrease indent", "Delete column": "Delete column", "Delete row": "Delete row", "Dim grey": "Dim grey", Downloadable: "Downloadable", "Dropdown toolbar": "Dropdown toolbar", "Edit block": "Edit block", "Edit link": "Edit link", "Editor toolbar": "Editor toolbar", "Enter image caption": "Enter image caption", "Full size image": "Full size image", Green: "Green", Grey: "Grey", "Header column": "Header column", "Header row": "Header row", Heading: "Heading", "Heading 1": "Heading 1", "Heading 2": "Heading 2", "Heading 3": "Heading 3", "Heading 4": "Heading 4", "Heading 5": "Heading 5", "Heading 6": "Heading 6", "Image toolbar": "Image toolbar", "image widget": "image widget", "In line": "In line", "Increase indent": "Increase indent", "Insert column left": "Insert column left", "Insert column right": "Insert column right", "Insert image": "Insert image", "Insert image or file": "Insert image or file", "Insert media": "Insert media", "Insert paragraph after block": "Insert paragraph after block", "Insert paragraph before block": "Insert paragraph before block", "Insert row above": "Insert row above", "Insert row below": "Insert row below", "Insert table": "Insert table", "Inserting image failed": "Inserting image failed", Italic: "Italic", "Left aligned image": "Left aligned image", "Light blue": "Light blue", "Light green": "Light green", "Light grey": "Light grey", Link: "Link", "Link URL": "Link URL", "Media URL": "Media URL", "media widget": "media widget", "Merge cell down": "Merge cell down", "Merge cell left": "Merge cell left", "Merge cell right": "Merge cell right", "Merge cell up": "Merge cell up", "Merge cells": "Merge cells", Next: "Next", "Numbered List": "Numbered List", "Open in a new tab": "Open in a new tab", "Open link in new tab": "Open link in new tab", Orange: "Orange", Paragraph: "Paragraph", "Paste the media URL in the input.": "Paste the media URL in the input.", Previous: "Previous", Purple: "Purple", Red: "Red", Redo: "Redo", "Rich Text Editor": "Rich Text Editor", "Rich Text Editor, %0": "Rich Text Editor, %0", "Right aligned image": "Right aligned image", Row: "Row", Save: "Save", "Select all": "Select all", "Select column": "Select column", "Select row": "Select row", "Selecting resized image failed": "Selecting resized image failed", "Show more items": "Show more items", "Side image": "Side image", "Split cell horizontally": "Split cell horizontally", "Split cell vertically": "Split cell vertically", "Table toolbar": "Table toolbar", "Text alternative": "Text alternative", "The URL must not be empty.": "The URL must not be empty.", "This link has no URL": "This link has no URL", "This media URL is not supported.": "This media URL is not supported.", "Tip: Paste the URL into the content to embed faster.": "Tip: Paste the URL into the content to embed faster.", "Toggle caption off": "Toggle caption off", "Toggle caption on": "Toggle caption on", Turquoise: "Turquoise", Undo: "Undo", Unlink: "Unlink", "Upload failed": "Upload failed", "Upload in progress": "Upload in progress", White: "White", "Widget toolbar": "Widget toolbar", "Wrap text": "Wrap text", Yellow: "Yellow" });
  }(window.CKEDITOR_TRANSLATIONS || (window.CKEDITOR_TRANSLATIONS = {})), function(e, t) {
    module.exports = t();
  }(window, function() {
    return function(e) {
      var t = {};
      function i(n) {
        if (t[n])
          return t[n].exports;
        var o = t[n] = { i: n, l: false, exports: {} };
        return e[n].call(o.exports, o, o.exports, i), o.l = true, o.exports;
      }
      return i.m = e, i.c = t, i.d = function(e2, t2, n) {
        i.o(e2, t2) || Object.defineProperty(e2, t2, { enumerable: true, get: n });
      }, i.r = function(e2) {
        typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
      }, i.t = function(e2, t2) {
        if (1 & t2 && (e2 = i(e2)), 8 & t2)
          return e2;
        if (4 & t2 && typeof e2 == "object" && e2 && e2.__esModule)
          return e2;
        var n = Object.create(null);
        if (i.r(n), Object.defineProperty(n, "default", { enumerable: true, value: e2 }), 2 & t2 && typeof e2 != "string")
          for (var o in e2)
            i.d(n, o, function(t3) {
              return e2[t3];
            }.bind(null, o));
        return n;
      }, i.n = function(e2) {
        var t2 = e2 && e2.__esModule ? function() {
          return e2.default;
        } : function() {
          return e2;
        };
        return i.d(t2, "a", t2), t2;
      }, i.o = function(e2, t2) {
        return Object.prototype.hasOwnProperty.call(e2, t2);
      }, i.p = "", i(i.s = 108);
    }([function(e, t, i) {
      i.d(t, "a", function() {
        return n;
      }), i.d(t, "b", function() {
        return o;
      });
      class n extends Error {
        constructor(e2, t2, i2) {
          super(`${e2}${i2 ? " " + JSON.stringify(i2) : ""}${r(e2)}`), this.name = "CKEditorError", this.context = t2, this.data = i2;
        }
        is(e2) {
          return e2 === "CKEditorError";
        }
        static rethrowUnexpectedError(e2, t2) {
          if (e2.is && e2.is("CKEditorError"))
            throw e2;
          const i2 = new n(e2.message, t2);
          throw i2.stack = e2.stack, i2;
        }
      }
      function o(e2, t2) {
        console.warn(...s(e2, t2));
      }
      function r(e2) {
        return "\nRead more: https://ckeditor.com/docs/ckeditor5/latest/framework/guides/support/error-codes.html#error-" + e2;
      }
      function s(e2, t2) {
        const i2 = r(e2);
        return t2 ? [e2, t2, i2] : [e2, i2];
      }
    }, function(e, t, i) {
      var n, o = function() {
        return n === void 0 && (n = Boolean(window && document && document.all && !window.atob)), n;
      }, r = function() {
        var e2 = {};
        return function(t2) {
          if (e2[t2] === void 0) {
            var i2 = document.querySelector(t2);
            if (window.HTMLIFrameElement && i2 instanceof window.HTMLIFrameElement)
              try {
                i2 = i2.contentDocument.head;
              } catch (e3) {
                i2 = null;
              }
            e2[t2] = i2;
          }
          return e2[t2];
        };
      }(), s = [];
      function a(e2) {
        for (var t2 = -1, i2 = 0; i2 < s.length; i2++)
          if (s[i2].identifier === e2) {
            t2 = i2;
            break;
          }
        return t2;
      }
      function c(e2, t2) {
        for (var i2 = {}, n2 = [], o2 = 0; o2 < e2.length; o2++) {
          var r2 = e2[o2], c2 = t2.base ? r2[0] + t2.base : r2[0], l2 = i2[c2] || 0, d2 = "".concat(c2, " ").concat(l2);
          i2[c2] = l2 + 1;
          var h2 = a(d2), u2 = { css: r2[1], media: r2[2], sourceMap: r2[3] };
          h2 !== -1 ? (s[h2].references++, s[h2].updater(u2)) : s.push({ identifier: d2, updater: p(u2, t2), references: 1 }), n2.push(d2);
        }
        return n2;
      }
      function l(e2) {
        var t2 = document.createElement("style"), n2 = e2.attributes || {};
        if (n2.nonce === void 0) {
          var o2 = i.nc;
          o2 && (n2.nonce = o2);
        }
        if (Object.keys(n2).forEach(function(e3) {
          t2.setAttribute(e3, n2[e3]);
        }), typeof e2.insert == "function")
          e2.insert(t2);
        else {
          var s2 = r(e2.insert || "head");
          if (!s2)
            throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
          s2.appendChild(t2);
        }
        return t2;
      }
      var d, h = (d = [], function(e2, t2) {
        return d[e2] = t2, d.filter(Boolean).join("\n");
      });
      function u(e2, t2, i2, n2) {
        var o2 = i2 ? "" : n2.media ? "@media ".concat(n2.media, " {").concat(n2.css, "}") : n2.css;
        if (e2.styleSheet)
          e2.styleSheet.cssText = h(t2, o2);
        else {
          var r2 = document.createTextNode(o2), s2 = e2.childNodes;
          s2[t2] && e2.removeChild(s2[t2]), s2.length ? e2.insertBefore(r2, s2[t2]) : e2.appendChild(r2);
        }
      }
      function g(e2, t2, i2) {
        var n2 = i2.css, o2 = i2.media, r2 = i2.sourceMap;
        if (o2 ? e2.setAttribute("media", o2) : e2.removeAttribute("media"), r2 && typeof btoa != "undefined" && (n2 += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(r2)))), " */")), e2.styleSheet)
          e2.styleSheet.cssText = n2;
        else {
          for (; e2.firstChild; )
            e2.removeChild(e2.firstChild);
          e2.appendChild(document.createTextNode(n2));
        }
      }
      var m = null, f = 0;
      function p(e2, t2) {
        var i2, n2, o2;
        if (t2.singleton) {
          var r2 = f++;
          i2 = m || (m = l(t2)), n2 = u.bind(null, i2, r2, false), o2 = u.bind(null, i2, r2, true);
        } else
          i2 = l(t2), n2 = g.bind(null, i2, t2), o2 = function() {
            !function(e3) {
              if (e3.parentNode === null)
                return false;
              e3.parentNode.removeChild(e3);
            }(i2);
          };
        return n2(e2), function(t3) {
          if (t3) {
            if (t3.css === e2.css && t3.media === e2.media && t3.sourceMap === e2.sourceMap)
              return;
            n2(e2 = t3);
          } else
            o2();
        };
      }
      e.exports = function(e2, t2) {
        (t2 = t2 || {}).singleton || typeof t2.singleton == "boolean" || (t2.singleton = o());
        var i2 = c(e2 = e2 || [], t2);
        return function(e3) {
          if (e3 = e3 || [], Object.prototype.toString.call(e3) === "[object Array]") {
            for (var n2 = 0; n2 < i2.length; n2++) {
              var o2 = a(i2[n2]);
              s[o2].references--;
            }
            for (var r2 = c(e3, t2), l2 = 0; l2 < i2.length; l2++) {
              var d2 = a(i2[l2]);
              s[d2].references === 0 && (s[d2].updater(), s.splice(d2, 1));
            }
            i2 = r2;
          }
        };
      };
    }, , function(e, t, i) {
      var n = i(8), o = typeof self == "object" && self && self.Object === Object && self, r = n.a || o || Function("return this")();
      t.a = r;
    }, function(e, t, i) {
      (function(e2) {
        var n = i(3), o = i(14), r = exports && !exports.nodeType && exports, s = r && typeof e2 == "object" && e2 && !e2.nodeType && e2, a = s && s.exports === r ? n.a.Buffer : void 0, c = (a ? a.isBuffer : void 0) || o.a;
        t.a = c;
      }).call(this, i(10)(e));
    }, function(e, t, i) {
      (function(e2) {
        var n = i(8), o = exports && !exports.nodeType && exports, r = o && typeof e2 == "object" && e2 && !e2.nodeType && e2, s = r && r.exports === o && n.a.process, a = function() {
          try {
            var e3 = r && r.require && r.require("util").types;
            return e3 || s && s.binding && s.binding("util");
          } catch (e4) {
          }
        }();
        t.a = a;
      }).call(this, i(10)(e));
    }, function(e, t, i) {
      (function(e2) {
        var t2 = i(0);
        const n = typeof window == "object" ? window : e2;
        if (n.CKEDITOR_VERSION)
          throw new t2.a("ckeditor-duplicated-modules", null);
        n.CKEDITOR_VERSION = "30.0.0";
      }).call(this, i(12));
    }, function(e, t, i) {
      var n = i(1), o = i(76);
      typeof (o = o.__esModule ? o.default : o) == "string" && (o = [[e.i, o, ""]]);
      var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      n(o, r);
      e.exports = o.locals || {};
    }, function(e, t, i) {
      (function(e2) {
        var i2 = typeof e2 == "object" && e2 && e2.Object === Object && e2;
        t.a = i2;
      }).call(this, i(12));
    }, function(e, t, i) {
      (function(e2) {
        var n = i(3), o = exports && !exports.nodeType && exports, r = o && typeof e2 == "object" && e2 && !e2.nodeType && e2, s = r && r.exports === o ? n.a.Buffer : void 0, a = s ? s.allocUnsafe : void 0;
        t.a = function(e3, t2) {
          if (t2)
            return e3.slice();
          var i2 = e3.length, n2 = a ? a(i2) : new e3.constructor(i2);
          return e3.copy(n2), n2;
        };
      }).call(this, i(10)(e));
    }, function(e, t) {
      e.exports = function(e2) {
        if (!e2.webpackPolyfill) {
          var t2 = Object.create(e2);
          t2.children || (t2.children = []), Object.defineProperty(t2, "loaded", { enumerable: true, get: function() {
            return t2.l;
          } }), Object.defineProperty(t2, "id", { enumerable: true, get: function() {
            return t2.i;
          } }), Object.defineProperty(t2, "exports", { enumerable: true }), t2.webpackPolyfill = 1;
        }
        return t2;
      };
    }, function(e, t, i) {
      var n = i(1), o = i(77);
      typeof (o = o.__esModule ? o.default : o) == "string" && (o = [[e.i, o, ""]]);
      var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      n(o, r);
      e.exports = o.locals || {};
    }, function(e, t) {
      var i;
      i = function() {
        return this;
      }();
      try {
        i = i || new Function("return this")();
      } catch (e2) {
        typeof window == "object" && (i = window);
      }
      e.exports = i;
    }, function(e, t, i) {
      var n = i(1), o = i(71);
      typeof (o = o.__esModule ? o.default : o) == "string" && (o = [[e.i, o, ""]]);
      var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      n(o, r);
      e.exports = o.locals || {};
    }, function(e, t, i) {
      t.a = function() {
        return false;
      };
    }, function(e, t, i) {
      var n = i(1), o = i(16);
      typeof (o = o.__esModule ? o.default : o) == "string" && (o = [[e.i, o, ""]]);
      var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      n(o, r);
      e.exports = o.locals || {};
    }, function(e, t) {
      e.exports = ".ck-hidden{display:none!important}.ck.ck-reset,.ck.ck-reset_all,.ck.ck-reset_all *{box-sizing:border-box;width:auto;height:auto;position:static}:root{--ck-z-default:1;--ck-z-modal:calc(var(--ck-z-default) + 999)}.ck-transitions-disabled,.ck-transitions-disabled *{transition:none!important}:root{--ck-color-base-foreground:#fafafa;--ck-color-base-background:#fff;--ck-color-base-border:#c4c4c4;--ck-color-base-action:#61b045;--ck-color-base-focus:#6cb5f9;--ck-color-base-text:#333;--ck-color-base-active:#198cf0;--ck-color-base-active-focus:#0e7fe1;--ck-color-base-error:#db3700;--ck-color-focus-border-coordinates:208,79%,51%;--ck-color-focus-border:hsl(var(--ck-color-focus-border-coordinates));--ck-color-focus-outer-shadow:#bcdefb;--ck-color-focus-disabled-shadow:rgba(119,186,248,0.3);--ck-color-focus-error-shadow:rgba(255,64,31,0.3);--ck-color-text:var(--ck-color-base-text);--ck-color-shadow-drop:rgba(0,0,0,0.15);--ck-color-shadow-drop-active:rgba(0,0,0,0.2);--ck-color-shadow-inner:rgba(0,0,0,0.1);--ck-color-button-default-background:transparent;--ck-color-button-default-hover-background:#e6e6e6;--ck-color-button-default-active-background:#d9d9d9;--ck-color-button-default-active-shadow:#bfbfbf;--ck-color-button-default-disabled-background:transparent;--ck-color-button-on-background:#dedede;--ck-color-button-on-hover-background:#c4c4c4;--ck-color-button-on-active-background:#bababa;--ck-color-button-on-active-shadow:#a1a1a1;--ck-color-button-on-disabled-background:#dedede;--ck-color-button-action-background:var(--ck-color-base-action);--ck-color-button-action-hover-background:#579e3d;--ck-color-button-action-active-background:#53973b;--ck-color-button-action-active-shadow:#498433;--ck-color-button-action-disabled-background:#7ec365;--ck-color-button-action-text:var(--ck-color-base-background);--ck-color-button-save:#008a00;--ck-color-button-cancel:#db3700;--ck-color-switch-button-off-background:#b0b0b0;--ck-color-switch-button-off-hover-background:#a3a3a3;--ck-color-switch-button-on-background:var(--ck-color-button-action-background);--ck-color-switch-button-on-hover-background:#579e3d;--ck-color-switch-button-inner-background:var(--ck-color-base-background);--ck-color-switch-button-inner-shadow:rgba(0,0,0,0.1);--ck-color-dropdown-panel-background:var(--ck-color-base-background);--ck-color-dropdown-panel-border:var(--ck-color-base-border);--ck-color-input-background:var(--ck-color-base-background);--ck-color-input-border:#c7c7c7;--ck-color-input-error-border:var(--ck-color-base-error);--ck-color-input-text:var(--ck-color-base-text);--ck-color-input-disabled-background:#f2f2f2;--ck-color-input-disabled-border:#c7c7c7;--ck-color-input-disabled-text:#757575;--ck-color-list-background:var(--ck-color-base-background);--ck-color-list-button-hover-background:var(--ck-color-button-default-hover-background);--ck-color-list-button-on-background:var(--ck-color-base-active);--ck-color-list-button-on-background-focus:var(--ck-color-base-active-focus);--ck-color-list-button-on-text:var(--ck-color-base-background);--ck-color-panel-background:var(--ck-color-base-background);--ck-color-panel-border:var(--ck-color-base-border);--ck-color-toolbar-background:var(--ck-color-base-foreground);--ck-color-toolbar-border:var(--ck-color-base-border);--ck-color-tooltip-background:var(--ck-color-base-text);--ck-color-tooltip-text:var(--ck-color-base-background);--ck-color-engine-placeholder-text:#707070;--ck-color-upload-bar-background:#6cb5f9;--ck-color-link-default:#0000f0;--ck-color-link-selected-background:rgba(31,177,255,0.1);--ck-color-link-fake-selection:rgba(31,177,255,0.3);--ck-disabled-opacity:.5;--ck-focus-outer-shadow-geometry:0 0 0 3px;--ck-focus-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);--ck-focus-disabled-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);--ck-focus-error-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);--ck-focus-ring:1px solid var(--ck-color-focus-border);--ck-font-size-base:13px;--ck-line-height-base:1.84615;--ck-font-face:Helvetica,Arial,Tahoma,Verdana,Sans-Serif;--ck-font-size-tiny:0.7em;--ck-font-size-small:0.75em;--ck-font-size-normal:1em;--ck-font-size-big:1.4em;--ck-font-size-large:1.8em;--ck-ui-component-min-height:2.3em}.ck.ck-reset,.ck.ck-reset_all,.ck.ck-reset_all *{margin:0;padding:0;border:0;background:transparent;text-decoration:none;vertical-align:middle;transition:none;word-wrap:break-word}.ck.ck-reset_all,.ck.ck-reset_all *{border-collapse:collapse;font:normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);color:var(--ck-color-text);text-align:left;white-space:nowrap;cursor:auto;float:none}.ck.ck-reset_all .ck-rtl *{text-align:right}.ck.ck-reset_all iframe{vertical-align:inherit}.ck.ck-reset_all textarea{white-space:pre-wrap}.ck.ck-reset_all input[type=password],.ck.ck-reset_all input[type=text],.ck.ck-reset_all textarea{cursor:text}.ck.ck-reset_all input[type=password][disabled],.ck.ck-reset_all input[type=text][disabled],.ck.ck-reset_all textarea[disabled]{cursor:default}.ck.ck-reset_all fieldset{padding:10px;border:2px groove #dfdee3}.ck.ck-reset_all button::-moz-focus-inner{padding:0;border:0}.ck[dir=rtl],.ck[dir=rtl] .ck{text-align:right}:root{--ck-border-radius:2px;--ck-inner-shadow:2px 2px 3px var(--ck-color-shadow-inner) inset;--ck-drop-shadow:0 1px 2px 1px var(--ck-color-shadow-drop);--ck-drop-shadow-active:0 3px 6px 1px var(--ck-color-shadow-drop-active);--ck-spacing-unit:0.6em;--ck-spacing-large:calc(var(--ck-spacing-unit)*1.5);--ck-spacing-standard:var(--ck-spacing-unit);--ck-spacing-medium:calc(var(--ck-spacing-unit)*0.8);--ck-spacing-small:calc(var(--ck-spacing-unit)*0.5);--ck-spacing-tiny:calc(var(--ck-spacing-unit)*0.3);--ck-spacing-extra-tiny:calc(var(--ck-spacing-unit)*0.16)}";
    }, function(e, t, i) {
      var n = i(1), o = i(18);
      typeof (o = o.__esModule ? o.default : o) == "string" && (o = [[e.i, o, ""]]);
      var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      n(o, r);
      e.exports = o.locals || {};
    }, function(e, t) {
      e.exports = ".ck.ck-icon{vertical-align:middle}:root{--ck-icon-size:calc(var(--ck-line-height-base)*var(--ck-font-size-normal))}.ck.ck-icon{width:var(--ck-icon-size);height:var(--ck-icon-size);font-size:.8333350694em;will-change:transform}.ck.ck-icon,.ck.ck-icon *{color:inherit;cursor:inherit}.ck.ck-icon :not([fill]){fill:currentColor}";
    }, function(e, t, i) {
      var n = i(1), o = i(20);
      typeof (o = o.__esModule ? o.default : o) == "string" && (o = [[e.i, o, ""]]);
      var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      n(o, r);
      e.exports = o.locals || {};
    }, function(e, t) {
      e.exports = '.ck.ck-tooltip,.ck.ck-tooltip .ck-tooltip__text:after{position:absolute;pointer-events:none;-webkit-backface-visibility:hidden}.ck.ck-tooltip{visibility:hidden;opacity:0;display:none;z-index:var(--ck-z-modal)}.ck.ck-tooltip .ck-tooltip__text{display:inline-block}.ck.ck-tooltip .ck-tooltip__text:after{content:"";width:0;height:0}:root{--ck-tooltip-arrow-size:5px}.ck.ck-tooltip{left:50%;top:0;transition:opacity .2s ease-in-out .2s}.ck.ck-tooltip .ck-tooltip__text{border-radius:0}.ck-rounded-corners .ck.ck-tooltip .ck-tooltip__text,.ck.ck-tooltip .ck-tooltip__text.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-tooltip .ck-tooltip__text{font-size:.9em;line-height:1.5;color:var(--ck-color-tooltip-text);padding:var(--ck-spacing-small) var(--ck-spacing-medium);background:var(--ck-color-tooltip-background);position:relative;left:-50%}.ck.ck-tooltip .ck-tooltip__text:after{transition:opacity .2s ease-in-out .2s;border-style:solid;left:50%}.ck.ck-tooltip.ck-tooltip_s,.ck.ck-tooltip.ck-tooltip_se,.ck.ck-tooltip.ck-tooltip_sw{bottom:calc(var(--ck-tooltip-arrow-size)*-1);transform:translateY(100%)}.ck.ck-tooltip.ck-tooltip_s .ck-tooltip__text:after,.ck.ck-tooltip.ck-tooltip_se .ck-tooltip__text:after,.ck.ck-tooltip.ck-tooltip_sw .ck-tooltip__text:after{top:calc(var(--ck-tooltip-arrow-size)*-1 + 1px);transform:translateX(-50%);border-left-color:transparent;border-bottom-color:var(--ck-color-tooltip-background);border-right-color:transparent;border-top-color:transparent;border-left-width:var(--ck-tooltip-arrow-size);border-bottom-width:var(--ck-tooltip-arrow-size);border-right-width:var(--ck-tooltip-arrow-size);border-top-width:0}.ck.ck-tooltip.ck-tooltip_sw{right:50%;left:auto}.ck.ck-tooltip.ck-tooltip_sw .ck-tooltip__text{left:auto;right:calc(var(--ck-tooltip-arrow-size)*-2)}.ck.ck-tooltip.ck-tooltip_sw .ck-tooltip__text:after{left:auto;right:0}.ck.ck-tooltip.ck-tooltip_se{left:50%;right:auto}.ck.ck-tooltip.ck-tooltip_se .ck-tooltip__text{right:auto;left:calc(var(--ck-tooltip-arrow-size)*-2)}.ck.ck-tooltip.ck-tooltip_se .ck-tooltip__text:after{right:auto;left:0;transform:translateX(50%)}.ck.ck-tooltip.ck-tooltip_n{top:calc(var(--ck-tooltip-arrow-size)*-1);transform:translateY(-100%)}.ck.ck-tooltip.ck-tooltip_n .ck-tooltip__text:after{bottom:calc(var(--ck-tooltip-arrow-size)*-1);transform:translateX(-50%);border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;border-top-color:var(--ck-color-tooltip-background);border-left-width:var(--ck-tooltip-arrow-size);border-bottom-width:0;border-right-width:var(--ck-tooltip-arrow-size);border-top-width:var(--ck-tooltip-arrow-size)}.ck.ck-tooltip.ck-tooltip_e{left:calc(100% + var(--ck-tooltip-arrow-size));top:50%}.ck.ck-tooltip.ck-tooltip_e .ck-tooltip__text{left:0;transform:translateY(-50%)}.ck.ck-tooltip.ck-tooltip_e .ck-tooltip__text:after{left:calc(var(--ck-tooltip-arrow-size)*-1);top:calc(50% - var(--ck-tooltip-arrow-size)*1);border-left-color:transparent;border-bottom-color:transparent;border-right-color:var(--ck-color-tooltip-background);border-top-color:transparent;border-left-width:0;border-bottom-width:var(--ck-tooltip-arrow-size);border-right-width:var(--ck-tooltip-arrow-size);border-top-width:var(--ck-tooltip-arrow-size)}.ck.ck-tooltip.ck-tooltip_w{right:calc(100% + var(--ck-tooltip-arrow-size));left:auto;top:50%}.ck.ck-tooltip.ck-tooltip_w .ck-tooltip__text{left:0;transform:translateY(-50%)}.ck.ck-tooltip.ck-tooltip_w .ck-tooltip__text:after{left:100%;top:calc(50% - var(--ck-tooltip-arrow-size)*1);border-left-color:var(--ck-color-tooltip-background);border-bottom-color:transparent;border-right-color:transparent;border-top-color:transparent;border-left-width:var(--ck-tooltip-arrow-size);border-bottom-width:var(--ck-tooltip-arrow-size);border-right-width:0;border-top-width:var(--ck-tooltip-arrow-size)}';
    }, function(e, t, i) {
      var n = i(1), o = i(22);
      typeof (o = o.__esModule ? o.default : o) == "string" && (o = [[e.i, o, ""]]);
      var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      n(o, r);
      e.exports = o.locals || {};
    }, function(e, t) {
      e.exports = ".ck.ck-button,a.ck.ck-button{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-button .ck-tooltip,a.ck.ck-button .ck-tooltip{display:block}@media (hover:none){.ck.ck-button .ck-tooltip,a.ck.ck-button .ck-tooltip{display:none}}.ck.ck-button,a.ck.ck-button{position:relative;display:inline-flex;align-items:center;justify-content:left}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{display:none}.ck.ck-button.ck-button_with-text .ck-button__label,a.ck.ck-button.ck-button_with-text .ck-button__label{display:inline-block}.ck.ck-button:not(.ck-button_with-text),a.ck.ck-button:not(.ck-button_with-text){justify-content:center}.ck.ck-button:hover .ck-tooltip,a.ck.ck-button:hover .ck-tooltip{visibility:visible;opacity:1}.ck.ck-button:focus:not(:hover) .ck-tooltip,a.ck.ck-button:focus:not(:hover) .ck-tooltip{display:none}.ck.ck-button,a.ck.ck-button{background:var(--ck-color-button-default-background)}.ck.ck-button:not(.ck-disabled):hover,a.ck.ck-button:not(.ck-disabled):hover{background:var(--ck-color-button-default-hover-background)}.ck.ck-button:not(.ck-disabled):active,a.ck.ck-button:not(.ck-disabled):active{background:var(--ck-color-button-default-active-background);box-shadow:inset 0 2px 2px var(--ck-color-button-default-active-shadow)}.ck.ck-button.ck-disabled,a.ck.ck-button.ck-disabled{background:var(--ck-color-button-default-disabled-background)}.ck.ck-button,a.ck.ck-button{border-radius:0}.ck-rounded-corners .ck.ck-button,.ck-rounded-corners a.ck.ck-button,.ck.ck-button.ck-rounded-corners,a.ck.ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-button,a.ck.ck-button{white-space:nowrap;cursor:default;vertical-align:middle;padding:var(--ck-spacing-tiny);text-align:center;min-width:var(--ck-ui-component-min-height);min-height:var(--ck-ui-component-min-height);line-height:1;font-size:inherit;border:1px solid transparent;transition:box-shadow .2s ease-in-out,border .2s ease-in-out;-webkit-appearance:none}.ck.ck-button:active,.ck.ck-button:focus,a.ck.ck-button:active,a.ck.ck-button:focus{outline:none;border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0}.ck.ck-button .ck-button__icon use,.ck.ck-button .ck-button__icon use *,a.ck.ck-button .ck-button__icon use,a.ck.ck-button .ck-button__icon use *{color:inherit}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{font-size:inherit;font-weight:inherit;color:inherit;cursor:inherit;vertical-align:middle}[dir=ltr] .ck.ck-button .ck-button__label,[dir=ltr] a.ck.ck-button .ck-button__label{text-align:left}[dir=rtl] .ck.ck-button .ck-button__label,[dir=rtl] a.ck.ck-button .ck-button__label{text-align:right}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{color:inherit}[dir=ltr] .ck.ck-button .ck-button__keystroke,[dir=ltr] a.ck.ck-button .ck-button__keystroke{margin-left:var(--ck-spacing-large)}[dir=rtl] .ck.ck-button .ck-button__keystroke,[dir=rtl] a.ck.ck-button .ck-button__keystroke{margin-right:var(--ck-spacing-large)}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{font-weight:700;opacity:.7}.ck.ck-button.ck-disabled:active,.ck.ck-button.ck-disabled:focus,a.ck.ck-button.ck-disabled:active,a.ck.ck-button.ck-disabled:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-button.ck-disabled .ck-button__icon,a.ck.ck-button.ck-disabled .ck-button__icon{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-disabled .ck-button__label,a.ck.ck-button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-disabled .ck-button__keystroke,a.ck.ck-button.ck-disabled .ck-button__keystroke{opacity:.3}.ck.ck-button.ck-button_with-text,a.ck.ck-button.ck-button_with-text{padding:var(--ck-spacing-tiny) var(--ck-spacing-standard)}[dir=ltr] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=ltr] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:calc(var(--ck-spacing-small)*-1);margin-right:var(--ck-spacing-small)}[dir=rtl] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=rtl] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-right:calc(var(--ck-spacing-small)*-1);margin-left:var(--ck-spacing-small)}.ck.ck-button.ck-button_with-keystroke .ck-button__label,a.ck.ck-button.ck-button_with-keystroke .ck-button__label{flex-grow:1}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{background:var(--ck-color-button-on-background)}.ck.ck-button.ck-on:not(.ck-disabled):hover,a.ck.ck-button.ck-on:not(.ck-disabled):hover{background:var(--ck-color-button-on-hover-background)}.ck.ck-button.ck-on:not(.ck-disabled):active,a.ck.ck-button.ck-on:not(.ck-disabled):active{background:var(--ck-color-button-on-active-background);box-shadow:inset 0 2px 2px var(--ck-color-button-on-active-shadow)}.ck.ck-button.ck-on.ck-disabled,a.ck.ck-button.ck-on.ck-disabled{background:var(--ck-color-button-on-disabled-background)}.ck.ck-button.ck-button-save,a.ck.ck-button.ck-button-save{color:var(--ck-color-button-save)}.ck.ck-button.ck-button-cancel,a.ck.ck-button.ck-button-cancel{color:var(--ck-color-button-cancel)}.ck.ck-button-action,a.ck.ck-button-action{background:var(--ck-color-button-action-background)}.ck.ck-button-action:not(.ck-disabled):hover,a.ck.ck-button-action:not(.ck-disabled):hover{background:var(--ck-color-button-action-hover-background)}.ck.ck-button-action:not(.ck-disabled):active,a.ck.ck-button-action:not(.ck-disabled):active{background:var(--ck-color-button-action-active-background);box-shadow:inset 0 2px 2px var(--ck-color-button-action-active-shadow)}.ck.ck-button-action.ck-disabled,a.ck.ck-button-action.ck-disabled{background:var(--ck-color-button-action-disabled-background)}.ck.ck-button-action,a.ck.ck-button-action{color:var(--ck-color-button-action-text)}.ck.ck-button-bold,a.ck.ck-button-bold{font-weight:700}";
    }, function(e, t, i) {
      var n = i(1), o = i(24);
      typeof (o = o.__esModule ? o.default : o) == "string" && (o = [[e.i, o, ""]]);
      var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      n(o, r);
      e.exports = o.locals || {};
    }, function(e, t) {
      e.exports = ".ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{display:block}:root{--ck-switch-button-toggle-width:2.6153846154em;--ck-switch-button-toggle-inner-size:1.0769230769em;--ck-switch-button-toggle-spacing:1px;--ck-switch-button-translation:calc(var(--ck-switch-button-toggle-width) - var(--ck-switch-button-toggle-inner-size) - var(--ck-switch-button-toggle-spacing)*2)}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__label{margin-right:calc(var(--ck-spacing-large)*2)}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__label{margin-left:calc(var(--ck-spacing-large)*2)}.ck.ck-button.ck-switchbutton .ck-button__toggle{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle.ck-rounded-corners{border-radius:var(--ck-border-radius)}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-left:auto}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-right:auto}.ck.ck-button.ck-switchbutton .ck-button__toggle{transition:background .4s ease;width:var(--ck-switch-button-toggle-width);background:var(--ck-color-switch-button-off-background)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:calc(var(--ck-border-radius)*0.5)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{margin:var(--ck-switch-button-toggle-spacing);width:var(--ck-switch-button-toggle-inner-size);height:var(--ck-switch-button-toggle-inner-size);background:var(--ck-color-switch-button-inner-background);transition:all .3s ease}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover{background:var(--ck-color-switch-button-off-hover-background)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover .ck-button__toggle__inner{box-shadow:0 0 0 5px var(--ck-color-switch-button-inner-shadow)}.ck.ck-button.ck-switchbutton.ck-disabled .ck-button__toggle{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle{background:var(--ck-color-switch-button-on-background)}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle:hover{background:var(--ck-color-switch-button-on-hover-background)}[dir=ltr] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(var(--ck-switch-button-translation))}[dir=rtl] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(calc(var(--ck-switch-button-translation)*-1))}";
    }, function(e, t, i) {
      var n = i(1), o = i(26);
      typeof (o = o.__esModule ? o.default : o) == "string" && (o = [[e.i, o, ""]]);
      var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      n(o, r);
      e.exports = o.locals || {};
    }, function(e, t) {
      e.exports = ".ck.ck-color-grid{display:grid}:root{--ck-color-grid-tile-size:24px;--ck-color-color-grid-check-icon:#000}.ck.ck-color-grid{grid-gap:5px;padding:8px}.ck.ck-color-grid__tile{width:var(--ck-color-grid-tile-size);height:var(--ck-color-grid-tile-size);min-width:var(--ck-color-grid-tile-size);min-height:var(--ck-color-grid-tile-size);padding:0;transition:box-shadow .2s ease;border:0}.ck.ck-color-grid__tile.ck-disabled{cursor:unset;transition:unset}.ck.ck-color-grid__tile.ck-color-table__color-tile_bordered{box-shadow:0 0 0 1px var(--ck-color-base-border)}.ck.ck-color-grid__tile .ck.ck-icon{display:none;color:var(--ck-color-color-grid-check-icon)}.ck.ck-color-grid__tile.ck-on{box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-base-text)}.ck.ck-color-grid__tile.ck-on .ck.ck-icon{display:block}.ck.ck-color-grid__tile.ck-on,.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){border:0}.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-focus-border)}.ck.ck-color-grid__label{padding:0 var(--ck-spacing-standard)}";
    }, function(e, t, i) {
      var n = i(1), o = i(28);
      typeof (o = o.__esModule ? o.default : o) == "string" && (o = [[e.i, o, ""]]);
      var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      n(o, r);
      e.exports = o.locals || {};
    }, function(e, t) {
      e.exports = '.ck.ck-splitbutton{font-size:inherit}.ck.ck-splitbutton .ck-splitbutton__action:focus{z-index:calc(var(--ck-z-default) + 1)}.ck.ck-splitbutton.ck-splitbutton_open>.ck-button .ck-tooltip{display:none}:root{--ck-color-split-button-hover-background:#ebebeb;--ck-color-split-button-hover-border:#b3b3b3}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__action{border-top-right-radius:unset;border-bottom-right-radius:unset}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__action{border-top-left-radius:unset;border-bottom-left-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow{min-width:unset}[dir=ltr] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-top-left-radius:unset;border-bottom-left-radius:unset}[dir=rtl] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-top-right-radius:unset;border-bottom-right-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow svg{width:var(--ck-dropdown-arrow-size)}.ck.ck-splitbutton.ck-splitbutton_open>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover),.ck.ck-splitbutton:hover>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover){background:var(--ck-color-split-button-hover-background)}.ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{content:"";position:absolute;width:1px;height:100%;background-color:var(--ck-color-split-button-hover-border)}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{left:-1px}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{right:-1px}.ck.ck-splitbutton.ck-splitbutton_open{border-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__action{border-bottom-left-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__arrow{border-bottom-right-radius:0}';
    }, function(e, t, i) {
      var n = i(1), o = i(30);
      typeof (o = o.__esModule ? o.default : o) == "string" && (o = [[e.i, o, ""]]);
      var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      n(o, r);
      e.exports = o.locals || {};
    }, function(e, t) {
      e.exports = ":root{--ck-dropdown-max-width:75vw}.ck.ck-dropdown{display:inline-block;position:relative}.ck.ck-dropdown .ck-dropdown__arrow{pointer-events:none;z-index:var(--ck-z-default)}.ck.ck-dropdown .ck-button.ck-dropdown__button{width:100%}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on .ck-tooltip{display:none}.ck.ck-dropdown .ck-dropdown__panel{-webkit-backface-visibility:hidden;display:none;z-index:var(--ck-z-modal);max-width:var(--ck-dropdown-max-width);position:absolute}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel-visible{display:inline-block}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw{bottom:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{top:100%;bottom:auto}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se{left:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{right:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s{left:50%;transform:translateX(-50%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw{left:75%;transform:translateX(-75%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme{left:25%;transform:translateX(-25%)}.ck.ck-toolbar .ck-dropdown__panel{z-index:calc(var(--ck-z-modal) + 1)}:root{--ck-dropdown-arrow-size:calc(var(--ck-icon-size)*0.5)}.ck.ck-dropdown{font-size:inherit}.ck.ck-dropdown .ck-dropdown__arrow{width:var(--ck-dropdown-arrow-size)}[dir=ltr] .ck.ck-dropdown .ck-dropdown__arrow{right:var(--ck-spacing-standard);margin-left:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-dropdown .ck-dropdown__arrow{left:var(--ck-spacing-standard);margin-right:var(--ck-spacing-small)}.ck.ck-dropdown.ck-disabled .ck-dropdown__arrow{opacity:var(--ck-disabled-opacity)}[dir=ltr] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-left:var(--ck-spacing-small)}[dir=rtl] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-right:var(--ck-spacing-small)}.ck.ck-dropdown .ck-button.ck-dropdown__button .ck-button__label{width:7em;overflow:hidden;text-overflow:ellipsis}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on{border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-dropdown__button_label-width_auto .ck-button__label{width:auto}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active{box-shadow:none}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active:focus,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active:focus{box-shadow:var(--ck-focus-outer-shadow),0 0}.ck.ck-dropdown__panel{border-radius:0}.ck-rounded-corners .ck.ck-dropdown__panel,.ck.ck-dropdown__panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-dropdown__panel{box-shadow:var(--ck-drop-shadow),0 0;background:var(--ck-color-dropdown-panel-background);border:1px solid var(--ck-color-dropdown-panel-border);bottom:0;min-width:100%}.ck.ck-dropdown__panel.ck-dropdown__panel_se{border-top-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_sw{border-top-right-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_ne{border-bottom-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_nw{border-bottom-right-radius:0}";
    }, function(e, t, i) {
      var n = i(1), o = i(32);
      typeof (o = o.__esModule ? o.default : o) == "string" && (o = [[e.i, o, ""]]);
      var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      n(o, r);
      e.exports = o.locals || {};
    }, function(e, t) {
      e.exports = ".ck.ck-toolbar{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none;display:flex;flex-flow:row nowrap;align-items:center}.ck.ck-toolbar>.ck-toolbar__items{display:flex;flex-flow:row wrap;align-items:center;flex-grow:1}.ck.ck-toolbar .ck.ck-toolbar__separator{display:inline-block}.ck.ck-toolbar .ck.ck-toolbar__separator:first-child,.ck.ck-toolbar .ck.ck-toolbar__separator:last-child{display:none}.ck.ck-toolbar .ck-toolbar__line-break{flex-basis:100%}.ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items{flex-direction:column}.ck.ck-toolbar.ck-toolbar_floating>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck-dropdown__button .ck-dropdown__arrow{display:none}.ck.ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-toolbar,.ck.ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-toolbar{background:var(--ck-color-toolbar-background);padding:0 var(--ck-spacing-small);border:1px solid var(--ck-color-toolbar-border)}.ck.ck-toolbar .ck.ck-toolbar__separator{align-self:stretch;width:1px;min-width:1px;background:var(--ck-color-toolbar-border);margin-top:var(--ck-spacing-small);margin-bottom:var(--ck-spacing-small)}.ck.ck-toolbar .ck-toolbar__line-break{height:0}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break){margin-right:var(--ck-spacing-small)}.ck.ck-toolbar>.ck-toolbar__items:empty+.ck.ck-toolbar__separator{display:none}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break),.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown{margin-top:var(--ck-spacing-small);margin-bottom:var(--ck-spacing-small)}.ck.ck-toolbar.ck-toolbar_vertical{padding:0}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items>.ck{width:100%;margin:0;border-radius:0;border:0}.ck.ck-toolbar.ck-toolbar_compact{padding:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>*{margin:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>:not(:first-child):not(:last-child){border-radius:0}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck.ck-button.ck-dropdown__button{padding-left:var(--ck-spacing-tiny)}.ck-toolbar-container .ck.ck-toolbar{border:0}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck{margin-right:0}.ck.ck-toolbar[dir=rtl]:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-left:0}.ck.ck-toolbar[dir=rtl].ck-toolbar_compact>.ck-toolbar__items>.ck:first-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-top-left-radius:0;border-bottom-left-radius:0}.ck.ck-toolbar[dir=rtl].ck-toolbar_compact>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-top-right-radius:0;border-bottom-right-radius:0}.ck.ck-toolbar[dir=rtl]>.ck.ck-toolbar__separator,[dir=rtl] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=rtl].ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=rtl] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child){margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-right:0}.ck.ck-toolbar[dir=ltr].ck-toolbar_compact>.ck-toolbar__items>.ck:first-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-top-right-radius:0;border-bottom-right-radius:0}.ck.ck-toolbar[dir=ltr].ck-toolbar_compact>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-top-left-radius:0;border-bottom-left-radius:0}.ck.ck-toolbar[dir=ltr]>.ck.ck-toolbar__separator,[dir=ltr] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-right:var(--ck-spacing-small)}.ck.ck-toolbar[dir=ltr].ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=ltr] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child){margin-right:var(--ck-spacing-small)}";
    }, function(e, t, i) {
      var n = i(1), o = i(34);
      typeof (o = o.__esModule ? o.default : o) == "string" && (o = [[e.i, o, ""]]);
      var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      n(o, r);
      e.exports = o.locals || {};
    }, function(e, t) {
      e.exports = ".ck.ck-list{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none;display:flex;flex-direction:column}.ck.ck-list .ck-list__item,.ck.ck-list .ck-list__separator{display:block}.ck.ck-list .ck-list__item>:focus{position:relative;z-index:var(--ck-z-default)}.ck.ck-list{border-radius:0}.ck-rounded-corners .ck.ck-list,.ck.ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-list{list-style-type:none;background:var(--ck-color-list-background)}.ck.ck-list__item{cursor:default;min-width:12em}.ck.ck-list__item .ck-button{min-height:unset;width:100%;text-align:left;border-radius:0;padding:calc(var(--ck-line-height-base)*0.2*var(--ck-font-size-base)) calc(var(--ck-line-height-base)*0.4*var(--ck-font-size-base))}.ck.ck-list__item .ck-button .ck-button__label{line-height:calc(var(--ck-line-height-base)*1.2*var(--ck-font-size-base))}.ck.ck-list__item .ck-button:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on{background:var(--ck-color-list-button-on-background);color:var(--ck-color-list-button-on-text)}.ck.ck-list__item .ck-button.ck-on:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-on-background-focus)}.ck.ck-list__item .ck-button.ck-on:focus:not(.ck-disabled){border-color:var(--ck-color-base-background)}.ck.ck-list__item .ck-button:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background)}.ck.ck-list__item .ck-switchbutton.ck-on{background:var(--ck-color-list-background);color:inherit}.ck.ck-list__item .ck-switchbutton.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background);color:inherit}.ck.ck-list__separator{height:1px;width:100%;background:var(--ck-color-base-border)}";
    }, function(e, t, i) {
      var n = i(1), o = i(36);
      typeof (o = o.__esModule ? o.default : o) == "string" && (o = [[e.i, o, ""]]);
      var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      n(o, r);
      e.exports = o.locals || {};
    }, function(e, t) {
      e.exports = ":root{--ck-toolbar-dropdown-max-width:60vw}.ck.ck-toolbar-dropdown>.ck-dropdown__panel{width:max-content;max-width:var(--ck-toolbar-dropdown-max-width)}.ck.ck-toolbar-dropdown>.ck-dropdown__panel .ck-button:focus{z-index:calc(var(--ck-z-default) + 1)}.ck.ck-toolbar-dropdown .ck-toolbar{border:0}";
    }, function(e, t, i) {
      var n = i(1), o = i(38);
      typeof (o = o.__esModule ? o.default : o) == "string" && (o = [[e.i, o, ""]]);
      var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      n(o, r);
      e.exports = o.locals || {};
    }, function(e, t) {
      e.exports = ".ck.ck-dropdown .ck-dropdown__panel .ck-list{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list,.ck.ck-dropdown .ck-dropdown__panel .ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}";
    }, function(e, t, i) {
      var n = i(1), o = i(40);
      typeof (o = o.__esModule ? o.default : o) == "string" && (o = [[e.i, o, ""]]);
      var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      n(o, r);
      e.exports = o.locals || {};
    }, function(e, t) {
      e.exports = ":root{--ck-color-editable-blur-selection:#d9d9d9}.ck.ck-editor__editable:not(.ck-editor__nested-editable){border-radius:0}.ck-rounded-corners .ck.ck-editor__editable:not(.ck-editor__nested-editable),.ck.ck-editor__editable:not(.ck-editor__nested-editable).ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-editor__editable:not(.ck-editor__nested-editable).ck-focused{outline:none;border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0}.ck.ck-editor__editable_inline{overflow:auto;padding:0 var(--ck-spacing-standard);border:1px solid transparent}.ck.ck-editor__editable_inline[dir=ltr]{text-align:left}.ck.ck-editor__editable_inline[dir=rtl]{text-align:right}.ck.ck-editor__editable_inline>:first-child{margin-top:var(--ck-spacing-large)}.ck.ck-editor__editable_inline>:last-child{margin-bottom:var(--ck-spacing-large)}.ck.ck-editor__editable_inline.ck-blurred ::selection{background:var(--ck-color-editable-blur-selection)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_n]:after{border-bottom-color:var(--ck-color-base-foreground)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_s]:after{border-top-color:var(--ck-color-base-foreground)}";
    }, function(e, t, i) {
      var n = i(1), o = i(42);
      typeof (o = o.__esModule ? o.default : o) == "string" && (o = [[e.i, o, ""]]);
      var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      n(o, r);
      e.exports = o.locals || {};
    }, function(e, t) {
      e.exports = ".ck.ck-label{display:block}.ck.ck-voice-label{display:none}.ck.ck-label{font-weight:700}";
    }, function(e, t, i) {
      var n = i(1), o = i(44);
      typeof (o = o.__esModule ? o.default : o) == "string" && (o = [[e.i, o, ""]]);
      var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      n(o, r);
      e.exports = o.locals || {};
    }, function(e, t) {
      e.exports = ".ck.ck-form__header{display:flex;flex-direction:row;flex-wrap:nowrap;align-items:center;justify-content:space-between}:root{--ck-form-header-height:38px}.ck.ck-form__header{padding:var(--ck-spacing-small) var(--ck-spacing-large);height:var(--ck-form-header-height);line-height:var(--ck-form-header-height);border-bottom:1px solid var(--ck-color-base-border)}.ck.ck-form__header .ck-form__header__label{font-weight:700}";
    }, function(e, t, i) {
      var n = i(1), o = i(46);
      typeof (o = o.__esModule ? o.default : o) == "string" && (o = [[e.i, o, ""]]);
      var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      n(o, r);
      e.exports = o.locals || {};
    }, function(e, t) {
      e.exports = ":root{--ck-input-text-width:18em}.ck.ck-input-text{border-radius:0}.ck-rounded-corners .ck.ck-input-text,.ck.ck-input-text.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-input-text{background:var(--ck-color-input-background);border:1px solid var(--ck-color-input-border);padding:var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);min-width:var(--ck-input-text-width);min-height:var(--ck-ui-component-min-height);transition:box-shadow .1s ease-in-out,border .1s ease-in-out}.ck.ck-input-text:focus{outline:none;border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0}.ck.ck-input-text[readonly]{border:1px solid var(--ck-color-input-disabled-border);background:var(--ck-color-input-disabled-background);color:var(--ck-color-input-disabled-text)}.ck.ck-input-text[readonly]:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-input-text.ck-error{border-color:var(--ck-color-input-error-border);animation:ck-text-input-shake .3s ease both}.ck.ck-input-text.ck-error:focus{box-shadow:var(--ck-focus-error-outer-shadow),0 0}@keyframes ck-text-input-shake{20%{transform:translateX(-2px)}40%{transform:translateX(2px)}60%{transform:translateX(-1px)}80%{transform:translateX(1px)}}";
    }, function(e, t, i) {
      var n = i(1), o = i(48);
      typeof (o = o.__esModule ? o.default : o) == "string" && (o = [[e.i, o, ""]]);
      var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      n(o, r);
      e.exports = o.locals || {};
    }, function(e, t) {
      e.exports = ".ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{display:flex;position:relative}.ck.ck-labeled-field-view .ck.ck-label{display:block;position:absolute}:root{--ck-labeled-field-view-transition:.1s cubic-bezier(0,0,0.24,0.95);--ck-labeled-field-empty-unfocused-max-width:100% - 2 * var(--ck-spacing-medium);--ck-color-labeled-field-label-background:var(--ck-color-base-background)}.ck.ck-labeled-field-view{border-radius:0}.ck-rounded-corners .ck.ck-labeled-field-view,.ck.ck-labeled-field-view.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{width:100%}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{top:0}[dir=ltr] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{left:0}[dir=rtl] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{right:0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{pointer-events:none;transform-origin:0 0;transform:translate(var(--ck-spacing-medium),-6px) scale(.75);background:var(--ck-color-labeled-field-label-background);padding:0 calc(var(--ck-font-size-tiny)*0.5);line-height:normal;font-weight:400;text-overflow:ellipsis;overflow:hidden;max-width:100%;transition:transform var(--ck-labeled-field-view-transition),padding var(--ck-labeled-field-view-transition),background var(--ck-labeled-field-view-transition)}.ck.ck-labeled-field-view.ck-error .ck-input:not([readonly])+.ck.ck-label,.ck.ck-labeled-field-view.ck-error>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view .ck-labeled-field-view__status{font-size:var(--ck-font-size-small);margin-top:var(--ck-spacing-small);white-space:normal}.ck.ck-labeled-field-view .ck-labeled-field-view__status.ck-labeled-field-view__status_error{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view.ck-disabled>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-input-disabled-text)}[dir=ltr] .ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=ltr] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(var(--ck-spacing-medium),calc(var(--ck-font-size-base)*0.6)) scale(1)}[dir=rtl] .ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=rtl] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(calc(var(--ck-spacing-medium)*-1),calc(var(--ck-font-size-base)*0.6)) scale(1)}.ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width));background:transparent;padding:0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck.ck-button{background:transparent}.ck.ck-labeled-field-view.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck-button>.ck-button__label{opacity:0}.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown+.ck-label{max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard))}";
    }, function(e, t, i) {
      var n = i(1), o = i(50);
      typeof (o = o.__esModule ? o.default : o) == "string" && (o = [[e.i, o, ""]]);
      var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      n(o, r);
      e.exports = o.locals || {};
    }, function(e, t) {
      e.exports = ':root{--ck-balloon-panel-arrow-z-index:calc(var(--ck-z-default) - 3)}.ck.ck-balloon-panel{display:none;position:absolute;z-index:var(--ck-z-modal)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{content:"";position:absolute}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_n]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_n]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_s]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_s]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel.ck-balloon-panel_visible{display:block}:root{--ck-balloon-arrow-offset:2px;--ck-balloon-arrow-height:10px;--ck-balloon-arrow-half-width:8px;--ck-balloon-arrow-drop-shadow:0 2px 2px var(--ck-color-shadow-drop)}.ck.ck-balloon-panel{border-radius:0}.ck-rounded-corners .ck.ck-balloon-panel,.ck.ck-balloon-panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-balloon-panel{box-shadow:var(--ck-drop-shadow),0 0;min-height:15px;background:var(--ck-color-panel-background);border:1px solid var(--ck-color-panel-border)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{width:0;height:0;border-style:solid}.ck.ck-balloon-panel[class*=arrow_n]:after,.ck.ck-balloon-panel[class*=arrow_n]:before{border-left-width:var(--ck-balloon-arrow-half-width);border-bottom-width:var(--ck-balloon-arrow-height);border-right-width:var(--ck-balloon-arrow-half-width);border-top-width:0}.ck.ck-balloon-panel[class*=arrow_n]:before{border-bottom-color:var(--ck-color-panel-border)}.ck.ck-balloon-panel[class*=arrow_n]:after,.ck.ck-balloon-panel[class*=arrow_n]:before{border-left-color:transparent;border-right-color:transparent;border-top-color:transparent}.ck.ck-balloon-panel[class*=arrow_n]:after{border-bottom-color:var(--ck-color-panel-background);margin-top:var(--ck-balloon-arrow-offset)}.ck.ck-balloon-panel[class*=arrow_s]:after,.ck.ck-balloon-panel[class*=arrow_s]:before{border-left-width:var(--ck-balloon-arrow-half-width);border-bottom-width:0;border-right-width:var(--ck-balloon-arrow-half-width);border-top-width:var(--ck-balloon-arrow-height)}.ck.ck-balloon-panel[class*=arrow_s]:before{border-top-color:var(--ck-color-panel-border);filter:drop-shadow(var(--ck-balloon-arrow-drop-shadow))}.ck.ck-balloon-panel[class*=arrow_s]:after,.ck.ck-balloon-panel[class*=arrow_s]:before{border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent}.ck.ck-balloon-panel[class*=arrow_s]:after{border-top-color:var(--ck-color-panel-background);margin-bottom:var(--ck-balloon-arrow-offset)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:before{left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:before{left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:before{right:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:before{left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1);bottom:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:before{left:calc(var(--ck-balloon-arrow-half-width)*2);bottom:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:before{right:calc(var(--ck-balloon-arrow-half-width)*2);bottom:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:before{right:25%;margin-right:calc(var(--ck-balloon-arrow-half-width)*2);bottom:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:before{left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2);bottom:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:before{right:25%;margin-right:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:before{left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}';
    }, function(e, t, i) {
      var n = i(1), o = i(52);
      typeof (o = o.__esModule ? o.default : o) == "string" && (o = [[e.i, o, ""]]);
      var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      n(o, r);
      e.exports = o.locals || {};
    }, function(e, t) {
      e.exports = ".ck .ck-balloon-rotator__navigation{display:flex;align-items:center;justify-content:center}.ck .ck-balloon-rotator__content .ck-toolbar{justify-content:center}.ck .ck-balloon-rotator__navigation{background:var(--ck-color-toolbar-background);border-bottom:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation>*{margin-right:var(--ck-spacing-small);margin-top:var(--ck-spacing-small);margin-bottom:var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation .ck-balloon-rotator__counter{margin-right:var(--ck-spacing-standard);margin-left:var(--ck-spacing-small)}.ck .ck-balloon-rotator__content .ck.ck-annotation-wrapper{box-shadow:none}";
    }, function(e, t, i) {
      var n = i(1), o = i(54);
      typeof (o = o.__esModule ? o.default : o) == "string" && (o = [[e.i, o, ""]]);
      var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      n(o, r);
      e.exports = o.locals || {};
    }, function(e, t) {
      e.exports = ".ck .ck-fake-panel{position:absolute;z-index:calc(var(--ck-z-modal) - 1)}.ck .ck-fake-panel div{position:absolute}.ck .ck-fake-panel div:first-child{z-index:2}.ck .ck-fake-panel div:nth-child(2){z-index:1}:root{--ck-balloon-fake-panel-offset-horizontal:6px;--ck-balloon-fake-panel-offset-vertical:6px}.ck .ck-fake-panel div{box-shadow:var(--ck-drop-shadow),0 0;min-height:15px;background:var(--ck-color-panel-background);border:1px solid var(--ck-color-panel-border);border-radius:var(--ck-border-radius);width:100%;height:100%}.ck .ck-fake-panel div:first-child{margin-left:var(--ck-balloon-fake-panel-offset-horizontal);margin-top:var(--ck-balloon-fake-panel-offset-vertical)}.ck .ck-fake-panel div:nth-child(2){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*2);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*2)}.ck .ck-fake-panel div:nth-child(3){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*3);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*3)}.ck .ck-balloon-panel_arrow_s+.ck-fake-panel,.ck .ck-balloon-panel_arrow_se+.ck-fake-panel,.ck .ck-balloon-panel_arrow_sw+.ck-fake-panel{--ck-balloon-fake-panel-offset-vertical:-6px}";
    }, function(e, t, i) {
      var n = i(1), o = i(56);
      typeof (o = o.__esModule ? o.default : o) == "string" && (o = [[e.i, o, ""]]);
      var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      n(o, r);
      e.exports = o.locals || {};
    }, function(e, t) {
      e.exports = ".ck.ck-sticky-panel .ck-sticky-panel__content_sticky{z-index:var(--ck-z-modal);position:fixed;top:0}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky_bottom-limit{top:auto;position:absolute}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky{box-shadow:var(--ck-drop-shadow),0 0;border-width:0 1px 1px;border-top-left-radius:0;border-top-right-radius:0}";
    }, function(e, t, i) {
      var n = i(1), o = i(58);
      typeof (o = o.__esModule ? o.default : o) == "string" && (o = [[e.i, o, ""]]);
      var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      n(o, r);
      e.exports = o.locals || {};
    }, function(e, t) {
      e.exports = ".ck.ck-block-toolbar-button{position:absolute;z-index:var(--ck-z-default)}:root{--ck-color-block-toolbar-button:var(--ck-color-text);--ck-block-toolbar-button-size:var(--ck-font-size-normal)}.ck.ck-block-toolbar-button{color:var(--ck-color-block-toolbar-button);font-size:var(--ck-block-toolbar-size)}";
    }, function(e, t, i) {
      var n = i(1), o = i(60);
      typeof (o = o.__esModule ? o.default : o) == "string" && (o = [[e.i, o, ""]]);
      var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      n(o, r);
      e.exports = o.locals || {};
    }, function(e, t) {
      e.exports = ".ck.ck-placeholder,.ck .ck-placeholder{position:relative}.ck.ck-placeholder:before,.ck .ck-placeholder:before{position:absolute;left:0;right:0;content:attr(data-placeholder);pointer-events:none}.ck.ck-read-only .ck-placeholder:before{display:none}.ck.ck-placeholder:before,.ck .ck-placeholder:before{cursor:text;color:var(--ck-color-engine-placeholder-text)}";
    }, function(e, t, i) {
      var n = i(1), o = i(62);
      typeof (o = o.__esModule ? o.default : o) == "string" && (o = [[e.i, o, ""]]);
      var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      n(o, r);
      e.exports = o.locals || {};
    }, function(e, t) {
      e.exports = ".ck.ck-editor{position:relative}.ck.ck-editor .ck-editor__top .ck-sticky-panel .ck-toolbar{z-index:var(--ck-z-modal)}.ck.ck-editor__top .ck-sticky-panel .ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-editor__top .ck-sticky-panel .ck-toolbar,.ck.ck-editor__top .ck-sticky-panel .ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius);border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-editor__top .ck-sticky-panel .ck-toolbar{border-bottom-width:0}.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar{border-bottom-width:1px;border-radius:0}.ck-rounded-corners .ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar,.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:0}.ck.ck-editor__main>.ck-editor__editable{background:var(--ck-color-base-background);border-radius:0}.ck-rounded-corners .ck.ck-editor__main>.ck-editor__editable,.ck.ck-editor__main>.ck-editor__editable.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}.ck.ck-editor__main>.ck-editor__editable:not(.ck-focused){border-color:var(--ck-color-base-border)}";
    }, function(e, t, i) {
      var n = i(1), o = i(64);
      typeof (o = o.__esModule ? o.default : o) == "string" && (o = [[e.i, o, ""]]);
      var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      n(o, r);
      e.exports = o.locals || {};
    }, function(e, t) {
      e.exports = '.ck .ck-widget .ck-widget__type-around__button{display:block;position:absolute;overflow:hidden;z-index:var(--ck-z-default)}.ck .ck-widget .ck-widget__type-around__button svg{position:absolute;top:50%;left:50%;z-index:calc(var(--ck-z-default) + 2)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_before{top:calc(var(--ck-widget-outline-thickness)*-0.5);left:min(10%,30px);transform:translateY(-50%)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_after{bottom:calc(var(--ck-widget-outline-thickness)*-0.5);right:min(10%,30px);transform:translateY(50%)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{content:"";display:block;position:absolute;top:1px;left:1px;z-index:calc(var(--ck-z-default) + 1)}.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__fake-caret{display:none;position:absolute;left:0;right:0}.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__fake-caret{left:calc(var(--ck-widget-outline-thickness)*-1);right:calc(var(--ck-widget-outline-thickness)*-1)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__fake-caret{top:calc(var(--ck-widget-outline-thickness)*-1 - 1px);display:block}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__fake-caret{bottom:calc(var(--ck-widget-outline-thickness)*-1 - 1px);display:block}.ck.ck-editor__editable.ck-read-only .ck-widget__type-around,.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around,.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around{display:none}:root{--ck-widget-type-around-button-size:20px;--ck-color-widget-type-around-button-active:var(--ck-color-focus-border);--ck-color-widget-type-around-button-hover:var(--ck-color-widget-hover-border);--ck-color-widget-type-around-button-blurred-editable:var(--ck-color-widget-blurred-border);--ck-color-widget-type-around-button-radar-start-alpha:0;--ck-color-widget-type-around-button-radar-end-alpha:.3;--ck-color-widget-type-around-button-icon:var(--ck-color-base-background)}.ck .ck-widget .ck-widget__type-around__button{width:var(--ck-widget-type-around-button-size);height:var(--ck-widget-type-around-button-size);background:var(--ck-color-widget-type-around-button);border-radius:100px;transition:opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);opacity:0;pointer-events:none}.ck .ck-widget .ck-widget__type-around__button svg{width:10px;height:8px;transform:translate(-50%,-50%);transition:transform .5s ease;margin-top:1px}.ck .ck-widget .ck-widget__type-around__button svg *{stroke-dasharray:10;stroke-dashoffset:0;fill:none;stroke:var(--ck-color-widget-type-around-button-icon);stroke-width:1.5px;stroke-linecap:round;stroke-linejoin:round}.ck .ck-widget .ck-widget__type-around__button svg line{stroke-dasharray:7}.ck .ck-widget .ck-widget__type-around__button:hover{animation:ck-widget-type-around-button-sonar 1s ease infinite}.ck .ck-widget .ck-widget__type-around__button:hover svg polyline{animation:ck-widget-type-around-arrow-dash 2s linear}.ck .ck-widget .ck-widget__type-around__button:hover svg line{animation:ck-widget-type-around-arrow-tip-dash 2s linear}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:1;pointer-events:auto}.ck .ck-widget:not(.ck-widget_selected)>.ck-widget__type-around>.ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button-hover)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover{background:var(--ck-color-widget-type-around-button-active)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{width:calc(var(--ck-widget-type-around-button-size) - 2px);height:calc(var(--ck-widget-type-around-button-size) - 2px);border-radius:100px;background:linear-gradient(135deg,hsla(0,0%,100%,0),hsla(0,0%,100%,.3))}.ck .ck-widget.ck-widget_with-selection-handle>.ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:20px}.ck .ck-widget .ck-widget__type-around__fake-caret{pointer-events:none;height:1px;animation:ck-widget-type-around-fake-caret-pulse 1s linear infinite normal forwards;outline:1px solid hsla(0,0%,100%,.5);background:var(--ck-color-base-text)}.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_after,.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_before{outline-color:transparent}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected:hover,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{opacity:0}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer{opacity:0}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:0;margin-right:20px}.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover){background:var(--ck-color-widget-type-around-button-blurred-editable)}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover) svg *{stroke:#999}@keyframes ck-widget-type-around-arrow-dash{0%{stroke-dashoffset:10}20%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-arrow-tip-dash{0%,20%{stroke-dashoffset:7}40%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-button-sonar{0%{box-shadow:0 0 0 0 hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}50%{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-end-alpha))}to{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}}@keyframes ck-widget-type-around-fake-caret-pulse{0%{opacity:1}49%{opacity:1}50%{opacity:0}99%{opacity:0}to{opacity:1}}';
    }, function(e, t, i) {
      var n = i(1), o = i(66);
      typeof (o = o.__esModule ? o.default : o) == "string" && (o = [[e.i, o, ""]]);
      var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      n(o, r);
      e.exports = o.locals || {};
    }, function(e, t) {
      e.exports = ":root{--ck-color-resizer:var(--ck-color-focus-border);--ck-color-resizer-tooltip-background:#262626;--ck-color-resizer-tooltip-text:#f2f2f2;--ck-resizer-border-radius:var(--ck-border-radius);--ck-resizer-tooltip-offset:10px;--ck-resizer-tooltip-height:calc(var(--ck-spacing-small)*2 + 10px)}.ck .ck-widget,.ck .ck-widget.ck-widget_with-selection-handle{position:relative}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{position:absolute}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{display:block}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{visibility:visible}.ck .ck-size-view{background:var(--ck-color-resizer-tooltip-background);color:var(--ck-color-resizer-tooltip-text);border:1px solid var(--ck-color-resizer-tooltip-text);border-radius:var(--ck-resizer-border-radius);font-size:var(--ck-font-size-tiny);display:block;padding:0 var(--ck-spacing-small);height:var(--ck-resizer-tooltip-height);line-height:var(--ck-resizer-tooltip-height)}.ck .ck-size-view.ck-orientation-above-center,.ck .ck-size-view.ck-orientation-bottom-left,.ck .ck-size-view.ck-orientation-bottom-right,.ck .ck-size-view.ck-orientation-top-left,.ck .ck-size-view.ck-orientation-top-right{position:absolute}.ck .ck-size-view.ck-orientation-top-left{top:var(--ck-resizer-tooltip-offset);left:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-top-right{top:var(--ck-resizer-tooltip-offset);right:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-right{bottom:var(--ck-resizer-tooltip-offset);right:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-left{bottom:var(--ck-resizer-tooltip-offset);left:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-above-center{top:calc(var(--ck-resizer-tooltip-height)*-1);left:50%;transform:translate(-50%)}:root{--ck-widget-outline-thickness:3px;--ck-widget-handler-icon-size:16px;--ck-widget-handler-animation-duration:200ms;--ck-widget-handler-animation-curve:ease;--ck-color-widget-blurred-border:#dedede;--ck-color-widget-hover-border:#ffc83d;--ck-color-widget-editable-focus-background:var(--ck-color-base-background);--ck-color-widget-drag-handler-icon-color:var(--ck-color-base-background)}.ck .ck-widget{outline-width:var(--ck-widget-outline-thickness);outline-style:solid;outline-color:transparent;transition:outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_selected,.ck .ck-widget.ck-widget_selected:hover{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border)}.ck .ck-widget:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-editor__nested-editable{border:1px solid transparent}.ck .ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck .ck-editor__nested-editable:focus{outline:none;border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;background-color:var(--ck-color-widget-editable-focus-background)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{padding:4px;box-sizing:border-box;background-color:transparent;opacity:0;transition:background-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),visibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);border-radius:var(--ck-border-radius) var(--ck-border-radius) 0 0;transform:translateY(-100%);left:calc(0px - var(--ck-widget-outline-thickness));top:0}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{width:var(--ck-widget-handler-icon-size);height:var(--ck-widget-handler-icon-size);color:var(--ck-color-widget-drag-handler-icon-color)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:0;transition:opacity .3s var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover .ck-icon .ck-icon__selected-indicator{opacity:1}.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{opacity:1;background-color:var(--ck-color-widget-hover-border)}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{opacity:1;background-color:var(--ck-color-focus-border)}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:1}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{left:auto;right:calc(0px - var(--ck-widget-outline-thickness))}.ck.ck-editor__editable.ck-read-only .ck-widget{transition:none}.ck.ck-editor__editable.ck-read-only .ck-widget:not(.ck-widget_selected){--ck-widget-outline-thickness:0px}.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle,.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover{outline-color:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle>.ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle>.ck-widget__selection-handle:hover,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover.ck-widget_with-selection-handle>.ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover.ck-widget_with-selection-handle>.ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable>.ck-widget.ck-widget_with-selection-handle:first-child,.ck.ck-editor__editable blockquote>.ck-widget.ck-widget_with-selection-handle:first-child{margin-top:calc(1em + var(--ck-widget-handler-icon-size))}";
    }, function(e, t, i) {
      var n = i(1), o = i(68);
      typeof (o = o.__esModule ? o.default : o) == "string" && (o = [[e.i, o, ""]]);
      var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      n(o, r);
      e.exports = o.locals || {};
    }, function(e, t) {
      e.exports = '.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position{display:inline;position:relative;pointer-events:none}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{position:absolute;width:0}.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__selection-handle,.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__type-around{display:none}:root{--ck-clipboard-drop-target-dot-width:12px;--ck-clipboard-drop-target-dot-height:8px;--ck-clipboard-drop-target-color:var(--ck-color-focus-border)}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{bottom:calc(var(--ck-clipboard-drop-target-dot-height)*-0.5);top:calc(var(--ck-clipboard-drop-target-dot-height)*-0.5);border:1px solid var(--ck-clipboard-drop-target-color);background:var(--ck-clipboard-drop-target-color);margin-left:-1px}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span:after{content:"";width:0;height:0;display:block;position:absolute;left:50%;top:calc(var(--ck-clipboard-drop-target-dot-height)*-0.5);transform:translateX(-50%);border-left:calc(var(--ck-clipboard-drop-target-dot-width)*0.5) solid transparent;border-bottom:0 solid transparent;border-right:calc(var(--ck-clipboard-drop-target-dot-width)*0.5) solid transparent;border-top:calc(var(--ck-clipboard-drop-target-dot-height)) solid var(--ck-clipboard-drop-target-color)}.ck.ck-editor__editable .ck-widget.ck-clipboard-drop-target-range{outline:var(--ck-widget-outline-thickness) solid var(--ck-clipboard-drop-target-color)!important}.ck.ck-editor__editable .ck-widget:-webkit-drag{zoom:.6;outline:none!important}';
    }, function(e, t, i) {
      var n = i(1), o = i(70);
      typeof (o = o.__esModule ? o.default : o) == "string" && (o = [[e.i, o, ""]]);
      var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      n(o, r);
      e.exports = o.locals || {};
    }, function(e, t) {
      e.exports = ".ck-content blockquote{overflow:hidden;padding-right:1.5em;padding-left:1.5em;margin-left:0;margin-right:0;font-style:italic;border-left:5px solid #ccc}.ck-content[dir=rtl] blockquote{border-left:0;border-right:5px solid #ccc}";
    }, function(e, t) {
      e.exports = ".ck.ck-heading_heading1{font-size:20px}.ck.ck-heading_heading2{font-size:17px}.ck.ck-heading_heading3{font-size:14px}.ck[class*=ck-heading_heading]{font-weight:700}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__button .ck-button__label{width:8em}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__panel .ck-list__item{min-width:18em}";
    }, function(e, t, i) {
      var n = i(1), o = i(73);
      typeof (o = o.__esModule ? o.default : o) == "string" && (o = [[e.i, o, ""]]);
      var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      n(o, r);
      e.exports = o.locals || {};
    }, function(e, t) {
      e.exports = ".ck .ck-widget_with-resizer{position:relative}.ck .ck-widget__resizer{display:none;position:absolute;pointer-events:none;left:0;top:0}.ck-focused .ck-widget_with-resizer.ck-widget_selected>.ck-widget__resizer{display:block}.ck .ck-widget__resizer__handle{position:absolute;pointer-events:all}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{cursor:nwse-resize}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{cursor:nesw-resize}:root{--ck-resizer-size:10px;--ck-resizer-offset:calc(var(--ck-resizer-size)/-2 - 2px);--ck-resizer-border-width:1px}.ck .ck-widget__resizer{outline:1px solid var(--ck-color-resizer)}.ck .ck-widget__resizer__handle{width:var(--ck-resizer-size);height:var(--ck-resizer-size);background:var(--ck-color-focus-border);border:var(--ck-resizer-border-width) solid #fff;border-radius:var(--ck-resizer-border-radius)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{top:var(--ck-resizer-offset);left:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{top:var(--ck-resizer-offset);right:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right{bottom:var(--ck-resizer-offset);right:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left{bottom:var(--ck-resizer-offset);left:var(--ck-resizer-offset)}";
    }, function(e, t, i) {
      var n = i(1), o = i(75);
      typeof (o = o.__esModule ? o.default : o) == "string" && (o = [[e.i, o, ""]]);
      var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      n(o, r);
      e.exports = o.locals || {};
    }, function(e, t) {
      e.exports = ".ck.ck-text-alternative-form{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-text-alternative-form .ck-labeled-field-view{display:inline-block}.ck.ck-text-alternative-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-text-alternative-form{flex-wrap:wrap}.ck.ck-text-alternative-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-text-alternative-form .ck-button{flex-basis:50%}}";
    }, function(e, t) {
      e.exports = '.ck-vertical-form .ck-button:after{content:"";width:0;position:absolute;right:-1px;top:var(--ck-spacing-small);bottom:var(--ck-spacing-small);z-index:1}@media screen and (max-width:600px){.ck.ck-responsive-form .ck-button:after{content:"";width:0;position:absolute;right:-1px;top:var(--ck-spacing-small);bottom:var(--ck-spacing-small);z-index:1}}.ck-vertical-form>.ck-button:nth-last-child(2):after{border-right:1px solid var(--ck-color-base-border)}.ck.ck-responsive-form{padding:var(--ck-spacing-large)}.ck.ck-responsive-form:focus{outline:none}[dir=ltr] .ck.ck-responsive-form>:not(:first-child),[dir=rtl] .ck.ck-responsive-form>:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-responsive-form{padding:0;width:calc(var(--ck-input-text-width)*0.8)}.ck.ck-responsive-form .ck-labeled-field-view{margin:var(--ck-spacing-large) var(--ck-spacing-large) 0}.ck.ck-responsive-form .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-responsive-form .ck-labeled-field-view .ck-labeled-field-view__error{white-space:normal}.ck.ck-responsive-form>.ck-button:last-child,.ck.ck-responsive-form>.ck-button:nth-last-child(2){padding:var(--ck-spacing-standard);margin-top:var(--ck-spacing-large);border-radius:0;border:0;border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-responsive-form>.ck-button:last-child,[dir=ltr] .ck.ck-responsive-form>.ck-button:nth-last-child(2),[dir=rtl] .ck.ck-responsive-form>.ck-button:last-child,[dir=rtl] .ck.ck-responsive-form>.ck-button:nth-last-child(2){margin-left:0}.ck.ck-responsive-form>.ck-button:nth-last-child(2):after,[dir=rtl] .ck.ck-responsive-form>.ck-button:last-child:last-of-type,[dir=rtl] .ck.ck-responsive-form>.ck-button:nth-last-child(2):last-of-type{border-right:1px solid var(--ck-color-base-border)}}';
    }, function(e, t) {
      e.exports = ".ck-content .image{display:table;clear:both;text-align:center;margin:.9em auto;min-width:50px}.ck-content .image img{display:block;margin:0 auto;max-width:100%;min-width:100%}.ck-content .image-inline{display:inline-flex;max-width:100%;align-items:flex-start}.ck-content .image-inline picture{display:flex}.ck-content .image-inline img,.ck-content .image-inline picture{flex-grow:1;flex-shrink:1;max-width:100%}.ck.ck-editor__editable .image>figcaption.ck-placeholder:before{padding-left:inherit;padding-right:inherit;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.ck.ck-editor__editable .image-inline.ck-widget_selected,.ck.ck-editor__editable .image.ck-widget_selected{z-index:1}.ck.ck-editor__editable .image-inline.ck-widget_selected ::selection{display:none}.ck.ck-editor__editable td .image-inline img,.ck.ck-editor__editable th .image-inline img{max-width:none}";
    }, function(e, t, i) {
      var n = i(1), o = i(79);
      typeof (o = o.__esModule ? o.default : o) == "string" && (o = [[e.i, o, ""]]);
      var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      n(o, r);
      e.exports = o.locals || {};
    }, function(e, t) {
      e.exports = ":root{--ck-color-image-caption-background:#f7f7f7;--ck-color-image-caption-text:#333;--ck-color-image-caption-highligted-background:#fd0}.ck-content .image>figcaption{display:table-caption;caption-side:bottom;word-break:break-word;color:var(--ck-color-image-caption-text);background-color:var(--ck-color-image-caption-background);padding:.6em;font-size:.75em;outline-offset:-1px}.ck.ck-editor__editable .image>figcaption.image__caption_highlighted{animation:ck-image-caption-highlight .6s ease-out}@keyframes ck-image-caption-highlight{0%{background-color:var(--ck-color-image-caption-highligted-background)}to{background-color:var(--ck-color-image-caption-background)}}";
    }, function(e, t, i) {
      var n = i(1), o = i(81);
      typeof (o = o.__esModule ? o.default : o) == "string" && (o = [[e.i, o, ""]]);
      var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      n(o, r);
      e.exports = o.locals || {};
    }, function(e, t) {
      e.exports = ":root{--ck-image-style-spacing:1.5em;--ck-inline-image-style-spacing:calc(var(--ck-image-style-spacing)/2)}.ck-content .image-style-block-align-left,.ck-content .image-style-block-align-right{max-width:calc(100% - var(--ck-image-style-spacing))}.ck-content .image-style-align-left,.ck-content .image-style-align-right{clear:none}.ck-content .image-style-side{float:right;margin-left:var(--ck-image-style-spacing);max-width:50%}.ck-content .image-style-align-left{float:left;margin-right:var(--ck-image-style-spacing)}.ck-content .image-style-align-center{margin-left:auto;margin-right:auto}.ck-content .image-style-align-right{float:right;margin-left:var(--ck-image-style-spacing)}.ck-content .image-style-block-align-right{margin-right:0;margin-left:auto}.ck-content .image-style-block-align-left{margin-left:0;margin-right:auto}.ck-content p+.image-style-align-left,.ck-content p+.image-style-align-right,.ck-content p+.image-style-side{margin-top:0}.ck-content .image-inline.image-style-align-left,.ck-content .image-inline.image-style-align-right{margin-top:var(--ck-inline-image-style-spacing);margin-bottom:var(--ck-inline-image-style-spacing)}.ck-content .image-inline.image-style-align-left{margin-right:var(--ck-inline-image-style-spacing)}.ck-content .image-inline.image-style-align-right{margin-left:var(--ck-inline-image-style-spacing)}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover){background-color:var(--ck-color-button-on-background)}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__action:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__action:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover):after{display:none}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover){background-color:var(--ck-color-button-on-hover-background)}";
    }, function(e, t, i) {
      var n = i(1), o = i(83);
      typeof (o = o.__esModule ? o.default : o) == "string" && (o = [[e.i, o, ""]]);
      var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      n(o, r);
      e.exports = o.locals || {};
    }, function(e, t) {
      e.exports = ".ck.ck-editor__editable .image,.ck.ck-editor__editable .image-inline{position:relative}.ck.ck-editor__editable .image-inline .ck-progress-bar,.ck.ck-editor__editable .image .ck-progress-bar{position:absolute;top:0;left:0}.ck.ck-editor__editable .image-inline.ck-appear,.ck.ck-editor__editable .image.ck-appear{animation:fadeIn .7s}.ck.ck-editor__editable .image-inline .ck-progress-bar,.ck.ck-editor__editable .image .ck-progress-bar{height:2px;width:0;background:var(--ck-color-upload-bar-background);transition:width .1s}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}";
    }, function(e, t, i) {
      var n = i(1), o = i(85);
      typeof (o = o.__esModule ? o.default : o) == "string" && (o = [[e.i, o, ""]]);
      var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      n(o, r);
      e.exports = o.locals || {};
    }, function(e, t) {
      e.exports = '.ck-image-upload-complete-icon{display:block;position:absolute;top:min(var(--ck-spacing-medium),6%);right:min(var(--ck-spacing-medium),6%);border-radius:50%;z-index:1}.ck-image-upload-complete-icon:after{content:"";position:absolute}:root{--ck-color-image-upload-icon:#fff;--ck-color-image-upload-icon-background:#008a00;--ck-image-upload-icon-size:20;--ck-image-upload-icon-width:2px;--ck-image-upload-icon-is-visible:clamp(0px,100% - 50px,1px)}.ck-image-upload-complete-icon{opacity:0;background:var(--ck-color-image-upload-icon-background);animation-name:ck-upload-complete-icon-show,ck-upload-complete-icon-hide;animation-fill-mode:forwards,forwards;animation-duration:.5s,.5s;font-size:calc(1px*var(--ck-image-upload-icon-size));animation-delay:0ms,3s;overflow:hidden;width:calc(var(--ck-image-upload-icon-is-visible)*var(--ck-image-upload-icon-size));height:calc(var(--ck-image-upload-icon-is-visible)*var(--ck-image-upload-icon-size))}.ck-image-upload-complete-icon:after{left:25%;top:50%;opacity:0;height:0;width:0;transform:scaleX(-1) rotate(135deg);transform-origin:left top;border-top:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);border-right:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);animation-name:ck-upload-complete-icon-check;animation-duration:.5s;animation-delay:.5s;animation-fill-mode:forwards;box-sizing:border-box}@keyframes ck-upload-complete-icon-show{0%{opacity:0}to{opacity:1}}@keyframes ck-upload-complete-icon-hide{0%{opacity:1}to{opacity:0}}@keyframes ck-upload-complete-icon-check{0%{opacity:1;width:0;height:0}33%{width:.3em;height:0}to{opacity:1;width:.3em;height:.45em}}';
    }, function(e, t, i) {
      var n = i(1), o = i(87);
      typeof (o = o.__esModule ? o.default : o) == "string" && (o = [[e.i, o, ""]]);
      var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      n(o, r);
      e.exports = o.locals || {};
    }, function(e, t) {
      e.exports = '.ck .ck-upload-placeholder-loader{position:absolute;display:flex;align-items:center;justify-content:center;top:0;left:0}.ck .ck-upload-placeholder-loader:before{content:"";position:relative}:root{--ck-color-upload-placeholder-loader:#b3b3b3;--ck-upload-placeholder-loader-size:32px}.ck .ck-image-upload-placeholder{width:100%;margin:0}.ck .ck-upload-placeholder-loader{width:100%;height:100%}.ck .ck-upload-placeholder-loader:before{width:var(--ck-upload-placeholder-loader-size);height:var(--ck-upload-placeholder-loader-size);border-radius:50%;border-top:3px solid var(--ck-color-upload-placeholder-loader);border-right:2px solid transparent;animation:ck-upload-placeholder-loader 1s linear infinite}@keyframes ck-upload-placeholder-loader{to{transform:rotate(1turn)}}';
    }, function(e, t, i) {
      var n = i(1), o = i(89);
      typeof (o = o.__esModule ? o.default : o) == "string" && (o = [[e.i, o, ""]]);
      var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      n(o, r);
      e.exports = o.locals || {};
    }, function(e, t) {
      e.exports = ".ck .ck-link_selected{background:var(--ck-color-link-selected-background)}.ck .ck-link_selected span.image-inline{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-link-selected-background)}.ck .ck-fake-link-selection{background:var(--ck-color-link-fake-selection)}.ck .ck-fake-link-selection_collapsed{height:100%;border-right:1px solid var(--ck-color-base-text);margin-right:-1px;outline:1px solid hsla(0,0%,100%,.5)}";
    }, function(e, t, i) {
      var n = i(1), o = i(91);
      typeof (o = o.__esModule ? o.default : o) == "string" && (o = [[e.i, o, ""]]);
      var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      n(o, r);
      e.exports = o.locals || {};
    }, function(e, t) {
      e.exports = ".ck.ck-link-form{display:flex}.ck.ck-link-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-link-form{flex-wrap:wrap}.ck.ck-link-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-link-form .ck-button{flex-basis:50%}}.ck.ck-link-form_layout-vertical{display:block}.ck.ck-link-form_layout-vertical .ck-button.ck-button-cancel,.ck.ck-link-form_layout-vertical .ck-button.ck-button-save{margin-top:var(--ck-spacing-medium)}.ck.ck-link-form_layout-vertical{padding:0;min-width:var(--ck-input-text-width)}.ck.ck-link-form_layout-vertical .ck-labeled-field-view{margin:var(--ck-spacing-large) var(--ck-spacing-large) var(--ck-spacing-small)}.ck.ck-link-form_layout-vertical .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-link-form_layout-vertical .ck-button{padding:var(--ck-spacing-standard);margin:0;border-radius:0;border:0;border-top:1px solid var(--ck-color-base-border);width:50%}[dir=ltr] .ck.ck-link-form_layout-vertical .ck-button,[dir=rtl] .ck.ck-link-form_layout-vertical .ck-button{margin-left:0}[dir=rtl] .ck.ck-link-form_layout-vertical .ck-button:last-of-type{border-right:1px solid var(--ck-color-base-border)}.ck.ck-link-form_layout-vertical .ck.ck-list{margin:var(--ck-spacing-standard) var(--ck-spacing-large)}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton{border:0;padding:0;width:100%}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton:hover{background:none}";
    }, function(e, t, i) {
      var n = i(1), o = i(93);
      typeof (o = o.__esModule ? o.default : o) == "string" && (o = [[e.i, o, ""]]);
      var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      n(o, r);
      e.exports = o.locals || {};
    }, function(e, t) {
      e.exports = ".ck.ck-link-actions{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-link-actions .ck-link-actions__preview{display:inline-block}.ck.ck-link-actions .ck-link-actions__preview .ck-button__label{overflow:hidden}@media screen and (max-width:600px){.ck.ck-link-actions{flex-wrap:wrap}.ck.ck-link-actions .ck-link-actions__preview{flex-basis:100%}.ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){flex-basis:50%}}.ck.ck-link-actions .ck-button.ck-link-actions__preview{padding-left:0;padding-right:0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{padding:0 var(--ck-spacing-medium);color:var(--ck-color-link-default);text-overflow:ellipsis;cursor:pointer;max-width:var(--ck-input-text-width);min-width:3em;text-align:center}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label:hover{text-decoration:underline}.ck.ck-link-actions .ck-button.ck-link-actions__preview,.ck.ck-link-actions .ck-button.ck-link-actions__preview:active,.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus,.ck.ck-link-actions .ck-button.ck-link-actions__preview:hover{background:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:active{box-shadow:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus .ck-button__label{text-decoration:underline}[dir=ltr] .ck.ck-link-actions .ck-button:not(:first-child),[dir=rtl] .ck.ck-link-actions .ck-button:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-link-actions .ck-button.ck-link-actions__preview{margin:var(--ck-spacing-standard) var(--ck-spacing-standard) 0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{min-width:0;max-width:100%}[dir=ltr] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview),[dir=rtl] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){margin-left:0}}";
    }, function(e, t, i) {
      var n = i(1), o = i(95);
      typeof (o = o.__esModule ? o.default : o) == "string" && (o = [[e.i, o, ""]]);
      var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      n(o, r);
      e.exports = o.locals || {};
    }, function(e, t) {
      e.exports = '.ck-media__wrapper .ck-media__placeholder{display:flex;flex-direction:column;align-items:center}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url .ck-tooltip{display:block}@media (hover:none){.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url .ck-tooltip{display:none}}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url{max-width:100%;position:relative}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url:hover .ck-tooltip{visibility:visible;opacity:1}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url .ck-media__placeholder__url__text{overflow:hidden;display:block}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="goo.gl/maps"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="maps.app.goo.gl"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="maps.google.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck-media__placeholder__icon *{display:none}.ck-editor__editable:not(.ck-read-only) .ck-media__wrapper>:not(.ck-media__placeholder),.ck-editor__editable:not(.ck-read-only) .ck-widget:not(.ck-widget_selected) .ck-media__placeholder{pointer-events:none}:root{--ck-media-embed-placeholder-icon-size:3em;--ck-color-media-embed-placeholder-url-text:#757575;--ck-color-media-embed-placeholder-url-text-hover:var(--ck-color-base-text)}.ck-media__wrapper{margin:0 auto}.ck-media__wrapper .ck-media__placeholder{padding:calc(var(--ck-spacing-standard)*3);background:var(--ck-color-base-foreground)}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__icon{min-width:var(--ck-media-embed-placeholder-icon-size);height:var(--ck-media-embed-placeholder-icon-size);margin-bottom:var(--ck-spacing-large);background-position:50%;background-size:cover}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__icon .ck-icon{width:100%;height:100%}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url__text{color:var(--ck-color-media-embed-placeholder-url-text);white-space:nowrap;text-align:center;font-style:italic;text-overflow:ellipsis}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:var(--ck-color-media-embed-placeholder-url-text-hover);cursor:pointer;text-decoration:underline}.ck-media__wrapper[data-oembed-url*="open.spotify.com"]{max-width:300px;max-height:380px}.ck-media__wrapper[data-oembed-url*="goo.gl/maps"] .ck-media__placeholder__icon,.ck-media__wrapper[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon,.ck-media__wrapper[data-oembed-url*="maps.app.goo.gl"] .ck-media__placeholder__icon,.ck-media__wrapper[data-oembed-url*="maps.google.com"] .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNTAuMzc4IiBoZWlnaHQ9IjI1NC4xNjciIHZpZXdCb3g9IjAgMCA2Ni4yNDYgNjcuMjQ4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTcyLjUzMSAtMjE4LjQ1NSkgc2NhbGUoLjk4MDEyKSI+PHJlY3Qgcnk9IjUuMjM4IiByeD0iNS4yMzgiIHk9IjIzMS4zOTkiIHg9IjE3Ni4wMzEiIGhlaWdodD0iNjAuMDk5IiB3aWR0aD0iNjAuMDk5IiBmaWxsPSIjMzRhNjY4IiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxwYXRoIGQ9Ik0yMDYuNDc3IDI2MC45bC0yOC45ODcgMjguOTg3YTUuMjE4IDUuMjE4IDAgMDAzLjc4IDEuNjFoNDkuNjIxYzEuNjk0IDAgMy4xOS0uNzk4IDQuMTQ2LTIuMDM3eiIgZmlsbD0iIzVjODhjNSIvPjxwYXRoIGQ9Ik0yMjYuNzQyIDIyMi45ODhjLTkuMjY2IDAtMTYuNzc3IDcuMTctMTYuNzc3IDE2LjAxNC4wMDcgMi43NjIuNjYzIDUuNDc0IDIuMDkzIDcuODc1LjQzLjcwMy44MyAxLjQwOCAxLjE5IDIuMTA3LjMzMy41MDIuNjUgMS4wMDUuOTUgMS41MDguMzQzLjQ3Ny42NzMuOTU3Ljk4OCAxLjQ0IDEuMzEgMS43NjkgMi41IDMuNTAyIDMuNjM3IDUuMTY4Ljc5MyAxLjI3NSAxLjY4MyAyLjY0IDIuNDY2IDMuOTkgMi4zNjMgNC4wOTQgNC4wMDcgOC4wOTIgNC42IDEzLjkxNHYuMDEyYy4xODIuNDEyLjUxNi42NjYuODc5LjY2Ny40MDMtLjAwMS43NjgtLjMxNC45My0uNzk5LjYwMy01Ljc1NiAyLjIzOC05LjcyOSA0LjU4NS0xMy43OTQuNzgyLTEuMzUgMS42NzMtMi43MTUgMi40NjUtMy45OSAxLjEzNy0xLjY2NiAyLjMyOC0zLjQgMy42MzgtNS4xNjkuMzE1LS40ODIuNjQ1LS45NjIuOTg4LTEuNDM5LjMtLjUwMy42MTctMS4wMDYuOTUtMS41MDguMzU5LS43Ljc2LTEuNDA0IDEuMTktMi4xMDcgMS40MjYtMi40MDIgMi01LjExNCAyLjAwNC03Ljg3NSAwLTguODQ0LTcuNTExLTE2LjAxNC0xNi43NzYtMTYuMDE0eiIgZmlsbD0iI2RkNGIzZSIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48ZWxsaXBzZSByeT0iNS41NjQiIHJ4PSI1LjgyOCIgY3k9IjIzOS4wMDIiIGN4PSIyMjYuNzQyIiBmaWxsPSIjODAyZDI3IiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxwYXRoIGQ9Ik0xOTAuMzAxIDIzNy4yODNjLTQuNjcgMC04LjQ1NyAzLjg1My04LjQ1NyA4LjYwNnMzLjc4NiA4LjYwNyA4LjQ1NyA4LjYwN2MzLjA0MyAwIDQuODA2LS45NTggNi4zMzctMi41MTYgMS41My0xLjU1NyAyLjA4Ny0zLjkxMyAyLjA4Ny02LjI5IDAtLjM2Mi0uMDIzLS43MjItLjA2NC0xLjA3OWgtOC4yNTd2My4wNDNoNC44NWMtLjE5Ny43NTktLjUzMSAxLjQ1LTEuMDU4IDEuOTg2LS45NDIuOTU4LTIuMDI4IDEuNTQ4LTMuOTAxIDEuNTQ4LTIuODc2IDAtNS4yMDgtMi4zNzItNS4yMDgtNS4yOTkgMC0yLjkyNiAyLjMzMi01LjI5OSA1LjIwOC01LjI5OSAxLjM5OSAwIDIuNjE4LjQwNyAzLjU4NCAxLjI5M2wyLjM4MS0yLjM4YzAtLjAwMi0uMDAzLS4wMDQtLjAwNC0uMDA1LTEuNTg4LTEuNTI0LTMuNjItMi4yMTUtNS45NTUtMi4yMTV6bTQuNDMgNS42NmwuMDAzLjAwNnYtLjAwM3oiIGZpbGw9IiNmZmYiIHBhaW50LW9yZGVyPSJtYXJrZXJzIHN0cm9rZSBmaWxsIi8+PHBhdGggZD0iTTIxNS4xODQgMjUxLjkyOWwtNy45OCA3Ljk3OSAyOC40NzcgMjguNDc1YTUuMjMzIDUuMjMzIDAgMDAuNDQ5LTIuMTIzdi0zMS4xNjVjLS40NjkuNjc1LS45MzQgMS4zNDktMS4zODIgMi4wMDUtLjc5MiAxLjI3NS0xLjY4MiAyLjY0LTIuNDY1IDMuOTktMi4zNDcgNC4wNjUtMy45ODIgOC4wMzgtNC41ODUgMTMuNzk0LS4xNjIuNDg1LS41MjcuNzk4LS45My43OTktLjM2My0uMDAxLS42OTctLjI1NS0uODc5LS42Njd2LS4wMTJjLS41OTMtNS44MjItMi4yMzctOS44Mi00LjYtMTMuOTE0LS43ODMtMS4zNS0xLjY3My0yLjcxNS0yLjQ2Ni0zLjk5LTEuMTM3LTEuNjY2LTIuMzI3LTMuNC0zLjYzNy01LjE2OWwtLjAwMi0uMDAzeiIgZmlsbD0iI2MzYzNjMyIvPjxwYXRoIGQ9Ik0yMTIuOTgzIDI0OC40OTVsLTM2Ljk1MiAzNi45NTN2LjgxMmE1LjIyNyA1LjIyNyAwIDAwNS4yMzggNS4yMzhoMS4wMTVsMzUuNjY2LTM1LjY2NmExMzYuMjc1IDEzNi4yNzUgMCAwMC0yLjc2NC0zLjkgMzcuNTc1IDM3LjU3NSAwIDAwLS45ODktMS40NCAzNS4xMjcgMzUuMTI3IDAgMDAtLjk1LTEuNTA4Yy0uMDgzLS4xNjItLjE3Ni0uMzI2LS4yNjQtLjQ4OXoiIGZpbGw9IiNmZGRjNGYiIHBhaW50LW9yZGVyPSJtYXJrZXJzIHN0cm9rZSBmaWxsIi8+PHBhdGggZD0iTTIxMS45OTggMjYxLjA4M2wtNi4xNTIgNi4xNTEgMjQuMjY0IDI0LjI2NGguNzgxYTUuMjI3IDUuMjI3IDAgMDA1LjIzOS01LjIzOHYtMS4wNDV6IiBmaWxsPSIjZmZmIiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjwvZz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder{background:#4268b3}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAyNCIgaGVpZ2h0PSIxMDI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXRoIGQ9Ik05NjcuNDg0IDBINTYuNTE3QzI1LjMwNCAwIDAgMjUuMzA0IDAgNTYuNTE3djkxMC45NjZDMCA5OTguNjk0IDI1LjI5NyAxMDI0IDU2LjUyMiAxMDI0SDU0N1Y2MjhINDE0VjQ3M2gxMzNWMzU5LjAyOWMwLTEzMi4yNjIgODAuNzczLTIwNC4yODIgMTk4Ljc1Ni0yMDQuMjgyIDU2LjUxMyAwIDEwNS4wODYgNC4yMDggMTE5LjI0NCA2LjA4OVYyOTlsLTgxLjYxNi4wMzdjLTYzLjk5MyAwLTc2LjM4NCAzMC40OTItNzYuMzg0IDc1LjIzNlY0NzNoMTUzLjQ4N2wtMTkuOTg2IDE1NUg3MDd2Mzk2aDI2MC40ODRjMzEuMjEzIDAgNTYuNTE2LTI1LjMwMyA1Ni41MTYtNTYuNTE2VjU2LjUxNUMxMDI0IDI1LjMwMyA5OTguNjk3IDAgOTY3LjQ4NCAwIiBmaWxsPSIjRkZGRkZFIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__url__text{color:#cdf}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder{background:linear-gradient(-135deg,#1400c7,#b800b1,#f50000)}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTA0IiBoZWlnaHQ9IjUwNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PGRlZnM+PHBhdGggaWQ9ImEiIGQ9Ik0wIC4xNTloNTAzLjg0MVY1MDMuOTRIMHoiLz48L2RlZnM+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj48bWFzayBpZD0iYiIgZmlsbD0iI2ZmZiI+PHVzZSB4bGluazpocmVmPSIjYSIvPjwvbWFzaz48cGF0aCBkPSJNMjUxLjkyMS4xNTljLTY4LjQxOCAwLTc2Ljk5Ny4yOS0xMDMuODY3IDEuNTE2LTI2LjgxNCAxLjIyMy00NS4xMjcgNS40ODItNjEuMTUxIDExLjcxLTE2LjU2NiA2LjQzNy0zMC42MTUgMTUuMDUxLTQ0LjYyMSAyOS4wNTYtMTQuMDA1IDE0LjAwNi0yMi42MTkgMjguMDU1LTI5LjA1NiA0NC42MjEtNi4yMjggMTYuMDI0LTEwLjQ4NyAzNC4zMzctMTEuNzEgNjEuMTUxQy4yOSAxNzUuMDgzIDAgMTgzLjY2MiAwIDI1Mi4wOGMwIDY4LjQxNy4yOSA3Ni45OTYgMS41MTYgMTAzLjg2NiAxLjIyMyAyNi44MTQgNS40ODIgNDUuMTI3IDExLjcxIDYxLjE1MSA2LjQzNyAxNi41NjYgMTUuMDUxIDMwLjYxNSAyOS4wNTYgNDQuNjIxIDE0LjAwNiAxNC4wMDUgMjguMDU1IDIyLjYxOSA0NC42MjEgMjkuMDU3IDE2LjAyNCA2LjIyNyAzNC4zMzcgMTAuNDg2IDYxLjE1MSAxMS43MDkgMjYuODcgMS4yMjYgMzUuNDQ5IDEuNTE2IDEwMy44NjcgMS41MTYgNjguNDE3IDAgNzYuOTk2LS4yOSAxMDMuODY2LTEuNTE2IDI2LjgxNC0xLjIyMyA0NS4xMjctNS40ODIgNjEuMTUxLTExLjcwOSAxNi41NjYtNi40MzggMzAuNjE1LTE1LjA1MiA0NC42MjEtMjkuMDU3IDE0LjAwNS0xNC4wMDYgMjIuNjE5LTI4LjA1NSAyOS4wNTctNDQuNjIxIDYuMjI3LTE2LjAyNCAxMC40ODYtMzQuMzM3IDExLjcwOS02MS4xNTEgMS4yMjYtMjYuODcgMS41MTYtMzUuNDQ5IDEuNTE2LTEwMy44NjYgMC02OC40MTgtLjI5LTc2Ljk5Ny0xLjUxNi0xMDMuODY3LTEuMjIzLTI2LjgxNC01LjQ4Mi00NS4xMjctMTEuNzA5LTYxLjE1MS02LjQzOC0xNi41NjYtMTUuMDUyLTMwLjYxNS0yOS4wNTctNDQuNjIxLTE0LjAwNi0xNC4wMDUtMjguMDU1LTIyLjYxOS00NC42MjEtMjkuMDU2LTE2LjAyNC02LjIyOC0zNC4zMzctMTAuNDg3LTYxLjE1MS0xMS43MUMzMjguOTE3LjQ0OSAzMjAuMzM4LjE1OSAyNTEuOTIxLjE1OXptMCA0NS4zOTFjNjcuMjY1IDAgNzUuMjMzLjI1NyAxMDEuNzk3IDEuNDY5IDI0LjU2MiAxLjEyIDM3LjkwMSA1LjIyNCA0Ni43NzggOC42NzQgMTEuNzU5IDQuNTcgMjAuMTUxIDEwLjAyOSAyOC45NjYgMTguODQ1IDguODE2IDguODE1IDE0LjI3NSAxNy4yMDcgMTguODQ1IDI4Ljk2NiAzLjQ1IDguODc3IDcuNTU0IDIyLjIxNiA4LjY3NCA0Ni43NzggMS4yMTIgMjYuNTY0IDEuNDY5IDM0LjUzMiAxLjQ2OSAxMDEuNzk4IDAgNjcuMjY1LS4yNTcgNzUuMjMzLTEuNDY5IDEwMS43OTctMS4xMiAyNC41NjItNS4yMjQgMzcuOTAxLTguNjc0IDQ2Ljc3OC00LjU3IDExLjc1OS0xMC4wMjkgMjAuMTUxLTE4Ljg0NSAyOC45NjYtOC44MTUgOC44MTYtMTcuMjA3IDE0LjI3NS0yOC45NjYgMTguODQ1LTguODc3IDMuNDUtMjIuMjE2IDcuNTU0LTQ2Ljc3OCA4LjY3NC0yNi41NiAxLjIxMi0zNC41MjcgMS40NjktMTAxLjc5NyAxLjQ2OS02Ny4yNzEgMC03NS4yMzctLjI1Ny0xMDEuNzk4LTEuNDY5LTI0LjU2Mi0xLjEyLTM3LjkwMS01LjIyNC00Ni43NzgtOC42NzQtMTEuNzU5LTQuNTctMjAuMTUxLTEwLjAyOS0yOC45NjYtMTguODQ1LTguODE1LTguODE1LTE0LjI3NS0xNy4yMDctMTguODQ1LTI4Ljk2Ni0zLjQ1LTguODc3LTcuNTU0LTIyLjIxNi04LjY3NC00Ni43NzgtMS4yMTItMjYuNTY0LTEuNDY5LTM0LjUzMi0xLjQ2OS0xMDEuNzk3IDAtNjcuMjY2LjI1Ny03NS4yMzQgMS40NjktMTAxLjc5OCAxLjEyLTI0LjU2MiA1LjIyNC0zNy45MDEgOC42NzQtNDYuNzc4IDQuNTctMTEuNzU5IDEwLjAyOS0yMC4xNTEgMTguODQ1LTI4Ljk2NiA4LjgxNS04LjgxNiAxNy4yMDctMTQuMjc1IDI4Ljk2Ni0xOC44NDUgOC44NzctMy40NSAyMi4yMTYtNy41NTQgNDYuNzc4LTguNjc0IDI2LjU2NC0xLjIxMiAzNC41MzItMS40NjkgMTAxLjc5OC0xLjQ2OXoiIGZpbGw9IiNGRkYiIG1hc2s9InVybCgjYikiLz48cGF0aCBkPSJNMjUxLjkyMSAzMzYuMDUzYy00Ni4zNzggMC04My45NzQtMzcuNTk2LTgzLjk3NC04My45NzMgMC00Ni4zNzggMzcuNTk2LTgzLjk3NCA4My45NzQtODMuOTc0IDQ2LjM3NyAwIDgzLjk3MyAzNy41OTYgODMuOTczIDgzLjk3NCAwIDQ2LjM3Ny0zNy41OTYgODMuOTczLTgzLjk3MyA4My45NzN6bTAtMjEzLjMzOGMtNzEuNDQ3IDAtMTI5LjM2NSA1Ny45MTgtMTI5LjM2NSAxMjkuMzY1IDAgNzEuNDQ2IDU3LjkxOCAxMjkuMzY0IDEyOS4zNjUgMTI5LjM2NCA3MS40NDYgMCAxMjkuMzY0LTU3LjkxOCAxMjkuMzY0LTEyOS4zNjQgMC03MS40NDctNTcuOTE4LTEyOS4zNjUtMTI5LjM2NC0xMjkuMzY1ek00MTYuNjI3IDExNy42MDRjMCAxNi42OTYtMTMuNTM1IDMwLjIzLTMwLjIzMSAzMC4yMy0xNi42OTUgMC0zMC4yMy0xMy41MzQtMzAuMjMtMzAuMjMgMC0xNi42OTYgMTMuNTM1LTMwLjIzMSAzMC4yMy0zMC4yMzEgMTYuNjk2IDAgMzAuMjMxIDEzLjUzNSAzMC4yMzEgMzAuMjMxIiBmaWxsPSIjRkZGIi8+PC9nPjwvc3ZnPg==)}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__url__text{color:#ffe0fe}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder{background:linear-gradient(90deg,#71c6f4,#0d70a5)}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA0MDAgNDAwIj48cGF0aCBkPSJNNDAwIDIwMGMwIDExMC41LTg5LjUgMjAwLTIwMCAyMDBTMCAzMTAuNSAwIDIwMCA4OS41IDAgMjAwIDBzMjAwIDg5LjUgMjAwIDIwMHpNMTYzLjQgMzA1LjVjODguNyAwIDEzNy4yLTczLjUgMTM3LjItMTM3LjIgMC0yLjEgMC00LjItLjEtNi4yIDkuNC02LjggMTcuNi0xNS4zIDI0LjEtMjUtOC42IDMuOC0xNy45IDYuNC0yNy43IDcuNiAxMC02IDE3LjYtMTUuNCAyMS4yLTI2LjctOS4zIDUuNS0xOS42IDkuNS0zMC42IDExLjctOC44LTkuNC0yMS4zLTE1LjItMzUuMi0xNS4yLTI2LjYgMC00OC4yIDIxLjYtNDguMiA0OC4yIDAgMy44LjQgNy41IDEuMyAxMS00MC4xLTItNzUuNi0yMS4yLTk5LjQtNTAuNC00LjEgNy4xLTYuNSAxNS40LTYuNSAyNC4yIDAgMTYuNyA4LjUgMzEuNSAyMS41IDQwLjEtNy45LS4yLTE1LjMtMi40LTIxLjgtNnYuNmMwIDIzLjQgMTYuNiA0Mi44IDM4LjcgNDcuMy00IDEuMS04LjMgMS43LTEyLjcgMS43LTMuMSAwLTYuMS0uMy05LjEtLjkgNi4xIDE5LjIgMjMuOSAzMy4xIDQ1IDMzLjUtMTYuNSAxMi45LTM3LjMgMjAuNi01OS45IDIwLjYtMy45IDAtNy43LS4yLTExLjUtLjcgMjEuMSAxMy44IDQ2LjUgMjEuOCA3My43IDIxLjgiIGZpbGw9IiNmZmYiLz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__url__text{color:#b8e6ff}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}';
    }, function(e, t, i) {
      var n = i(1), o = i(97);
      typeof (o = o.__esModule ? o.default : o) == "string" && (o = [[e.i, o, ""]]);
      var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      n(o, r);
      e.exports = o.locals || {};
    }, function(e, t) {
      e.exports = ".ck.ck-media-form{display:flex;align-items:flex-start;flex-direction:row;flex-wrap:nowrap}.ck.ck-media-form .ck-labeled-field-view{display:inline-block}.ck.ck-media-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-media-form{flex-wrap:wrap}.ck.ck-media-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-media-form .ck-button{flex-basis:50%}}";
    }, function(e, t, i) {
      var n = i(1), o = i(99);
      typeof (o = o.__esModule ? o.default : o) == "string" && (o = [[e.i, o, ""]]);
      var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      n(o, r);
      e.exports = o.locals || {};
    }, function(e, t) {
      e.exports = ".ck-content .media{clear:both;margin:.9em 0;display:block;min-width:15em}";
    }, function(e, t, i) {
      var n = i(1), o = i(101);
      typeof (o = o.__esModule ? o.default : o) == "string" && (o = [[e.i, o, ""]]);
      var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      n(o, r);
      e.exports = o.locals || {};
    }, function(e, t) {
      e.exports = ":root{--ck-color-table-focused-cell-background:rgba(158,207,250,0.3)}.ck-widget.table td.ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck-widget.table td.ck-editor__nested-editable:focus,.ck-widget.table th.ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck-widget.table th.ck-editor__nested-editable:focus{background:var(--ck-color-table-focused-cell-background);border-style:none;outline:1px solid var(--ck-color-focus-border);outline-offset:-1px}";
    }, function(e, t, i) {
      var n = i(1), o = i(103);
      typeof (o = o.__esModule ? o.default : o) == "string" && (o = [[e.i, o, ""]]);
      var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      n(o, r);
      e.exports = o.locals || {};
    }, function(e, t) {
      e.exports = ".ck .ck-insert-table-dropdown__grid{display:flex;flex-direction:row;flex-wrap:wrap}:root{--ck-insert-table-dropdown-padding:10px;--ck-insert-table-dropdown-box-height:11px;--ck-insert-table-dropdown-box-width:12px;--ck-insert-table-dropdown-box-margin:1px}.ck .ck-insert-table-dropdown__grid{width:calc(var(--ck-insert-table-dropdown-box-width)*10 + var(--ck-insert-table-dropdown-box-margin)*20 + var(--ck-insert-table-dropdown-padding)*2);padding:var(--ck-insert-table-dropdown-padding) var(--ck-insert-table-dropdown-padding) 0}.ck .ck-insert-table-dropdown__label{text-align:center}.ck .ck-insert-table-dropdown-grid-box{width:var(--ck-insert-table-dropdown-box-width);height:var(--ck-insert-table-dropdown-box-height);margin:var(--ck-insert-table-dropdown-box-margin);border:1px solid var(--ck-color-base-border);border-radius:1px}.ck .ck-insert-table-dropdown-grid-box.ck-on{border-color:var(--ck-color-focus-border);background:var(--ck-color-focus-outer-shadow)}";
    }, function(e, t, i) {
      var n = i(1), o = i(105);
      typeof (o = o.__esModule ? o.default : o) == "string" && (o = [[e.i, o, ""]]);
      var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      n(o, r);
      e.exports = o.locals || {};
    }, function(e, t) {
      e.exports = ':root{--ck-table-selected-cell-background:rgba(158,207,250,0.3)}.ck.ck-editor__editable .table table td.ck-editor__editable_selected,.ck.ck-editor__editable .table table th.ck-editor__editable_selected{position:relative;caret-color:transparent;outline:unset;box-shadow:unset}.ck.ck-editor__editable .table table td.ck-editor__editable_selected:after,.ck.ck-editor__editable .table table th.ck-editor__editable_selected:after{content:"";pointer-events:none;background-color:var(--ck-table-selected-cell-background);position:absolute;top:0;left:0;right:0;bottom:0}.ck.ck-editor__editable .table table td.ck-editor__editable_selected ::selection,.ck.ck-editor__editable .table table td.ck-editor__editable_selected:focus,.ck.ck-editor__editable .table table th.ck-editor__editable_selected ::selection,.ck.ck-editor__editable .table table th.ck-editor__editable_selected:focus{background-color:transparent}.ck.ck-editor__editable .table table td.ck-editor__editable_selected .ck-widget_selected,.ck.ck-editor__editable .table table th.ck-editor__editable_selected .ck-widget_selected{outline:unset}';
    }, function(e, t, i) {
      var n = i(1), o = i(107);
      typeof (o = o.__esModule ? o.default : o) == "string" && (o = [[e.i, o, ""]]);
      var r = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      n(o, r);
      e.exports = o.locals || {};
    }, function(e, t) {
      e.exports = ".ck-content .table{margin:.9em auto;display:table}.ck-content .table table{border-collapse:collapse;border-spacing:0;width:100%;height:100%;border:1px double #b3b3b3}.ck-content .table table td,.ck-content .table table th{min-width:2em;padding:.4em;border:1px solid #bfbfbf}.ck-content .table table th{font-weight:700;background:hsla(0,0%,0%,5%)}.ck-content[dir=rtl] .table th{text-align:right}.ck-content[dir=ltr] .table th{text-align:left}.ck-editor__editable .ck-table-bogus-paragraph{display:inline-block;width:100%}";
    }, function(e, t, i) {
      i.r(t), i.d(t, "default", function() {
        return Tw;
      });
      var n = function() {
        return function e2() {
          e2.called = true;
        };
      };
      class o {
        constructor(e2, t2) {
          this.source = e2, this.name = t2, this.path = [], this.stop = n(), this.off = n();
        }
      }
      const r = new Array(256).fill().map((e2, t2) => ("0" + t2.toString(16)).slice(-2));
      function s() {
        const e2 = 4294967296 * Math.random() >>> 0, t2 = 4294967296 * Math.random() >>> 0, i2 = 4294967296 * Math.random() >>> 0, n2 = 4294967296 * Math.random() >>> 0;
        return "e" + r[e2 >> 0 & 255] + r[e2 >> 8 & 255] + r[e2 >> 16 & 255] + r[e2 >> 24 & 255] + r[t2 >> 0 & 255] + r[t2 >> 8 & 255] + r[t2 >> 16 & 255] + r[t2 >> 24 & 255] + r[i2 >> 0 & 255] + r[i2 >> 8 & 255] + r[i2 >> 16 & 255] + r[i2 >> 24 & 255] + r[n2 >> 0 & 255] + r[n2 >> 8 & 255] + r[n2 >> 16 & 255] + r[n2 >> 24 & 255];
      }
      var a = { get(e2) {
        return typeof e2 != "number" ? this[e2] || this.normal : e2;
      }, highest: 1e5, high: 1e3, normal: 0, low: -1e3, lowest: -1e5 }, c = (i(6), i(0));
      const l = Symbol("listeningTo"), d = Symbol("emitterId");
      var h = { on(e2, t2, i2 = {}) {
        this.listenTo(this, e2, t2, i2);
      }, once(e2, t2, i2) {
        let n2 = false;
        this.listenTo(this, e2, function(e3, ...i3) {
          n2 || (n2 = true, e3.off(), t2.call(this, e3, ...i3));
        }, i2);
      }, off(e2, t2) {
        this.stopListening(this, e2, t2);
      }, listenTo(e2, t2, i2, n2 = {}) {
        let o2, r2;
        this[l] || (this[l] = {});
        const s2 = this[l];
        g(e2) || u(e2);
        const a2 = g(e2);
        (o2 = s2[a2]) || (o2 = s2[a2] = { emitter: e2, callbacks: {} }), (r2 = o2.callbacks[t2]) || (r2 = o2.callbacks[t2] = []), r2.push(i2), function(e3, t3, i3, n3, o3) {
          t3._addEventListener ? t3._addEventListener(i3, n3, o3) : e3._addEventListener.call(t3, i3, n3, o3);
        }(this, e2, t2, i2, n2);
      }, stopListening(e2, t2, i2) {
        const n2 = this[l];
        let o2 = e2 && g(e2);
        const r2 = n2 && o2 && n2[o2], s2 = r2 && t2 && r2.callbacks[t2];
        if (!(!n2 || e2 && !r2 || t2 && !s2))
          if (i2) {
            b(this, e2, t2, i2);
            s2.indexOf(i2) !== -1 && (s2.length === 1 ? delete r2.callbacks[t2] : b(this, e2, t2, i2));
          } else if (s2) {
            for (; i2 = s2.pop(); )
              b(this, e2, t2, i2);
            delete r2.callbacks[t2];
          } else if (r2) {
            for (t2 in r2.callbacks)
              this.stopListening(e2, t2);
            delete n2[o2];
          } else {
            for (o2 in n2)
              this.stopListening(n2[o2].emitter);
            delete this[l];
          }
      }, fire(e2, ...t2) {
        try {
          const i2 = e2 instanceof o ? e2 : new o(this, e2), n2 = i2.name;
          let r2 = function e3(t3, i3) {
            let n3;
            if (!t3._events || !(n3 = t3._events[i3]) || !n3.callbacks.length)
              return i3.indexOf(":") > -1 ? e3(t3, i3.substr(0, i3.lastIndexOf(":"))) : null;
            return n3.callbacks;
          }(this, n2);
          if (i2.path.push(this), r2) {
            const e3 = [i2, ...t2];
            r2 = Array.from(r2);
            for (let t3 = 0; t3 < r2.length && (r2[t3].callback.apply(this, e3), i2.off.called && (delete i2.off.called, this._removeEventListener(n2, r2[t3].callback)), !i2.stop.called); t3++)
              ;
          }
          if (this._delegations) {
            const e3 = this._delegations.get(n2), o2 = this._delegations.get("*");
            e3 && p(e3, i2, t2), o2 && p(o2, i2, t2);
          }
          return i2.return;
        } catch (e3) {
          c.a.rethrowUnexpectedError(e3, this);
        }
      }, delegate(...e2) {
        return { to: (t2, i2) => {
          this._delegations || (this._delegations = new Map()), e2.forEach((e3) => {
            const n2 = this._delegations.get(e3);
            n2 ? n2.set(t2, i2) : this._delegations.set(e3, new Map([[t2, i2]]));
          });
        } };
      }, stopDelegating(e2, t2) {
        if (this._delegations)
          if (e2)
            if (t2) {
              const i2 = this._delegations.get(e2);
              i2 && i2.delete(t2);
            } else
              this._delegations.delete(e2);
          else
            this._delegations.clear();
      }, _addEventListener(e2, t2, i2) {
        !function(e3, t3) {
          const i3 = m(e3);
          if (i3[t3])
            return;
          let n3 = t3, o3 = null;
          const r3 = [];
          for (; n3 !== "" && !i3[n3]; )
            i3[n3] = { callbacks: [], childEvents: [] }, r3.push(i3[n3]), o3 && i3[n3].childEvents.push(o3), o3 = n3, n3 = n3.substr(0, n3.lastIndexOf(":"));
          if (n3 !== "") {
            for (const e4 of r3)
              e4.callbacks = i3[n3].callbacks.slice();
            i3[n3].childEvents.push(o3);
          }
        }(this, e2);
        const n2 = f(this, e2), o2 = a.get(i2.priority), r2 = { callback: t2, priority: o2 };
        for (const e3 of n2) {
          let t3 = false;
          for (let i3 = 0; i3 < e3.length; i3++)
            if (e3[i3].priority < o2) {
              e3.splice(i3, 0, r2), t3 = true;
              break;
            }
          t3 || e3.push(r2);
        }
      }, _removeEventListener(e2, t2) {
        const i2 = f(this, e2);
        for (const e3 of i2)
          for (let i3 = 0; i3 < e3.length; i3++)
            e3[i3].callback == t2 && (e3.splice(i3, 1), i3--);
      } };
      function u(e2, t2) {
        e2[d] || (e2[d] = t2 || s());
      }
      function g(e2) {
        return e2[d];
      }
      function m(e2) {
        return e2._events || Object.defineProperty(e2, "_events", { value: {} }), e2._events;
      }
      function f(e2, t2) {
        const i2 = m(e2)[t2];
        if (!i2)
          return [];
        let n2 = [i2.callbacks];
        for (let t3 = 0; t3 < i2.childEvents.length; t3++) {
          const o2 = f(e2, i2.childEvents[t3]);
          n2 = n2.concat(o2);
        }
        return n2;
      }
      function p(e2, t2, i2) {
        for (let [n2, r2] of e2) {
          r2 ? typeof r2 == "function" && (r2 = r2(t2.name)) : r2 = t2.name;
          const e3 = new o(t2.source, r2);
          e3.path = [...t2.path], n2.fire(e3, ...i2);
        }
      }
      function b(e2, t2, i2, n2) {
        t2._removeEventListener ? t2._removeEventListener(i2, n2) : e2._removeEventListener.call(t2, i2, n2);
      }
      var w = function(e2) {
        var t2 = typeof e2;
        return e2 != null && (t2 == "object" || t2 == "function");
      }, k = i(3), _ = k.a.Symbol, v = Object.prototype, y = v.hasOwnProperty, x = v.toString, A = _ ? _.toStringTag : void 0;
      var C = function(e2) {
        var t2 = y.call(e2, A), i2 = e2[A];
        try {
          e2[A] = void 0;
          var n2 = true;
        } catch (e3) {
        }
        var o2 = x.call(e2);
        return n2 && (t2 ? e2[A] = i2 : delete e2[A]), o2;
      }, T = Object.prototype.toString;
      var E = function(e2) {
        return T.call(e2);
      }, I = _ ? _.toStringTag : void 0;
      var S = function(e2) {
        return e2 == null ? e2 === void 0 ? "[object Undefined]" : "[object Null]" : I && I in Object(e2) ? C(e2) : E(e2);
      };
      var P, M = function(e2) {
        if (!w(e2))
          return false;
        var t2 = S(e2);
        return t2 == "[object Function]" || t2 == "[object GeneratorFunction]" || t2 == "[object AsyncFunction]" || t2 == "[object Proxy]";
      }, N = k.a["__core-js_shared__"], R = (P = /[^.]+$/.exec(N && N.keys && N.keys.IE_PROTO || "")) ? "Symbol(src)_1." + P : "";
      var O = function(e2) {
        return !!R && R in e2;
      }, z = Function.prototype.toString;
      var D = function(e2) {
        if (e2 != null) {
          try {
            return z.call(e2);
          } catch (e3) {
          }
          try {
            return e2 + "";
          } catch (e3) {
          }
        }
        return "";
      }, L = /^\[object .+?Constructor\]$/, V = Function.prototype, j = Object.prototype, B = V.toString, F = j.hasOwnProperty, H = RegExp("^" + B.call(F).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
      var U = function(e2) {
        return !(!w(e2) || O(e2)) && (M(e2) ? H : L).test(D(e2));
      };
      var W = function(e2, t2) {
        return e2 == null ? void 0 : e2[t2];
      };
      var q = function(e2, t2) {
        var i2 = W(e2, t2);
        return U(i2) ? i2 : void 0;
      }, $ = function() {
        try {
          var e2 = q(Object, "defineProperty");
          return e2({}, "", {}), e2;
        } catch (e3) {
        }
      }();
      var Y = function(e2, t2, i2) {
        t2 == "__proto__" && $ ? $(e2, t2, { configurable: true, enumerable: true, value: i2, writable: true }) : e2[t2] = i2;
      };
      var G = function(e2, t2) {
        return e2 === t2 || e2 != e2 && t2 != t2;
      }, K = Object.prototype.hasOwnProperty;
      var Q = function(e2, t2, i2) {
        var n2 = e2[t2];
        K.call(e2, t2) && G(n2, i2) && (i2 !== void 0 || t2 in e2) || Y(e2, t2, i2);
      };
      var J = function(e2, t2, i2, n2) {
        var o2 = !i2;
        i2 || (i2 = {});
        for (var r2 = -1, s2 = t2.length; ++r2 < s2; ) {
          var a2 = t2[r2], c2 = n2 ? n2(i2[a2], e2[a2], a2, i2, e2) : void 0;
          c2 === void 0 && (c2 = e2[a2]), o2 ? Y(i2, a2, c2) : Q(i2, a2, c2);
        }
        return i2;
      };
      var Z = function(e2) {
        return e2;
      };
      var X = function(e2, t2, i2) {
        switch (i2.length) {
          case 0:
            return e2.call(t2);
          case 1:
            return e2.call(t2, i2[0]);
          case 2:
            return e2.call(t2, i2[0], i2[1]);
          case 3:
            return e2.call(t2, i2[0], i2[1], i2[2]);
        }
        return e2.apply(t2, i2);
      }, ee = Math.max;
      var te = function(e2, t2, i2) {
        return t2 = ee(t2 === void 0 ? e2.length - 1 : t2, 0), function() {
          for (var n2 = arguments, o2 = -1, r2 = ee(n2.length - t2, 0), s2 = Array(r2); ++o2 < r2; )
            s2[o2] = n2[t2 + o2];
          o2 = -1;
          for (var a2 = Array(t2 + 1); ++o2 < t2; )
            a2[o2] = n2[o2];
          return a2[t2] = i2(s2), X(e2, this, a2);
        };
      };
      var ie = function(e2) {
        return function() {
          return e2;
        };
      }, ne = $ ? function(e2, t2) {
        return $(e2, "toString", { configurable: true, enumerable: false, value: ie(t2), writable: true });
      } : Z, oe = Date.now;
      var re = function(e2) {
        var t2 = 0, i2 = 0;
        return function() {
          var n2 = oe(), o2 = 16 - (n2 - i2);
          if (i2 = n2, o2 > 0) {
            if (++t2 >= 800)
              return arguments[0];
          } else
            t2 = 0;
          return e2.apply(void 0, arguments);
        };
      }(ne);
      var se = function(e2, t2) {
        return re(te(e2, t2, Z), e2 + "");
      };
      var ae = function(e2) {
        return typeof e2 == "number" && e2 > -1 && e2 % 1 == 0 && e2 <= 9007199254740991;
      };
      var ce = function(e2) {
        return e2 != null && ae(e2.length) && !M(e2);
      }, le = /^(?:0|[1-9]\d*)$/;
      var de = function(e2, t2) {
        var i2 = typeof e2;
        return !!(t2 = t2 == null ? 9007199254740991 : t2) && (i2 == "number" || i2 != "symbol" && le.test(e2)) && e2 > -1 && e2 % 1 == 0 && e2 < t2;
      };
      var he = function(e2, t2, i2) {
        if (!w(i2))
          return false;
        var n2 = typeof t2;
        return !!(n2 == "number" ? ce(i2) && de(t2, i2.length) : n2 == "string" && t2 in i2) && G(i2[t2], e2);
      };
      var ue = function(e2) {
        return se(function(t2, i2) {
          var n2 = -1, o2 = i2.length, r2 = o2 > 1 ? i2[o2 - 1] : void 0, s2 = o2 > 2 ? i2[2] : void 0;
          for (r2 = e2.length > 3 && typeof r2 == "function" ? (o2--, r2) : void 0, s2 && he(i2[0], i2[1], s2) && (r2 = o2 < 3 ? void 0 : r2, o2 = 1), t2 = Object(t2); ++n2 < o2; ) {
            var a2 = i2[n2];
            a2 && e2(t2, a2, n2, r2);
          }
          return t2;
        });
      };
      var ge = function(e2, t2) {
        for (var i2 = -1, n2 = Array(e2); ++i2 < e2; )
          n2[i2] = t2(i2);
        return n2;
      };
      var me = function(e2) {
        return e2 != null && typeof e2 == "object";
      };
      var fe = function(e2) {
        return me(e2) && S(e2) == "[object Arguments]";
      }, pe = Object.prototype, be = pe.hasOwnProperty, we = pe.propertyIsEnumerable, ke = fe(function() {
        return arguments;
      }()) ? fe : function(e2) {
        return me(e2) && be.call(e2, "callee") && !we.call(e2, "callee");
      }, _e = Array.isArray, ve = i(4), ye = {};
      ye["[object Float32Array]"] = ye["[object Float64Array]"] = ye["[object Int8Array]"] = ye["[object Int16Array]"] = ye["[object Int32Array]"] = ye["[object Uint8Array]"] = ye["[object Uint8ClampedArray]"] = ye["[object Uint16Array]"] = ye["[object Uint32Array]"] = true, ye["[object Arguments]"] = ye["[object Array]"] = ye["[object ArrayBuffer]"] = ye["[object Boolean]"] = ye["[object DataView]"] = ye["[object Date]"] = ye["[object Error]"] = ye["[object Function]"] = ye["[object Map]"] = ye["[object Number]"] = ye["[object Object]"] = ye["[object RegExp]"] = ye["[object Set]"] = ye["[object String]"] = ye["[object WeakMap]"] = false;
      var xe = function(e2) {
        return me(e2) && ae(e2.length) && !!ye[S(e2)];
      };
      var Ae = function(e2) {
        return function(t2) {
          return e2(t2);
        };
      }, Ce = i(5), Te = Ce.a && Ce.a.isTypedArray, Ee = Te ? Ae(Te) : xe, Ie = Object.prototype.hasOwnProperty;
      var Se = function(e2, t2) {
        var i2 = _e(e2), n2 = !i2 && ke(e2), o2 = !i2 && !n2 && Object(ve.a)(e2), r2 = !i2 && !n2 && !o2 && Ee(e2), s2 = i2 || n2 || o2 || r2, a2 = s2 ? ge(e2.length, String) : [], c2 = a2.length;
        for (var l2 in e2)
          !t2 && !Ie.call(e2, l2) || s2 && (l2 == "length" || o2 && (l2 == "offset" || l2 == "parent") || r2 && (l2 == "buffer" || l2 == "byteLength" || l2 == "byteOffset") || de(l2, c2)) || a2.push(l2);
        return a2;
      }, Pe = Object.prototype;
      var Me = function(e2) {
        var t2 = e2 && e2.constructor;
        return e2 === (typeof t2 == "function" && t2.prototype || Pe);
      };
      var Ne = function(e2) {
        var t2 = [];
        if (e2 != null)
          for (var i2 in Object(e2))
            t2.push(i2);
        return t2;
      }, Re = Object.prototype.hasOwnProperty;
      var Oe = function(e2) {
        if (!w(e2))
          return Ne(e2);
        var t2 = Me(e2), i2 = [];
        for (var n2 in e2)
          (n2 != "constructor" || !t2 && Re.call(e2, n2)) && i2.push(n2);
        return i2;
      };
      var ze = function(e2) {
        return ce(e2) ? Se(e2, true) : Oe(e2);
      }, De = ue(function(e2, t2) {
        J(t2, ze(t2), e2);
      });
      const Le = Symbol("observableProperties"), Ve = Symbol("boundObservables"), je = Symbol("boundProperties"), Be = Symbol("decoratedMethods"), Fe = Symbol("decoratedOriginal"), He = { set(e2, t2) {
        if (w(e2))
          return void Object.keys(e2).forEach((t3) => {
            this.set(t3, e2[t3]);
          }, this);
        We(this);
        const i2 = this[Le];
        if (e2 in this && !i2.has(e2))
          throw new c.a("observable-set-cannot-override", this);
        Object.defineProperty(this, e2, { enumerable: true, configurable: true, get: () => i2.get(e2), set(t3) {
          const n2 = i2.get(e2);
          let o2 = this.fire("set:" + e2, e2, t3, n2);
          o2 === void 0 && (o2 = t3), n2 === o2 && i2.has(e2) || (i2.set(e2, o2), this.fire("change:" + e2, e2, o2, n2));
        } }), this[e2] = t2;
      }, bind(...e2) {
        if (!e2.length || !Ye(e2))
          throw new c.a("observable-bind-wrong-properties", this);
        if (new Set(e2).size !== e2.length)
          throw new c.a("observable-bind-duplicate-properties", this);
        We(this);
        const t2 = this[je];
        e2.forEach((e3) => {
          if (t2.has(e3))
            throw new c.a("observable-bind-rebind", this);
        });
        const i2 = new Map();
        return e2.forEach((e3) => {
          const n2 = { property: e3, to: [] };
          t2.set(e3, n2), i2.set(e3, n2);
        }), { to: qe, toMany: $e, _observable: this, _bindProperties: e2, _to: [], _bindings: i2 };
      }, unbind(...e2) {
        if (!this[Le])
          return;
        const t2 = this[je], i2 = this[Ve];
        if (e2.length) {
          if (!Ye(e2))
            throw new c.a("observable-unbind-wrong-properties", this);
          e2.forEach((e3) => {
            const n2 = t2.get(e3);
            if (!n2)
              return;
            let o2, r2, s2, a2;
            n2.to.forEach((e4) => {
              o2 = e4[0], r2 = e4[1], s2 = i2.get(o2), a2 = s2[r2], a2.delete(n2), a2.size || delete s2[r2], Object.keys(s2).length || (i2.delete(o2), this.stopListening(o2, "change"));
            }), t2.delete(e3);
          });
        } else
          i2.forEach((e3, t3) => {
            this.stopListening(t3, "change");
          }), i2.clear(), t2.clear();
      }, decorate(e2) {
        const t2 = this[e2];
        if (!t2)
          throw new c.a("observablemixin-cannot-decorate-undefined", this, { object: this, methodName: e2 });
        this.on(e2, (e3, i2) => {
          e3.return = t2.apply(this, i2);
        }), this[e2] = function(...t3) {
          return this.fire(e2, t3);
        }, this[e2][Fe] = t2, this[Be] || (this[Be] = []), this[Be].push(e2);
      } };
      De(He, h), He.stopListening = function(e2, t2, i2) {
        if (!e2 && this[Be]) {
          for (const e3 of this[Be])
            this[e3] = this[e3][Fe];
          delete this[Be];
        }
        h.stopListening.call(this, e2, t2, i2);
      };
      var Ue = He;
      function We(e2) {
        e2[Le] || (Object.defineProperty(e2, Le, { value: new Map() }), Object.defineProperty(e2, Ve, { value: new Map() }), Object.defineProperty(e2, je, { value: new Map() }));
      }
      function qe(...e2) {
        const t2 = function(...e3) {
          if (!e3.length)
            throw new c.a("observable-bind-to-parse-error", null);
          const t3 = { to: [] };
          let i3;
          typeof e3[e3.length - 1] == "function" && (t3.callback = e3.pop());
          return e3.forEach((e4) => {
            if (typeof e4 == "string")
              i3.properties.push(e4);
            else {
              if (typeof e4 != "object")
                throw new c.a("observable-bind-to-parse-error", null);
              i3 = { observable: e4, properties: [] }, t3.to.push(i3);
            }
          }), t3;
        }(...e2), i2 = Array.from(this._bindings.keys()), n2 = i2.length;
        if (!t2.callback && t2.to.length > 1)
          throw new c.a("observable-bind-to-no-callback", this);
        if (n2 > 1 && t2.callback)
          throw new c.a("observable-bind-to-extra-callback", this);
        var o2;
        t2.to.forEach((e3) => {
          if (e3.properties.length && e3.properties.length !== n2)
            throw new c.a("observable-bind-to-properties-length", this);
          e3.properties.length || (e3.properties = this._bindProperties);
        }), this._to = t2.to, t2.callback && (this._bindings.get(i2[0]).callback = t2.callback), o2 = this._observable, this._to.forEach((e3) => {
          const t3 = o2[Ve];
          let i3;
          t3.get(e3.observable) || o2.listenTo(e3.observable, "change", (n3, r2) => {
            i3 = t3.get(e3.observable)[r2], i3 && i3.forEach((e4) => {
              Ge(o2, e4.property);
            });
          });
        }), function(e3) {
          let t3;
          e3._bindings.forEach((i3, n3) => {
            e3._to.forEach((o3) => {
              t3 = o3.properties[i3.callback ? 0 : e3._bindProperties.indexOf(n3)], i3.to.push([o3.observable, t3]), function(e4, t4, i4, n4) {
                const o4 = e4[Ve], r2 = o4.get(i4), s2 = r2 || {};
                s2[n4] || (s2[n4] = new Set());
                s2[n4].add(t4), r2 || o4.set(i4, s2);
              }(e3._observable, i3, o3.observable, t3);
            });
          });
        }(this), this._bindProperties.forEach((e3) => {
          Ge(this._observable, e3);
        });
      }
      function $e(e2, t2, i2) {
        if (this._bindings.size > 1)
          throw new c.a("observable-bind-to-many-not-one-binding", this);
        this.to(...function(e3, t3) {
          const i3 = e3.map((e4) => [e4, t3]);
          return Array.prototype.concat.apply([], i3);
        }(e2, t2), i2);
      }
      function Ye(e2) {
        return e2.every((e3) => typeof e3 == "string");
      }
      function Ge(e2, t2) {
        const i2 = e2[je].get(t2);
        let n2;
        i2.callback ? n2 = i2.callback.apply(e2, i2.to.map((e3) => e3[0][e3[1]])) : (n2 = i2.to[0], n2 = n2[0][n2[1]]), Object.prototype.hasOwnProperty.call(e2, t2) ? e2[t2] = n2 : e2.set(t2, n2);
      }
      function Ke(e2, ...t2) {
        t2.forEach((t3) => {
          Object.getOwnPropertyNames(t3).concat(Object.getOwnPropertySymbols(t3)).forEach((i2) => {
            if (i2 in e2.prototype)
              return;
            const n2 = Object.getOwnPropertyDescriptor(t3, i2);
            n2.enumerable = false, Object.defineProperty(e2.prototype, i2, n2);
          });
        });
      }
      class Qe {
        constructor(e2) {
          this.editor = e2, this.set("isEnabled", true), this._disableStack = new Set();
        }
        forceDisabled(e2) {
          this._disableStack.add(e2), this._disableStack.size == 1 && (this.on("set:isEnabled", Je, { priority: "highest" }), this.isEnabled = false);
        }
        clearForceDisabled(e2) {
          this._disableStack.delete(e2), this._disableStack.size == 0 && (this.off("set:isEnabled", Je), this.isEnabled = true);
        }
        destroy() {
          this.stopListening();
        }
        static get isContextPlugin() {
          return false;
        }
      }
      function Je(e2) {
        e2.return = false, e2.stop();
      }
      Ke(Qe, Ue);
      class Ze {
        constructor(e2) {
          this.editor = e2, this.set("value", void 0), this.set("isEnabled", false), this._disableStack = new Set(), this.decorate("execute"), this.listenTo(this.editor.model.document, "change", () => {
            this.refresh();
          }), this.on("execute", (e3) => {
            this.isEnabled || e3.stop();
          }, { priority: "high" }), this.listenTo(e2, "change:isReadOnly", (e3, t2, i2) => {
            i2 ? this.forceDisabled("readOnlyMode") : this.clearForceDisabled("readOnlyMode");
          });
        }
        refresh() {
          this.isEnabled = true;
        }
        forceDisabled(e2) {
          this._disableStack.add(e2), this._disableStack.size == 1 && (this.on("set:isEnabled", Xe, { priority: "highest" }), this.isEnabled = false);
        }
        clearForceDisabled(e2) {
          this._disableStack.delete(e2), this._disableStack.size == 0 && (this.off("set:isEnabled", Xe), this.refresh());
        }
        execute() {
        }
        destroy() {
          this.stopListening();
        }
      }
      function Xe(e2) {
        e2.return = false, e2.stop();
      }
      Ke(Ze, Ue);
      class et extends Ze {
        constructor(e2) {
          super(e2), this._childCommands = [];
        }
        refresh() {
        }
        execute(...e2) {
          const t2 = this._getFirstEnabledCommand();
          return t2 != null && t2.execute(e2);
        }
        registerChildCommand(e2) {
          this._childCommands.push(e2), e2.on("change:isEnabled", () => this._checkEnabled()), this._checkEnabled();
        }
        _checkEnabled() {
          this.isEnabled = !!this._getFirstEnabledCommand();
        }
        _getFirstEnabledCommand() {
          return this._childCommands.find((e2) => e2.isEnabled);
        }
      }
      var tt = function(e2, t2) {
        return function(i2) {
          return e2(t2(i2));
        };
      }, it = tt(Object.getPrototypeOf, Object), nt = Function.prototype, ot = Object.prototype, rt = nt.toString, st = ot.hasOwnProperty, at = rt.call(Object);
      var ct = function(e2) {
        if (!me(e2) || S(e2) != "[object Object]")
          return false;
        var t2 = it(e2);
        if (t2 === null)
          return true;
        var i2 = st.call(t2, "constructor") && t2.constructor;
        return typeof i2 == "function" && i2 instanceof i2 && rt.call(i2) == at;
      };
      var lt = function() {
        this.__data__ = [], this.size = 0;
      };
      var dt = function(e2, t2) {
        for (var i2 = e2.length; i2--; )
          if (G(e2[i2][0], t2))
            return i2;
        return -1;
      }, ht = Array.prototype.splice;
      var ut = function(e2) {
        var t2 = this.__data__, i2 = dt(t2, e2);
        return !(i2 < 0) && (i2 == t2.length - 1 ? t2.pop() : ht.call(t2, i2, 1), --this.size, true);
      };
      var gt = function(e2) {
        var t2 = this.__data__, i2 = dt(t2, e2);
        return i2 < 0 ? void 0 : t2[i2][1];
      };
      var mt = function(e2) {
        return dt(this.__data__, e2) > -1;
      };
      var ft = function(e2, t2) {
        var i2 = this.__data__, n2 = dt(i2, e2);
        return n2 < 0 ? (++this.size, i2.push([e2, t2])) : i2[n2][1] = t2, this;
      };
      function pt(e2) {
        var t2 = -1, i2 = e2 == null ? 0 : e2.length;
        for (this.clear(); ++t2 < i2; ) {
          var n2 = e2[t2];
          this.set(n2[0], n2[1]);
        }
      }
      pt.prototype.clear = lt, pt.prototype.delete = ut, pt.prototype.get = gt, pt.prototype.has = mt, pt.prototype.set = ft;
      var bt = pt;
      var wt = function() {
        this.__data__ = new bt(), this.size = 0;
      };
      var kt = function(e2) {
        var t2 = this.__data__, i2 = t2.delete(e2);
        return this.size = t2.size, i2;
      };
      var _t = function(e2) {
        return this.__data__.get(e2);
      };
      var vt = function(e2) {
        return this.__data__.has(e2);
      }, yt = q(k.a, "Map"), xt = q(Object, "create");
      var At = function() {
        this.__data__ = xt ? xt(null) : {}, this.size = 0;
      };
      var Ct = function(e2) {
        var t2 = this.has(e2) && delete this.__data__[e2];
        return this.size -= t2 ? 1 : 0, t2;
      }, Tt = Object.prototype.hasOwnProperty;
      var Et = function(e2) {
        var t2 = this.__data__;
        if (xt) {
          var i2 = t2[e2];
          return i2 === "__lodash_hash_undefined__" ? void 0 : i2;
        }
        return Tt.call(t2, e2) ? t2[e2] : void 0;
      }, It = Object.prototype.hasOwnProperty;
      var St = function(e2) {
        var t2 = this.__data__;
        return xt ? t2[e2] !== void 0 : It.call(t2, e2);
      };
      var Pt = function(e2, t2) {
        var i2 = this.__data__;
        return this.size += this.has(e2) ? 0 : 1, i2[e2] = xt && t2 === void 0 ? "__lodash_hash_undefined__" : t2, this;
      };
      function Mt(e2) {
        var t2 = -1, i2 = e2 == null ? 0 : e2.length;
        for (this.clear(); ++t2 < i2; ) {
          var n2 = e2[t2];
          this.set(n2[0], n2[1]);
        }
      }
      Mt.prototype.clear = At, Mt.prototype.delete = Ct, Mt.prototype.get = Et, Mt.prototype.has = St, Mt.prototype.set = Pt;
      var Nt = Mt;
      var Rt = function() {
        this.size = 0, this.__data__ = { hash: new Nt(), map: new (yt || bt)(), string: new Nt() };
      };
      var Ot = function(e2) {
        var t2 = typeof e2;
        return t2 == "string" || t2 == "number" || t2 == "symbol" || t2 == "boolean" ? e2 !== "__proto__" : e2 === null;
      };
      var zt = function(e2, t2) {
        var i2 = e2.__data__;
        return Ot(t2) ? i2[typeof t2 == "string" ? "string" : "hash"] : i2.map;
      };
      var Dt = function(e2) {
        var t2 = zt(this, e2).delete(e2);
        return this.size -= t2 ? 1 : 0, t2;
      };
      var Lt = function(e2) {
        return zt(this, e2).get(e2);
      };
      var Vt = function(e2) {
        return zt(this, e2).has(e2);
      };
      var jt = function(e2, t2) {
        var i2 = zt(this, e2), n2 = i2.size;
        return i2.set(e2, t2), this.size += i2.size == n2 ? 0 : 1, this;
      };
      function Bt(e2) {
        var t2 = -1, i2 = e2 == null ? 0 : e2.length;
        for (this.clear(); ++t2 < i2; ) {
          var n2 = e2[t2];
          this.set(n2[0], n2[1]);
        }
      }
      Bt.prototype.clear = Rt, Bt.prototype.delete = Dt, Bt.prototype.get = Lt, Bt.prototype.has = Vt, Bt.prototype.set = jt;
      var Ft = Bt;
      var Ht = function(e2, t2) {
        var i2 = this.__data__;
        if (i2 instanceof bt) {
          var n2 = i2.__data__;
          if (!yt || n2.length < 199)
            return n2.push([e2, t2]), this.size = ++i2.size, this;
          i2 = this.__data__ = new Ft(n2);
        }
        return i2.set(e2, t2), this.size = i2.size, this;
      };
      function Ut(e2) {
        var t2 = this.__data__ = new bt(e2);
        this.size = t2.size;
      }
      Ut.prototype.clear = wt, Ut.prototype.delete = kt, Ut.prototype.get = _t, Ut.prototype.has = vt, Ut.prototype.set = Ht;
      var Wt = Ut;
      var qt = function(e2, t2) {
        for (var i2 = -1, n2 = e2 == null ? 0 : e2.length; ++i2 < n2 && t2(e2[i2], i2, e2) !== false; )
          ;
        return e2;
      }, $t = tt(Object.keys, Object), Yt = Object.prototype.hasOwnProperty;
      var Gt = function(e2) {
        if (!Me(e2))
          return $t(e2);
        var t2 = [];
        for (var i2 in Object(e2))
          Yt.call(e2, i2) && i2 != "constructor" && t2.push(i2);
        return t2;
      };
      var Kt = function(e2) {
        return ce(e2) ? Se(e2) : Gt(e2);
      };
      var Qt = function(e2, t2) {
        return e2 && J(t2, Kt(t2), e2);
      };
      var Jt = function(e2, t2) {
        return e2 && J(t2, ze(t2), e2);
      }, Zt = i(9);
      var Xt = function(e2, t2) {
        var i2 = -1, n2 = e2.length;
        for (t2 || (t2 = Array(n2)); ++i2 < n2; )
          t2[i2] = e2[i2];
        return t2;
      };
      var ei = function(e2, t2) {
        for (var i2 = -1, n2 = e2 == null ? 0 : e2.length, o2 = 0, r2 = []; ++i2 < n2; ) {
          var s2 = e2[i2];
          t2(s2, i2, e2) && (r2[o2++] = s2);
        }
        return r2;
      };
      var ti = function() {
        return [];
      }, ii = Object.prototype.propertyIsEnumerable, ni = Object.getOwnPropertySymbols, oi = ni ? function(e2) {
        return e2 == null ? [] : (e2 = Object(e2), ei(ni(e2), function(t2) {
          return ii.call(e2, t2);
        }));
      } : ti;
      var ri = function(e2, t2) {
        return J(e2, oi(e2), t2);
      };
      var si = function(e2, t2) {
        for (var i2 = -1, n2 = t2.length, o2 = e2.length; ++i2 < n2; )
          e2[o2 + i2] = t2[i2];
        return e2;
      }, ai = Object.getOwnPropertySymbols ? function(e2) {
        for (var t2 = []; e2; )
          si(t2, oi(e2)), e2 = it(e2);
        return t2;
      } : ti;
      var ci = function(e2, t2) {
        return J(e2, ai(e2), t2);
      };
      var li = function(e2, t2, i2) {
        var n2 = t2(e2);
        return _e(e2) ? n2 : si(n2, i2(e2));
      };
      var di = function(e2) {
        return li(e2, Kt, oi);
      };
      var hi = function(e2) {
        return li(e2, ze, ai);
      }, ui = q(k.a, "DataView"), gi = q(k.a, "Promise"), mi = q(k.a, "Set"), fi = q(k.a, "WeakMap"), pi = D(ui), bi = D(yt), wi = D(gi), ki = D(mi), _i = D(fi), vi = S;
      (ui && vi(new ui(new ArrayBuffer(1))) != "[object DataView]" || yt && vi(new yt()) != "[object Map]" || gi && vi(gi.resolve()) != "[object Promise]" || mi && vi(new mi()) != "[object Set]" || fi && vi(new fi()) != "[object WeakMap]") && (vi = function(e2) {
        var t2 = S(e2), i2 = t2 == "[object Object]" ? e2.constructor : void 0, n2 = i2 ? D(i2) : "";
        if (n2)
          switch (n2) {
            case pi:
              return "[object DataView]";
            case bi:
              return "[object Map]";
            case wi:
              return "[object Promise]";
            case ki:
              return "[object Set]";
            case _i:
              return "[object WeakMap]";
          }
        return t2;
      });
      var yi = vi, xi = Object.prototype.hasOwnProperty;
      var Ai = function(e2) {
        var t2 = e2.length, i2 = new e2.constructor(t2);
        return t2 && typeof e2[0] == "string" && xi.call(e2, "index") && (i2.index = e2.index, i2.input = e2.input), i2;
      }, Ci = k.a.Uint8Array;
      var Ti = function(e2) {
        var t2 = new e2.constructor(e2.byteLength);
        return new Ci(t2).set(new Ci(e2)), t2;
      };
      var Ei = function(e2, t2) {
        var i2 = t2 ? Ti(e2.buffer) : e2.buffer;
        return new e2.constructor(i2, e2.byteOffset, e2.byteLength);
      }, Ii = /\w*$/;
      var Si = function(e2) {
        var t2 = new e2.constructor(e2.source, Ii.exec(e2));
        return t2.lastIndex = e2.lastIndex, t2;
      }, Pi = _ ? _.prototype : void 0, Mi = Pi ? Pi.valueOf : void 0;
      var Ni = function(e2) {
        return Mi ? Object(Mi.call(e2)) : {};
      };
      var Ri = function(e2, t2) {
        var i2 = t2 ? Ti(e2.buffer) : e2.buffer;
        return new e2.constructor(i2, e2.byteOffset, e2.length);
      };
      var Oi = function(e2, t2, i2) {
        var n2 = e2.constructor;
        switch (t2) {
          case "[object ArrayBuffer]":
            return Ti(e2);
          case "[object Boolean]":
          case "[object Date]":
            return new n2(+e2);
          case "[object DataView]":
            return Ei(e2, i2);
          case "[object Float32Array]":
          case "[object Float64Array]":
          case "[object Int8Array]":
          case "[object Int16Array]":
          case "[object Int32Array]":
          case "[object Uint8Array]":
          case "[object Uint8ClampedArray]":
          case "[object Uint16Array]":
          case "[object Uint32Array]":
            return Ri(e2, i2);
          case "[object Map]":
            return new n2();
          case "[object Number]":
          case "[object String]":
            return new n2(e2);
          case "[object RegExp]":
            return Si(e2);
          case "[object Set]":
            return new n2();
          case "[object Symbol]":
            return Ni(e2);
        }
      }, zi = Object.create, Di = function() {
        function e2() {
        }
        return function(t2) {
          if (!w(t2))
            return {};
          if (zi)
            return zi(t2);
          e2.prototype = t2;
          var i2 = new e2();
          return e2.prototype = void 0, i2;
        };
      }();
      var Li = function(e2) {
        return typeof e2.constructor != "function" || Me(e2) ? {} : Di(it(e2));
      };
      var Vi = function(e2) {
        return me(e2) && yi(e2) == "[object Map]";
      }, ji = Ce.a && Ce.a.isMap, Bi = ji ? Ae(ji) : Vi;
      var Fi = function(e2) {
        return me(e2) && yi(e2) == "[object Set]";
      }, Hi = Ce.a && Ce.a.isSet, Ui = Hi ? Ae(Hi) : Fi, Wi = {};
      Wi["[object Arguments]"] = Wi["[object Array]"] = Wi["[object ArrayBuffer]"] = Wi["[object DataView]"] = Wi["[object Boolean]"] = Wi["[object Date]"] = Wi["[object Float32Array]"] = Wi["[object Float64Array]"] = Wi["[object Int8Array]"] = Wi["[object Int16Array]"] = Wi["[object Int32Array]"] = Wi["[object Map]"] = Wi["[object Number]"] = Wi["[object Object]"] = Wi["[object RegExp]"] = Wi["[object Set]"] = Wi["[object String]"] = Wi["[object Symbol]"] = Wi["[object Uint8Array]"] = Wi["[object Uint8ClampedArray]"] = Wi["[object Uint16Array]"] = Wi["[object Uint32Array]"] = true, Wi["[object Error]"] = Wi["[object Function]"] = Wi["[object WeakMap]"] = false;
      var qi = function e2(t2, i2, n2, o2, r2, s2) {
        var a2, c2 = 1 & i2, l2 = 2 & i2, d2 = 4 & i2;
        if (n2 && (a2 = r2 ? n2(t2, o2, r2, s2) : n2(t2)), a2 !== void 0)
          return a2;
        if (!w(t2))
          return t2;
        var h2 = _e(t2);
        if (h2) {
          if (a2 = Ai(t2), !c2)
            return Xt(t2, a2);
        } else {
          var u2 = yi(t2), g2 = u2 == "[object Function]" || u2 == "[object GeneratorFunction]";
          if (Object(ve.a)(t2))
            return Object(Zt.a)(t2, c2);
          if (u2 == "[object Object]" || u2 == "[object Arguments]" || g2 && !r2) {
            if (a2 = l2 || g2 ? {} : Li(t2), !c2)
              return l2 ? ci(t2, Jt(a2, t2)) : ri(t2, Qt(a2, t2));
          } else {
            if (!Wi[u2])
              return r2 ? t2 : {};
            a2 = Oi(t2, u2, c2);
          }
        }
        s2 || (s2 = new Wt());
        var m2 = s2.get(t2);
        if (m2)
          return m2;
        s2.set(t2, a2), Ui(t2) ? t2.forEach(function(o3) {
          a2.add(e2(o3, i2, n2, o3, t2, s2));
        }) : Bi(t2) && t2.forEach(function(o3, r3) {
          a2.set(r3, e2(o3, i2, n2, r3, t2, s2));
        });
        var f2 = h2 ? void 0 : (d2 ? l2 ? hi : di : l2 ? ze : Kt)(t2);
        return qt(f2 || t2, function(o3, r3) {
          f2 && (o3 = t2[r3 = o3]), Q(a2, r3, e2(o3, i2, n2, r3, t2, s2));
        }), a2;
      };
      var $i = function(e2, t2) {
        return qi(e2, 5, t2 = typeof t2 == "function" ? t2 : void 0);
      };
      var Yi = function(e2) {
        return me(e2) && e2.nodeType === 1 && !ct(e2);
      };
      class Gi {
        constructor(e2, t2) {
          this._config = {}, t2 && this.define(Ki(t2)), e2 && this._setObjectToTarget(this._config, e2);
        }
        set(e2, t2) {
          this._setToTarget(this._config, e2, t2);
        }
        define(e2, t2) {
          this._setToTarget(this._config, e2, t2, true);
        }
        get(e2) {
          return this._getFromSource(this._config, e2);
        }
        *names() {
          for (const e2 of Object.keys(this._config))
            yield e2;
        }
        _setToTarget(e2, t2, i2, n2 = false) {
          if (ct(t2))
            return void this._setObjectToTarget(e2, t2, n2);
          const o2 = t2.split(".");
          t2 = o2.pop();
          for (const t3 of o2)
            ct(e2[t3]) || (e2[t3] = {}), e2 = e2[t3];
          if (ct(i2))
            return ct(e2[t2]) || (e2[t2] = {}), e2 = e2[t2], void this._setObjectToTarget(e2, i2, n2);
          n2 && e2[t2] !== void 0 || (e2[t2] = i2);
        }
        _getFromSource(e2, t2) {
          const i2 = t2.split(".");
          t2 = i2.pop();
          for (const t3 of i2) {
            if (!ct(e2[t3])) {
              e2 = null;
              break;
            }
            e2 = e2[t3];
          }
          return e2 ? Ki(e2[t2]) : void 0;
        }
        _setObjectToTarget(e2, t2, i2) {
          Object.keys(t2).forEach((n2) => {
            this._setToTarget(e2, n2, t2[n2], i2);
          });
        }
      }
      function Ki(e2) {
        return $i(e2, Qi);
      }
      function Qi(e2) {
        return Yi(e2) ? e2 : void 0;
      }
      function Ji(e2) {
        return !(!e2 || !e2[Symbol.iterator]);
      }
      class Zi {
        constructor(e2 = {}, t2 = {}) {
          const i2 = Ji(e2);
          if (i2 || (t2 = e2), this._items = [], this._itemMap = new Map(), this._idProperty = t2.idProperty || "id", this._bindToExternalToInternalMap = new WeakMap(), this._bindToInternalToExternalMap = new WeakMap(), this._skippedIndexesFromExternal = [], i2)
            for (const t3 of e2)
              this._items.push(t3), this._itemMap.set(this._getItemIdBeforeAdding(t3), t3);
        }
        get length() {
          return this._items.length;
        }
        get first() {
          return this._items[0] || null;
        }
        get last() {
          return this._items[this.length - 1] || null;
        }
        add(e2, t2) {
          return this.addMany([e2], t2);
        }
        addMany(e2, t2) {
          if (t2 === void 0)
            t2 = this._items.length;
          else if (t2 > this._items.length || t2 < 0)
            throw new c.a("collection-add-item-invalid-index", this);
          for (let i2 = 0; i2 < e2.length; i2++) {
            const n2 = e2[i2], o2 = this._getItemIdBeforeAdding(n2), r2 = t2 + i2;
            this._items.splice(r2, 0, n2), this._itemMap.set(o2, n2), this.fire("add", n2, r2);
          }
          return this.fire("change", { added: e2, removed: [], index: t2 }), this;
        }
        get(e2) {
          let t2;
          if (typeof e2 == "string")
            t2 = this._itemMap.get(e2);
          else {
            if (typeof e2 != "number")
              throw new c.a("collection-get-invalid-arg", this);
            t2 = this._items[e2];
          }
          return t2 || null;
        }
        has(e2) {
          if (typeof e2 == "string")
            return this._itemMap.has(e2);
          {
            const t2 = e2[this._idProperty];
            return this._itemMap.has(t2);
          }
        }
        getIndex(e2) {
          let t2;
          return t2 = typeof e2 == "string" ? this._itemMap.get(e2) : e2, this._items.indexOf(t2);
        }
        remove(e2) {
          const [t2, i2] = this._remove(e2);
          return this.fire("change", { added: [], removed: [t2], index: i2 }), t2;
        }
        map(e2, t2) {
          return this._items.map(e2, t2);
        }
        find(e2, t2) {
          return this._items.find(e2, t2);
        }
        filter(e2, t2) {
          return this._items.filter(e2, t2);
        }
        clear() {
          this._bindToCollection && (this.stopListening(this._bindToCollection), this._bindToCollection = null);
          const e2 = Array.from(this._items);
          for (; this.length; )
            this._remove(0);
          this.fire("change", { added: [], removed: e2, index: 0 });
        }
        bindTo(e2) {
          if (this._bindToCollection)
            throw new c.a("collection-bind-to-rebind", this);
          return this._bindToCollection = e2, { as: (e3) => {
            this._setUpBindToBinding((t2) => new e3(t2));
          }, using: (e3) => {
            typeof e3 == "function" ? this._setUpBindToBinding((t2) => e3(t2)) : this._setUpBindToBinding((t2) => t2[e3]);
          } };
        }
        _setUpBindToBinding(e2) {
          const t2 = this._bindToCollection, i2 = (i3, n2, o2) => {
            const r2 = t2._bindToCollection == this, s2 = t2._bindToInternalToExternalMap.get(n2);
            if (r2 && s2)
              this._bindToExternalToInternalMap.set(n2, s2), this._bindToInternalToExternalMap.set(s2, n2);
            else {
              const i4 = e2(n2);
              if (!i4)
                return void this._skippedIndexesFromExternal.push(o2);
              let r3 = o2;
              for (const e3 of this._skippedIndexesFromExternal)
                o2 > e3 && r3--;
              for (const e3 of t2._skippedIndexesFromExternal)
                r3 >= e3 && r3++;
              this._bindToExternalToInternalMap.set(n2, i4), this._bindToInternalToExternalMap.set(i4, n2), this.add(i4, r3);
              for (let e3 = 0; e3 < t2._skippedIndexesFromExternal.length; e3++)
                r3 <= t2._skippedIndexesFromExternal[e3] && t2._skippedIndexesFromExternal[e3]++;
            }
          };
          for (const e3 of t2)
            i2(0, e3, t2.getIndex(e3));
          this.listenTo(t2, "add", i2), this.listenTo(t2, "remove", (e3, t3, i3) => {
            const n2 = this._bindToExternalToInternalMap.get(t3);
            n2 && this.remove(n2), this._skippedIndexesFromExternal = this._skippedIndexesFromExternal.reduce((e4, t4) => (i3 < t4 && e4.push(t4 - 1), i3 > t4 && e4.push(t4), e4), []);
          });
        }
        _getItemIdBeforeAdding(e2) {
          const t2 = this._idProperty;
          let i2;
          if (t2 in e2) {
            if (i2 = e2[t2], typeof i2 != "string")
              throw new c.a("collection-add-invalid-id", this);
            if (this.get(i2))
              throw new c.a("collection-add-item-already-exists", this);
          } else
            e2[t2] = i2 = s();
          return i2;
        }
        _remove(e2) {
          let t2, i2, n2, o2 = false;
          const r2 = this._idProperty;
          if (typeof e2 == "string" ? (i2 = e2, n2 = this._itemMap.get(i2), o2 = !n2, n2 && (t2 = this._items.indexOf(n2))) : typeof e2 == "number" ? (t2 = e2, n2 = this._items[t2], o2 = !n2, n2 && (i2 = n2[r2])) : (n2 = e2, i2 = n2[r2], t2 = this._items.indexOf(n2), o2 = t2 == -1 || !this._itemMap.get(i2)), o2)
            throw new c.a("collection-remove-404", this);
          this._items.splice(t2, 1), this._itemMap.delete(i2);
          const s2 = this._bindToInternalToExternalMap.get(n2);
          return this._bindToInternalToExternalMap.delete(n2), this._bindToExternalToInternalMap.delete(s2), this.fire("remove", n2, t2), [n2, t2];
        }
        [Symbol.iterator]() {
          return this._items[Symbol.iterator]();
        }
      }
      Ke(Zi, h);
      class Xi {
        constructor(e2, t2 = [], i2 = []) {
          this._context = e2, this._plugins = new Map(), this._availablePlugins = new Map();
          for (const e3 of t2)
            e3.pluginName && this._availablePlugins.set(e3.pluginName, e3);
          this._contextPlugins = new Map();
          for (const [e3, t3] of i2)
            this._contextPlugins.set(e3, t3), this._contextPlugins.set(t3, e3), e3.pluginName && this._availablePlugins.set(e3.pluginName, e3);
        }
        *[Symbol.iterator]() {
          for (const e2 of this._plugins)
            typeof e2[0] == "function" && (yield e2);
        }
        get(e2) {
          const t2 = this._plugins.get(e2);
          if (!t2) {
            let t3 = e2;
            throw typeof e2 == "function" && (t3 = e2.pluginName || e2.name), new c.a("plugincollection-plugin-not-loaded", this._context, { plugin: t3 });
          }
          return t2;
        }
        has(e2) {
          return this._plugins.has(e2);
        }
        init(e2, t2 = [], i2 = []) {
          const n2 = this, o2 = this._context;
          !function e3(t3, i3 = new Set()) {
            t3.forEach((t4) => {
              a2(t4) && (i3.has(t4) || (i3.add(t4), t4.pluginName && !n2._availablePlugins.has(t4.pluginName) && n2._availablePlugins.set(t4.pluginName, t4), t4.requires && e3(t4.requires, i3)));
            });
          }(e2), u2(e2);
          const r2 = [...function e3(t3, i3 = new Set()) {
            return t3.map((e4) => a2(e4) ? e4 : n2._availablePlugins.get(e4)).reduce((t4, n3) => i3.has(n3) ? t4 : (i3.add(n3), n3.requires && (u2(n3.requires, n3), e3(n3.requires, i3).forEach((e4) => t4.add(e4))), t4.add(n3)), new Set());
          }(e2.filter((e3) => !d2(e3, t2)))];
          !function(e3, t3) {
            for (const i3 of t3) {
              if (typeof i3 != "function")
                throw new c.a("plugincollection-replace-plugin-invalid-type", null, { pluginItem: i3 });
              const t4 = i3.pluginName;
              if (!t4)
                throw new c.a("plugincollection-replace-plugin-missing-name", null, { pluginItem: i3 });
              if (i3.requires && i3.requires.length)
                throw new c.a("plugincollection-plugin-for-replacing-cannot-have-dependencies", null, { pluginName: t4 });
              const o3 = n2._availablePlugins.get(t4);
              if (!o3)
                throw new c.a("plugincollection-plugin-for-replacing-not-exist", null, { pluginName: t4 });
              const r3 = e3.indexOf(o3);
              if (r3 === -1) {
                if (n2._contextPlugins.has(o3))
                  return;
                throw new c.a("plugincollection-plugin-for-replacing-not-loaded", null, { pluginName: t4 });
              }
              if (o3.requires && o3.requires.length)
                throw new c.a("plugincollection-replaced-plugin-cannot-have-dependencies", null, { pluginName: t4 });
              e3.splice(r3, 1, i3), n2._availablePlugins.set(t4, i3);
            }
          }(r2, i2);
          const s2 = function(e3) {
            return e3.map((e4) => {
              const t3 = n2._contextPlugins.get(e4) || new e4(o2);
              return n2._add(e4, t3), t3;
            });
          }(r2);
          return g2(s2, "init").then(() => g2(s2, "afterInit")).then(() => s2);
          function a2(e3) {
            return typeof e3 == "function";
          }
          function l2(e3) {
            return a2(e3) && e3.isContextPlugin;
          }
          function d2(e3, t3) {
            return t3.some((t4) => t4 === e3 || (h2(e3) === t4 || h2(t4) === e3));
          }
          function h2(e3) {
            return a2(e3) ? e3.pluginName || e3.name : e3;
          }
          function u2(e3, i3 = null) {
            e3.map((e4) => a2(e4) ? e4 : n2._availablePlugins.get(e4) || e4).forEach((e4) => {
              !function(e5, t3) {
                if (a2(e5))
                  return;
                if (t3)
                  throw new c.a("plugincollection-soft-required", o2, { missingPlugin: e5, requiredBy: h2(t3) });
                throw new c.a("plugincollection-plugin-not-found", o2, { plugin: e5 });
              }(e4, i3), function(e5, t3) {
                if (!l2(t3))
                  return;
                if (l2(e5))
                  return;
                throw new c.a("plugincollection-context-required", o2, { plugin: h2(e5), requiredBy: h2(t3) });
              }(e4, i3), function(e5, i4) {
                if (!i4)
                  return;
                if (!d2(e5, t2))
                  return;
                throw new c.a("plugincollection-required", o2, { plugin: h2(e5), requiredBy: h2(i4) });
              }(e4, i3);
            });
          }
          function g2(e3, t3) {
            return e3.reduce((e4, i3) => i3[t3] ? n2._contextPlugins.has(i3) ? e4 : e4.then(i3[t3].bind(i3)) : e4, Promise.resolve());
          }
        }
        destroy() {
          const e2 = [];
          for (const [, t2] of this)
            typeof t2.destroy != "function" || this._contextPlugins.has(t2) || e2.push(t2.destroy());
          return Promise.all(e2);
        }
        _add(e2, t2) {
          this._plugins.set(e2, t2);
          const i2 = e2.pluginName;
          if (i2) {
            if (this._plugins.has(i2))
              throw new c.a("plugincollection-plugin-name-conflict", null, { pluginName: i2, plugin1: this._plugins.get(i2).constructor, plugin2: e2 });
            this._plugins.set(i2, t2);
          }
        }
      }
      function en(e2) {
        return Array.isArray(e2) ? e2 : [e2];
      }
      function tn(e2, t2, i2 = 1) {
        if (typeof i2 != "number")
          throw new c.a("translation-service-quantity-not-a-number", null, { quantity: i2 });
        const n2 = Object.keys(window.CKEDITOR_TRANSLATIONS).length;
        n2 === 1 && (e2 = Object.keys(window.CKEDITOR_TRANSLATIONS)[0]);
        const o2 = t2.id || t2.string;
        if (n2 === 0 || !function(e3, t3) {
          return !!window.CKEDITOR_TRANSLATIONS[e3] && !!window.CKEDITOR_TRANSLATIONS[e3].dictionary[t3];
        }(e2, o2))
          return i2 !== 1 ? t2.plural : t2.string;
        const r2 = window.CKEDITOR_TRANSLATIONS[e2].dictionary, s2 = window.CKEDITOR_TRANSLATIONS[e2].getPluralForm || ((e3) => e3 === 1 ? 0 : 1);
        if (typeof r2[o2] == "string")
          return r2[o2];
        const a2 = Number(s2(i2));
        return r2[o2][a2];
      }
      Ke(Xi, h), window.CKEDITOR_TRANSLATIONS || (window.CKEDITOR_TRANSLATIONS = {});
      const nn = ["ar", "ara", "fa", "per", "fas", "he", "heb", "ku", "kur", "ug", "uig"];
      function on(e2) {
        return nn.includes(e2) ? "rtl" : "ltr";
      }
      class rn {
        constructor(e2 = {}) {
          this.uiLanguage = e2.uiLanguage || "en", this.contentLanguage = e2.contentLanguage || this.uiLanguage, this.uiLanguageDirection = on(this.uiLanguage), this.contentLanguageDirection = on(this.contentLanguage), this.t = (e3, t2) => this._t(e3, t2);
        }
        get language() {
          return console.warn("locale-deprecated-language-property: The Locale#language property has been deprecated and will be removed in the near future. Please use #uiLanguage and #contentLanguage properties instead."), this.uiLanguage;
        }
        _t(e2, t2 = []) {
          t2 = en(t2), typeof e2 == "string" && (e2 = { string: e2 });
          const i2 = !!e2.plural ? t2[0] : 1;
          return function(e3, t3) {
            return e3.replace(/%(\d+)/g, (e4, i3) => i3 < t3.length ? t3[i3] : e4);
          }(tn(this.uiLanguage, e2, i2), t2);
        }
      }
      class sn {
        constructor(e2) {
          this.config = new Gi(e2, this.constructor.defaultConfig);
          const t2 = this.constructor.builtinPlugins;
          this.config.define("plugins", t2), this.plugins = new Xi(this, t2);
          const i2 = this.config.get("language") || {};
          this.locale = new rn({ uiLanguage: typeof i2 == "string" ? i2 : i2.ui, contentLanguage: this.config.get("language.content") }), this.t = this.locale.t, this.editors = new Zi(), this._contextOwner = null;
        }
        initPlugins() {
          const e2 = this.config.get("plugins") || [], t2 = this.config.get("substitutePlugins") || [];
          for (const i2 of e2.concat(t2)) {
            if (typeof i2 != "function")
              throw new c.a("context-initplugins-constructor-only", null, { Plugin: i2 });
            if (i2.isContextPlugin !== true)
              throw new c.a("context-initplugins-invalid-plugin", null, { Plugin: i2 });
          }
          return this.plugins.init(e2, [], t2);
        }
        destroy() {
          return Promise.all(Array.from(this.editors, (e2) => e2.destroy())).then(() => this.plugins.destroy());
        }
        _addEditor(e2, t2) {
          if (this._contextOwner)
            throw new c.a("context-addeditor-private-context");
          this.editors.add(e2), t2 && (this._contextOwner = e2);
        }
        _removeEditor(e2) {
          return this.editors.has(e2) && this.editors.remove(e2), this._contextOwner === e2 ? this.destroy() : Promise.resolve();
        }
        _getEditorConfig() {
          const e2 = {};
          for (const t2 of this.config.names())
            ["plugins", "removePlugins", "extraPlugins"].includes(t2) || (e2[t2] = this.config.get(t2));
          return e2;
        }
        static create(e2) {
          return new Promise((t2) => {
            const i2 = new this(e2);
            t2(i2.initPlugins().then(() => i2));
          });
        }
      }
      class an {
        constructor(e2) {
          this.context = e2;
        }
        destroy() {
          this.stopListening();
        }
        static get isContextPlugin() {
          return true;
        }
      }
      function cn(e2, t2) {
        const i2 = Math.min(e2.length, t2.length);
        for (let n2 = 0; n2 < i2; n2++)
          if (e2[n2] != t2[n2])
            return n2;
        return e2.length == t2.length ? "same" : e2.length < t2.length ? "prefix" : "extension";
      }
      Ke(an, Ue);
      var ln = function(e2) {
        return qi(e2, 4);
      };
      class dn {
        constructor(e2) {
          this.document = e2, this.parent = null;
        }
        get index() {
          let e2;
          if (!this.parent)
            return null;
          if ((e2 = this.parent.getChildIndex(this)) == -1)
            throw new c.a("view-node-not-found-in-parent", this);
          return e2;
        }
        get nextSibling() {
          const e2 = this.index;
          return e2 !== null && this.parent.getChild(e2 + 1) || null;
        }
        get previousSibling() {
          const e2 = this.index;
          return e2 !== null && this.parent.getChild(e2 - 1) || null;
        }
        get root() {
          let e2 = this;
          for (; e2.parent; )
            e2 = e2.parent;
          return e2;
        }
        isAttached() {
          return this.root.is("rootElement");
        }
        getPath() {
          const e2 = [];
          let t2 = this;
          for (; t2.parent; )
            e2.unshift(t2.index), t2 = t2.parent;
          return e2;
        }
        getAncestors(e2 = { includeSelf: false, parentFirst: false }) {
          const t2 = [];
          let i2 = e2.includeSelf ? this : this.parent;
          for (; i2; )
            t2[e2.parentFirst ? "push" : "unshift"](i2), i2 = i2.parent;
          return t2;
        }
        getCommonAncestor(e2, t2 = {}) {
          const i2 = this.getAncestors(t2), n2 = e2.getAncestors(t2);
          let o2 = 0;
          for (; i2[o2] == n2[o2] && i2[o2]; )
            o2++;
          return o2 === 0 ? null : i2[o2 - 1];
        }
        isBefore(e2) {
          if (this == e2)
            return false;
          if (this.root !== e2.root)
            return false;
          const t2 = this.getPath(), i2 = e2.getPath(), n2 = cn(t2, i2);
          switch (n2) {
            case "prefix":
              return true;
            case "extension":
              return false;
            default:
              return t2[n2] < i2[n2];
          }
        }
        isAfter(e2) {
          return this != e2 && (this.root === e2.root && !this.isBefore(e2));
        }
        _remove() {
          this.parent._removeChildren(this.index);
        }
        _fireChange(e2, t2) {
          this.fire("change:" + e2, t2), this.parent && this.parent._fireChange(e2, t2);
        }
        toJSON() {
          const e2 = ln(this);
          return delete e2.parent, e2;
        }
        is(e2) {
          return e2 === "node" || e2 === "view:node";
        }
      }
      Ke(dn, h);
      class hn extends dn {
        constructor(e2, t2) {
          super(e2), this._textData = t2;
        }
        is(e2) {
          return e2 === "$text" || e2 === "view:$text" || e2 === "text" || e2 === "view:text" || e2 === "node" || e2 === "view:node";
        }
        get data() {
          return this._textData;
        }
        get _data() {
          return this.data;
        }
        set _data(e2) {
          this._fireChange("text", this), this._textData = e2;
        }
        isSimilar(e2) {
          return e2 instanceof hn && (this === e2 || this.data === e2.data);
        }
        _clone() {
          return new hn(this.document, this.data);
        }
      }
      class un {
        constructor(e2, t2, i2) {
          if (this.textNode = e2, t2 < 0 || t2 > e2.data.length)
            throw new c.a("view-textproxy-wrong-offsetintext", this);
          if (i2 < 0 || t2 + i2 > e2.data.length)
            throw new c.a("view-textproxy-wrong-length", this);
          this.data = e2.data.substring(t2, t2 + i2), this.offsetInText = t2;
        }
        get offsetSize() {
          return this.data.length;
        }
        get isPartial() {
          return this.data.length !== this.textNode.data.length;
        }
        get parent() {
          return this.textNode.parent;
        }
        get root() {
          return this.textNode.root;
        }
        get document() {
          return this.textNode.document;
        }
        is(e2) {
          return e2 === "$textProxy" || e2 === "view:$textProxy" || e2 === "textProxy" || e2 === "view:textProxy";
        }
        getAncestors(e2 = { includeSelf: false, parentFirst: false }) {
          const t2 = [];
          let i2 = e2.includeSelf ? this.textNode : this.parent;
          for (; i2 !== null; )
            t2[e2.parentFirst ? "push" : "unshift"](i2), i2 = i2.parent;
          return t2;
        }
      }
      function gn(e2) {
        return Ji(e2) ? new Map(e2) : function(e3) {
          const t2 = new Map();
          for (const i2 in e3)
            t2.set(i2, e3[i2]);
          return t2;
        }(e2);
      }
      class mn {
        constructor(...e2) {
          this._patterns = [], this.add(...e2);
        }
        add(...e2) {
          for (let t2 of e2)
            (typeof t2 == "string" || t2 instanceof RegExp) && (t2 = { name: t2 }), this._patterns.push(t2);
        }
        match(...e2) {
          for (const t2 of e2)
            for (const e3 of this._patterns) {
              const i2 = fn(t2, e3);
              if (i2)
                return { element: t2, pattern: e3, match: i2 };
            }
          return null;
        }
        matchAll(...e2) {
          const t2 = [];
          for (const i2 of e2)
            for (const e3 of this._patterns) {
              const n2 = fn(i2, e3);
              n2 && t2.push({ element: i2, pattern: e3, match: n2 });
            }
          return t2.length > 0 ? t2 : null;
        }
        getElementName() {
          if (this._patterns.length !== 1)
            return null;
          const e2 = this._patterns[0], t2 = e2.name;
          return typeof e2 == "function" || !t2 || t2 instanceof RegExp ? null : t2;
        }
      }
      function fn(e2, t2) {
        if (typeof t2 == "function")
          return t2(e2);
        const i2 = {};
        return t2.name && (i2.name = function(e3, t3) {
          if (e3 instanceof RegExp)
            return !!t3.match(e3);
          return e3 === t3;
        }(t2.name, e2.name), !i2.name) || t2.attributes && (i2.attributes = function(e3, t3) {
          const i3 = new Set(t3.getAttributeKeys());
          ct(e3) ? (e3.style !== void 0 && Object(c.b)("matcher-pattern-deprecated-attributes-style-key", e3), e3.class !== void 0 && Object(c.b)("matcher-pattern-deprecated-attributes-class-key", e3)) : (i3.delete("style"), i3.delete("class"));
          return pn(e3, i3, (e4) => t3.getAttribute(e4));
        }(t2.attributes, e2), !i2.attributes) ? null : !(t2.classes && (i2.classes = function(e3, t3) {
          return pn(e3, t3.getClassNames());
        }(t2.classes, e2), !i2.classes)) && (!(t2.styles && (i2.styles = function(e3, t3) {
          return pn(e3, t3.getStyleNames(true), (e4) => t3.getStyle(e4));
        }(t2.styles, e2), !i2.styles)) && i2);
      }
      function pn(e2, t2, i2) {
        const n2 = function(e3) {
          if (Array.isArray(e3))
            return e3.map((e4) => ct(e4) ? (e4.key !== void 0 && e4.value !== void 0 || Object(c.b)("matcher-pattern-missing-key-or-value", e4), [e4.key, e4.value]) : [e4, true]);
          if (ct(e3))
            return Object.entries(e3);
          return [[e3, true]];
        }(e2), o2 = Array.from(t2), r2 = [];
        return n2.forEach(([e3, t3]) => {
          o2.forEach((n3) => {
            (function(e4, t4) {
              return e4 === true || e4 === t4 || e4 instanceof RegExp && t4.match(e4);
            })(e3, n3) && function(e4, t4, i3) {
              if (e4 === true)
                return true;
              const n4 = i3(t4);
              return e4 === n4 || e4 instanceof RegExp && !!String(n4).match(e4);
            }(t3, n3, i2) && r2.push(n3);
          });
        }), !n2.length || r2.length < n2.length ? null : r2;
      }
      var bn = function(e2) {
        return typeof e2 == "symbol" || me(e2) && S(e2) == "[object Symbol]";
      }, wn = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, kn = /^\w*$/;
      var _n = function(e2, t2) {
        if (_e(e2))
          return false;
        var i2 = typeof e2;
        return !(i2 != "number" && i2 != "symbol" && i2 != "boolean" && e2 != null && !bn(e2)) || (kn.test(e2) || !wn.test(e2) || t2 != null && e2 in Object(t2));
      };
      function vn(e2, t2) {
        if (typeof e2 != "function" || t2 != null && typeof t2 != "function")
          throw new TypeError("Expected a function");
        var i2 = function() {
          var n2 = arguments, o2 = t2 ? t2.apply(this, n2) : n2[0], r2 = i2.cache;
          if (r2.has(o2))
            return r2.get(o2);
          var s2 = e2.apply(this, n2);
          return i2.cache = r2.set(o2, s2) || r2, s2;
        };
        return i2.cache = new (vn.Cache || Ft)(), i2;
      }
      vn.Cache = Ft;
      var yn = vn;
      var xn = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, An = /\\(\\)?/g, Cn = function(e2) {
        var t2 = yn(e2, function(e3) {
          return i2.size === 500 && i2.clear(), e3;
        }), i2 = t2.cache;
        return t2;
      }(function(e2) {
        var t2 = [];
        return e2.charCodeAt(0) === 46 && t2.push(""), e2.replace(xn, function(e3, i2, n2, o2) {
          t2.push(n2 ? o2.replace(An, "$1") : i2 || e3);
        }), t2;
      });
      var Tn = function(e2, t2) {
        for (var i2 = -1, n2 = e2 == null ? 0 : e2.length, o2 = Array(n2); ++i2 < n2; )
          o2[i2] = t2(e2[i2], i2, e2);
        return o2;
      }, En = _ ? _.prototype : void 0, In = En ? En.toString : void 0;
      var Sn = function e2(t2) {
        if (typeof t2 == "string")
          return t2;
        if (_e(t2))
          return Tn(t2, e2) + "";
        if (bn(t2))
          return In ? In.call(t2) : "";
        var i2 = t2 + "";
        return i2 == "0" && 1 / t2 == -1 / 0 ? "-0" : i2;
      };
      var Pn = function(e2) {
        return e2 == null ? "" : Sn(e2);
      };
      var Mn = function(e2, t2) {
        return _e(e2) ? e2 : _n(e2, t2) ? [e2] : Cn(Pn(e2));
      };
      var Nn = function(e2) {
        var t2 = e2 == null ? 0 : e2.length;
        return t2 ? e2[t2 - 1] : void 0;
      };
      var Rn = function(e2) {
        if (typeof e2 == "string" || bn(e2))
          return e2;
        var t2 = e2 + "";
        return t2 == "0" && 1 / e2 == -1 / 0 ? "-0" : t2;
      };
      var On = function(e2, t2) {
        for (var i2 = 0, n2 = (t2 = Mn(t2, e2)).length; e2 != null && i2 < n2; )
          e2 = e2[Rn(t2[i2++])];
        return i2 && i2 == n2 ? e2 : void 0;
      };
      var zn = function(e2, t2, i2) {
        var n2 = -1, o2 = e2.length;
        t2 < 0 && (t2 = -t2 > o2 ? 0 : o2 + t2), (i2 = i2 > o2 ? o2 : i2) < 0 && (i2 += o2), o2 = t2 > i2 ? 0 : i2 - t2 >>> 0, t2 >>>= 0;
        for (var r2 = Array(o2); ++n2 < o2; )
          r2[n2] = e2[n2 + t2];
        return r2;
      };
      var Dn = function(e2, t2) {
        return t2.length < 2 ? e2 : On(e2, zn(t2, 0, -1));
      };
      var Ln = function(e2, t2) {
        return t2 = Mn(t2, e2), (e2 = Dn(e2, t2)) == null || delete e2[Rn(Nn(t2))];
      };
      var Vn = function(e2, t2) {
        return e2 == null || Ln(e2, t2);
      };
      var jn = function(e2, t2, i2) {
        var n2 = e2 == null ? void 0 : On(e2, t2);
        return n2 === void 0 ? i2 : n2;
      };
      var Bn = function(e2, t2, i2) {
        (i2 !== void 0 && !G(e2[t2], i2) || i2 === void 0 && !(t2 in e2)) && Y(e2, t2, i2);
      };
      var Fn = function(e2) {
        return function(t2, i2, n2) {
          for (var o2 = -1, r2 = Object(t2), s2 = n2(t2), a2 = s2.length; a2--; ) {
            var c2 = s2[e2 ? a2 : ++o2];
            if (i2(r2[c2], c2, r2) === false)
              break;
          }
          return t2;
        };
      }();
      var Hn = function(e2) {
        return me(e2) && ce(e2);
      };
      var Un = function(e2, t2) {
        if ((t2 !== "constructor" || typeof e2[t2] != "function") && t2 != "__proto__")
          return e2[t2];
      };
      var Wn = function(e2) {
        return J(e2, ze(e2));
      };
      var qn = function(e2, t2, i2, n2, o2, r2, s2) {
        var a2 = Un(e2, i2), c2 = Un(t2, i2), l2 = s2.get(c2);
        if (l2)
          Bn(e2, i2, l2);
        else {
          var d2 = r2 ? r2(a2, c2, i2 + "", e2, t2, s2) : void 0, h2 = d2 === void 0;
          if (h2) {
            var u2 = _e(c2), g2 = !u2 && Object(ve.a)(c2), m2 = !u2 && !g2 && Ee(c2);
            d2 = c2, u2 || g2 || m2 ? _e(a2) ? d2 = a2 : Hn(a2) ? d2 = Xt(a2) : g2 ? (h2 = false, d2 = Object(Zt.a)(c2, true)) : m2 ? (h2 = false, d2 = Ri(c2, true)) : d2 = [] : ct(c2) || ke(c2) ? (d2 = a2, ke(a2) ? d2 = Wn(a2) : w(a2) && !M(a2) || (d2 = Li(c2))) : h2 = false;
          }
          h2 && (s2.set(c2, d2), o2(d2, c2, n2, r2, s2), s2.delete(c2)), Bn(e2, i2, d2);
        }
      };
      var $n = function e2(t2, i2, n2, o2, r2) {
        t2 !== i2 && Fn(i2, function(s2, a2) {
          if (r2 || (r2 = new Wt()), w(s2))
            qn(t2, i2, a2, n2, e2, o2, r2);
          else {
            var c2 = o2 ? o2(Un(t2, a2), s2, a2 + "", t2, i2, r2) : void 0;
            c2 === void 0 && (c2 = s2), Bn(t2, a2, c2);
          }
        }, ze);
      }, Yn = ue(function(e2, t2, i2) {
        $n(e2, t2, i2);
      });
      var Gn = function(e2, t2, i2, n2) {
        if (!w(e2))
          return e2;
        for (var o2 = -1, r2 = (t2 = Mn(t2, e2)).length, s2 = r2 - 1, a2 = e2; a2 != null && ++o2 < r2; ) {
          var c2 = Rn(t2[o2]), l2 = i2;
          if (c2 === "__proto__" || c2 === "constructor" || c2 === "prototype")
            return e2;
          if (o2 != s2) {
            var d2 = a2[c2];
            (l2 = n2 ? n2(d2, c2, a2) : void 0) === void 0 && (l2 = w(d2) ? d2 : de(t2[o2 + 1]) ? [] : {});
          }
          Q(a2, c2, l2), a2 = a2[c2];
        }
        return e2;
      };
      var Kn = function(e2, t2, i2) {
        return e2 == null ? e2 : Gn(e2, t2, i2);
      };
      class Qn {
        constructor(e2) {
          this._styles = {}, this._styleProcessor = e2;
        }
        get isEmpty() {
          const e2 = Object.entries(this._styles);
          return !Array.from(e2).length;
        }
        get size() {
          return this.isEmpty ? 0 : this.getStyleNames().length;
        }
        setTo(e2) {
          this.clear();
          const t2 = Array.from(function(e3) {
            let t3 = null, i2 = 0, n2 = 0, o2 = null;
            const r2 = new Map();
            if (e3 === "")
              return r2;
            e3.charAt(e3.length - 1) != ";" && (e3 += ";");
            for (let s2 = 0; s2 < e3.length; s2++) {
              const a2 = e3.charAt(s2);
              if (t3 === null)
                switch (a2) {
                  case ":":
                    o2 || (o2 = e3.substr(i2, s2 - i2), n2 = s2 + 1);
                    break;
                  case '"':
                  case "'":
                    t3 = a2;
                    break;
                  case ";": {
                    const t4 = e3.substr(n2, s2 - n2);
                    o2 && r2.set(o2.trim(), t4.trim()), o2 = null, i2 = s2 + 1;
                    break;
                  }
                }
              else
                a2 === t3 && (t3 = null);
            }
            return r2;
          }(e2).entries());
          for (const [e3, i2] of t2)
            this._styleProcessor.toNormalizedForm(e3, i2, this._styles);
        }
        has(e2) {
          if (this.isEmpty)
            return false;
          const t2 = this._styleProcessor.getReducedForm(e2, this._styles).find(([t3]) => t3 === e2);
          return Array.isArray(t2);
        }
        set(e2, t2) {
          if (w(e2))
            for (const [t3, i2] of Object.entries(e2))
              this._styleProcessor.toNormalizedForm(t3, i2, this._styles);
          else
            this._styleProcessor.toNormalizedForm(e2, t2, this._styles);
        }
        remove(e2) {
          const t2 = Zn(e2);
          Vn(this._styles, t2), delete this._styles[e2], this._cleanEmptyObjectsOnPath(t2);
        }
        getNormalized(e2) {
          return this._styleProcessor.getNormalized(e2, this._styles);
        }
        toString() {
          return this.isEmpty ? "" : this._getStylesEntries().map((e2) => e2.join(":")).sort().join(";") + ";";
        }
        getAsString(e2) {
          if (this.isEmpty)
            return;
          if (this._styles[e2] && !w(this._styles[e2]))
            return this._styles[e2];
          const t2 = this._styleProcessor.getReducedForm(e2, this._styles).find(([t3]) => t3 === e2);
          return Array.isArray(t2) ? t2[1] : void 0;
        }
        getStyleNames(e2 = false) {
          if (this.isEmpty)
            return [];
          if (e2)
            return this._styleProcessor.getStyleNames(this._styles);
          return this._getStylesEntries().map(([e3]) => e3);
        }
        clear() {
          this._styles = {};
        }
        _getStylesEntries() {
          const e2 = [], t2 = Object.keys(this._styles);
          for (const i2 of t2)
            e2.push(...this._styleProcessor.getReducedForm(i2, this._styles));
          return e2;
        }
        _cleanEmptyObjectsOnPath(e2) {
          const t2 = e2.split(".");
          if (!(t2.length > 1))
            return;
          const i2 = t2.splice(0, t2.length - 1).join("."), n2 = jn(this._styles, i2);
          if (!n2)
            return;
          !Array.from(Object.keys(n2)).length && this.remove(i2);
        }
      }
      class Jn {
        constructor() {
          this._normalizers = new Map(), this._extractors = new Map(), this._reducers = new Map(), this._consumables = new Map();
        }
        toNormalizedForm(e2, t2, i2) {
          if (w(t2))
            Xn(i2, Zn(e2), t2);
          else if (this._normalizers.has(e2)) {
            const n2 = this._normalizers.get(e2), { path: o2, value: r2 } = n2(t2);
            Xn(i2, o2, r2);
          } else
            Xn(i2, e2, t2);
        }
        getNormalized(e2, t2) {
          if (!e2)
            return Yn({}, t2);
          if (t2[e2] !== void 0)
            return t2[e2];
          if (this._extractors.has(e2)) {
            const i2 = this._extractors.get(e2);
            if (typeof i2 == "string")
              return jn(t2, i2);
            const n2 = i2(e2, t2);
            if (n2)
              return n2;
          }
          return jn(t2, Zn(e2));
        }
        getReducedForm(e2, t2) {
          const i2 = this.getNormalized(e2, t2);
          if (i2 === void 0)
            return [];
          if (this._reducers.has(e2)) {
            return this._reducers.get(e2)(i2);
          }
          return [[e2, i2]];
        }
        getStyleNames(e2) {
          const t2 = Array.from(this._consumables.keys()).filter((t3) => {
            const i3 = this.getNormalized(t3, e2);
            return i3 && typeof i3 == "object" ? Object.keys(i3).length : i3;
          }), i2 = new Set([...t2, ...Object.keys(e2)]);
          return Array.from(i2.values());
        }
        getRelatedStyles(e2) {
          return this._consumables.get(e2) || [];
        }
        setNormalizer(e2, t2) {
          this._normalizers.set(e2, t2);
        }
        setExtractor(e2, t2) {
          this._extractors.set(e2, t2);
        }
        setReducer(e2, t2) {
          this._reducers.set(e2, t2);
        }
        setStyleRelation(e2, t2) {
          this._mapStyleNames(e2, t2);
          for (const i2 of t2)
            this._mapStyleNames(i2, [e2]);
        }
        _mapStyleNames(e2, t2) {
          this._consumables.has(e2) || this._consumables.set(e2, []), this._consumables.get(e2).push(...t2);
        }
      }
      function Zn(e2) {
        return e2.replace("-", ".");
      }
      function Xn(e2, t2, i2) {
        let n2 = i2;
        w(i2) && (n2 = Yn({}, jn(e2, t2), i2)), Kn(e2, t2, n2);
      }
      class eo extends dn {
        constructor(e2, t2, i2, n2) {
          if (super(e2), this.name = t2, this._attrs = function(e3) {
            e3 = gn(e3);
            for (const [t3, i3] of e3)
              i3 === null ? e3.delete(t3) : typeof i3 != "string" && e3.set(t3, String(i3));
            return e3;
          }(i2), this._children = [], n2 && this._insertChild(0, n2), this._classes = new Set(), this._attrs.has("class")) {
            const e3 = this._attrs.get("class");
            to(this._classes, e3), this._attrs.delete("class");
          }
          this._styles = new Qn(this.document.stylesProcessor), this._attrs.has("style") && (this._styles.setTo(this._attrs.get("style")), this._attrs.delete("style")), this._customProperties = new Map(), this._isAllowedInsideAttributeElement = false;
        }
        get childCount() {
          return this._children.length;
        }
        get isEmpty() {
          return this._children.length === 0;
        }
        get isAllowedInsideAttributeElement() {
          return this._isAllowedInsideAttributeElement;
        }
        is(e2, t2 = null) {
          return t2 ? t2 === this.name && (e2 === "element" || e2 === "view:element") : e2 === "element" || e2 === "view:element" || e2 === "node" || e2 === "view:node";
        }
        getChild(e2) {
          return this._children[e2];
        }
        getChildIndex(e2) {
          return this._children.indexOf(e2);
        }
        getChildren() {
          return this._children[Symbol.iterator]();
        }
        *getAttributeKeys() {
          this._classes.size > 0 && (yield "class"), this._styles.isEmpty || (yield "style"), yield* this._attrs.keys();
        }
        *getAttributes() {
          yield* this._attrs.entries(), this._classes.size > 0 && (yield ["class", this.getAttribute("class")]), this._styles.isEmpty || (yield ["style", this.getAttribute("style")]);
        }
        getAttribute(e2) {
          if (e2 == "class")
            return this._classes.size > 0 ? [...this._classes].join(" ") : void 0;
          if (e2 == "style") {
            const e3 = this._styles.toString();
            return e3 == "" ? void 0 : e3;
          }
          return this._attrs.get(e2);
        }
        hasAttribute(e2) {
          return e2 == "class" ? this._classes.size > 0 : e2 == "style" ? !this._styles.isEmpty : this._attrs.has(e2);
        }
        isSimilar(e2) {
          if (!(e2 instanceof eo))
            return false;
          if (this === e2)
            return true;
          if (this.name != e2.name)
            return false;
          if (this.isAllowedInsideAttributeElement != e2.isAllowedInsideAttributeElement)
            return false;
          if (this._attrs.size !== e2._attrs.size || this._classes.size !== e2._classes.size || this._styles.size !== e2._styles.size)
            return false;
          for (const [t2, i2] of this._attrs)
            if (!e2._attrs.has(t2) || e2._attrs.get(t2) !== i2)
              return false;
          for (const t2 of this._classes)
            if (!e2._classes.has(t2))
              return false;
          for (const t2 of this._styles.getStyleNames())
            if (!e2._styles.has(t2) || e2._styles.getAsString(t2) !== this._styles.getAsString(t2))
              return false;
          return true;
        }
        hasClass(...e2) {
          for (const t2 of e2)
            if (!this._classes.has(t2))
              return false;
          return true;
        }
        getClassNames() {
          return this._classes.keys();
        }
        getStyle(e2) {
          return this._styles.getAsString(e2);
        }
        getNormalizedStyle(e2) {
          return this._styles.getNormalized(e2);
        }
        getStyleNames(e2 = false) {
          return this._styles.getStyleNames(e2);
        }
        hasStyle(...e2) {
          for (const t2 of e2)
            if (!this._styles.has(t2))
              return false;
          return true;
        }
        findAncestor(...e2) {
          const t2 = new mn(...e2);
          let i2 = this.parent;
          for (; i2; ) {
            if (t2.match(i2))
              return i2;
            i2 = i2.parent;
          }
          return null;
        }
        getCustomProperty(e2) {
          return this._customProperties.get(e2);
        }
        *getCustomProperties() {
          yield* this._customProperties.entries();
        }
        getIdentity() {
          const e2 = Array.from(this._classes).sort().join(","), t2 = this._styles.toString(), i2 = Array.from(this._attrs).map((e3) => `${e3[0]}="${e3[1]}"`).sort().join(" ");
          return this.name + (e2 == "" ? "" : ` class="${e2}"`) + (t2 ? ` style="${t2}"` : "") + (i2 == "" ? "" : " " + i2);
        }
        _clone(e2 = false) {
          const t2 = [];
          if (e2)
            for (const i3 of this.getChildren())
              t2.push(i3._clone(e2));
          const i2 = new this.constructor(this.document, this.name, this._attrs, t2);
          return i2._classes = new Set(this._classes), i2._styles.set(this._styles.getNormalized()), i2._customProperties = new Map(this._customProperties), i2.getFillerOffset = this.getFillerOffset, i2._isAllowedInsideAttributeElement = this.isAllowedInsideAttributeElement, i2;
        }
        _appendChild(e2) {
          return this._insertChild(this.childCount, e2);
        }
        _insertChild(e2, t2) {
          this._fireChange("children", this);
          let i2 = 0;
          const n2 = function(e3, t3) {
            if (typeof t3 == "string")
              return [new hn(e3, t3)];
            Ji(t3) || (t3 = [t3]);
            return Array.from(t3).map((t4) => typeof t4 == "string" ? new hn(e3, t4) : t4 instanceof un ? new hn(e3, t4.data) : t4);
          }(this.document, t2);
          for (const t3 of n2)
            t3.parent !== null && t3._remove(), t3.parent = this, t3.document = this.document, this._children.splice(e2, 0, t3), e2++, i2++;
          return i2;
        }
        _removeChildren(e2, t2 = 1) {
          this._fireChange("children", this);
          for (let i2 = e2; i2 < e2 + t2; i2++)
            this._children[i2].parent = null;
          return this._children.splice(e2, t2);
        }
        _setAttribute(e2, t2) {
          t2 = String(t2), this._fireChange("attributes", this), e2 == "class" ? to(this._classes, t2) : e2 == "style" ? this._styles.setTo(t2) : this._attrs.set(e2, t2);
        }
        _removeAttribute(e2) {
          return this._fireChange("attributes", this), e2 == "class" ? this._classes.size > 0 && (this._classes.clear(), true) : e2 == "style" ? !this._styles.isEmpty && (this._styles.clear(), true) : this._attrs.delete(e2);
        }
        _addClass(e2) {
          this._fireChange("attributes", this);
          for (const t2 of en(e2))
            this._classes.add(t2);
        }
        _removeClass(e2) {
          this._fireChange("attributes", this);
          for (const t2 of en(e2))
            this._classes.delete(t2);
        }
        _setStyle(e2, t2) {
          this._fireChange("attributes", this), this._styles.set(e2, t2);
        }
        _removeStyle(e2) {
          this._fireChange("attributes", this);
          for (const t2 of en(e2))
            this._styles.remove(t2);
        }
        _setCustomProperty(e2, t2) {
          this._customProperties.set(e2, t2);
        }
        _removeCustomProperty(e2) {
          return this._customProperties.delete(e2);
        }
      }
      function to(e2, t2) {
        const i2 = t2.split(/\s+/);
        e2.clear(), i2.forEach((t3) => e2.add(t3));
      }
      class io extends eo {
        constructor(e2, t2, i2, n2) {
          super(e2, t2, i2, n2), this.getFillerOffset = no;
        }
        is(e2, t2 = null) {
          return t2 ? t2 === this.name && (e2 === "containerElement" || e2 === "view:containerElement" || e2 === "element" || e2 === "view:element") : e2 === "containerElement" || e2 === "view:containerElement" || e2 === "element" || e2 === "view:element" || e2 === "node" || e2 === "view:node";
        }
      }
      function no() {
        const e2 = [...this.getChildren()], t2 = e2[this.childCount - 1];
        if (t2 && t2.is("element", "br"))
          return this.childCount;
        for (const t3 of e2)
          if (!t3.is("uiElement"))
            return null;
        return this.childCount;
      }
      class oo extends io {
        constructor(e2, t2, i2, n2) {
          super(e2, t2, i2, n2), this.set("isReadOnly", false), this.set("isFocused", false), this.bind("isReadOnly").to(e2), this.bind("isFocused").to(e2, "isFocused", (t3) => t3 && e2.selection.editableElement == this), this.listenTo(e2.selection, "change", () => {
            this.isFocused = e2.isFocused && e2.selection.editableElement == this;
          });
        }
        is(e2, t2 = null) {
          return t2 ? t2 === this.name && (e2 === "editableElement" || e2 === "view:editableElement" || e2 === "containerElement" || e2 === "view:containerElement" || e2 === "element" || e2 === "view:element") : e2 === "editableElement" || e2 === "view:editableElement" || e2 === "containerElement" || e2 === "view:containerElement" || e2 === "element" || e2 === "view:element" || e2 === "node" || e2 === "view:node";
        }
        destroy() {
          this.stopListening();
        }
      }
      Ke(oo, Ue);
      const ro = Symbol("rootName");
      class so extends oo {
        constructor(e2, t2) {
          super(e2, t2), this.rootName = "main";
        }
        is(e2, t2 = null) {
          return t2 ? t2 === this.name && (e2 === "rootElement" || e2 === "view:rootElement" || e2 === "editableElement" || e2 === "view:editableElement" || e2 === "containerElement" || e2 === "view:containerElement" || e2 === "element" || e2 === "view:element") : e2 === "rootElement" || e2 === "view:rootElement" || e2 === "editableElement" || e2 === "view:editableElement" || e2 === "containerElement" || e2 === "view:containerElement" || e2 === "element" || e2 === "view:element" || e2 === "node" || e2 === "view:node";
        }
        get rootName() {
          return this.getCustomProperty(ro);
        }
        set rootName(e2) {
          this._setCustomProperty(ro, e2);
        }
        set _name(e2) {
          this.name = e2;
        }
      }
      class ao {
        constructor(e2 = {}) {
          if (!e2.boundaries && !e2.startPosition)
            throw new c.a("view-tree-walker-no-start-position", null);
          if (e2.direction && e2.direction != "forward" && e2.direction != "backward")
            throw new c.a("view-tree-walker-unknown-direction", e2.startPosition, { direction: e2.direction });
          this.boundaries = e2.boundaries || null, e2.startPosition ? this.position = co._createAt(e2.startPosition) : this.position = co._createAt(e2.boundaries[e2.direction == "backward" ? "end" : "start"]), this.direction = e2.direction || "forward", this.singleCharacters = !!e2.singleCharacters, this.shallow = !!e2.shallow, this.ignoreElementEnd = !!e2.ignoreElementEnd, this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null, this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;
        }
        [Symbol.iterator]() {
          return this;
        }
        skip(e2) {
          let t2, i2, n2;
          do {
            n2 = this.position, { done: t2, value: i2 } = this.next();
          } while (!t2 && e2(i2));
          t2 || (this.position = n2);
        }
        next() {
          return this.direction == "forward" ? this._next() : this._previous();
        }
        _next() {
          let e2 = this.position.clone();
          const t2 = this.position, i2 = e2.parent;
          if (i2.parent === null && e2.offset === i2.childCount)
            return { done: true };
          if (i2 === this._boundaryEndParent && e2.offset == this.boundaries.end.offset)
            return { done: true };
          let n2;
          if (i2 instanceof hn) {
            if (e2.isAtEnd)
              return this.position = co._createAfter(i2), this._next();
            n2 = i2.data[e2.offset];
          } else
            n2 = i2.getChild(e2.offset);
          if (n2 instanceof eo)
            return this.shallow ? e2.offset++ : e2 = new co(n2, 0), this.position = e2, this._formatReturnValue("elementStart", n2, t2, e2, 1);
          if (n2 instanceof hn) {
            if (this.singleCharacters)
              return e2 = new co(n2, 0), this.position = e2, this._next();
            {
              let i3, o2 = n2.data.length;
              return n2 == this._boundaryEndParent ? (o2 = this.boundaries.end.offset, i3 = new un(n2, 0, o2), e2 = co._createAfter(i3)) : (i3 = new un(n2, 0, n2.data.length), e2.offset++), this.position = e2, this._formatReturnValue("text", i3, t2, e2, o2);
            }
          }
          if (typeof n2 == "string") {
            let n3;
            if (this.singleCharacters)
              n3 = 1;
            else {
              n3 = (i2 === this._boundaryEndParent ? this.boundaries.end.offset : i2.data.length) - e2.offset;
            }
            const o2 = new un(i2, e2.offset, n3);
            return e2.offset += n3, this.position = e2, this._formatReturnValue("text", o2, t2, e2, n3);
          }
          return e2 = co._createAfter(i2), this.position = e2, this.ignoreElementEnd ? this._next() : this._formatReturnValue("elementEnd", i2, t2, e2);
        }
        _previous() {
          let e2 = this.position.clone();
          const t2 = this.position, i2 = e2.parent;
          if (i2.parent === null && e2.offset === 0)
            return { done: true };
          if (i2 == this._boundaryStartParent && e2.offset == this.boundaries.start.offset)
            return { done: true };
          let n2;
          if (i2 instanceof hn) {
            if (e2.isAtStart)
              return this.position = co._createBefore(i2), this._previous();
            n2 = i2.data[e2.offset - 1];
          } else
            n2 = i2.getChild(e2.offset - 1);
          if (n2 instanceof eo)
            return this.shallow ? (e2.offset--, this.position = e2, this._formatReturnValue("elementStart", n2, t2, e2, 1)) : (e2 = new co(n2, n2.childCount), this.position = e2, this.ignoreElementEnd ? this._previous() : this._formatReturnValue("elementEnd", n2, t2, e2));
          if (n2 instanceof hn) {
            if (this.singleCharacters)
              return e2 = new co(n2, n2.data.length), this.position = e2, this._previous();
            {
              let i3, o2 = n2.data.length;
              if (n2 == this._boundaryStartParent) {
                const t3 = this.boundaries.start.offset;
                i3 = new un(n2, t3, n2.data.length - t3), o2 = i3.data.length, e2 = co._createBefore(i3);
              } else
                i3 = new un(n2, 0, n2.data.length), e2.offset--;
              return this.position = e2, this._formatReturnValue("text", i3, t2, e2, o2);
            }
          }
          if (typeof n2 == "string") {
            let n3;
            if (this.singleCharacters)
              n3 = 1;
            else {
              const t3 = i2 === this._boundaryStartParent ? this.boundaries.start.offset : 0;
              n3 = e2.offset - t3;
            }
            e2.offset -= n3;
            const o2 = new un(i2, e2.offset, n3);
            return this.position = e2, this._formatReturnValue("text", o2, t2, e2, n3);
          }
          return e2 = co._createBefore(i2), this.position = e2, this._formatReturnValue("elementStart", i2, t2, e2, 1);
        }
        _formatReturnValue(e2, t2, i2, n2, o2) {
          return t2 instanceof un && (t2.offsetInText + t2.data.length == t2.textNode.data.length && (this.direction != "forward" || this.boundaries && this.boundaries.end.isEqual(this.position) ? i2 = co._createAfter(t2.textNode) : (n2 = co._createAfter(t2.textNode), this.position = n2)), t2.offsetInText === 0 && (this.direction != "backward" || this.boundaries && this.boundaries.start.isEqual(this.position) ? i2 = co._createBefore(t2.textNode) : (n2 = co._createBefore(t2.textNode), this.position = n2))), { done: false, value: { type: e2, item: t2, previousPosition: i2, nextPosition: n2, length: o2 } };
        }
      }
      class co {
        constructor(e2, t2) {
          this.parent = e2, this.offset = t2;
        }
        get nodeAfter() {
          return this.parent.is("$text") ? null : this.parent.getChild(this.offset) || null;
        }
        get nodeBefore() {
          return this.parent.is("$text") ? null : this.parent.getChild(this.offset - 1) || null;
        }
        get isAtStart() {
          return this.offset === 0;
        }
        get isAtEnd() {
          const e2 = this.parent.is("$text") ? this.parent.data.length : this.parent.childCount;
          return this.offset === e2;
        }
        get root() {
          return this.parent.root;
        }
        get editableElement() {
          let e2 = this.parent;
          for (; !(e2 instanceof oo); ) {
            if (!e2.parent)
              return null;
            e2 = e2.parent;
          }
          return e2;
        }
        getShiftedBy(e2) {
          const t2 = co._createAt(this), i2 = t2.offset + e2;
          return t2.offset = i2 < 0 ? 0 : i2, t2;
        }
        getLastMatchingPosition(e2, t2 = {}) {
          t2.startPosition = this;
          const i2 = new ao(t2);
          return i2.skip(e2), i2.position;
        }
        getAncestors() {
          return this.parent.is("documentFragment") ? [this.parent] : this.parent.getAncestors({ includeSelf: true });
        }
        getCommonAncestor(e2) {
          const t2 = this.getAncestors(), i2 = e2.getAncestors();
          let n2 = 0;
          for (; t2[n2] == i2[n2] && t2[n2]; )
            n2++;
          return n2 === 0 ? null : t2[n2 - 1];
        }
        is(e2) {
          return e2 === "position" || e2 === "view:position";
        }
        isEqual(e2) {
          return this.parent == e2.parent && this.offset == e2.offset;
        }
        isBefore(e2) {
          return this.compareWith(e2) == "before";
        }
        isAfter(e2) {
          return this.compareWith(e2) == "after";
        }
        compareWith(e2) {
          if (this.root !== e2.root)
            return "different";
          if (this.isEqual(e2))
            return "same";
          const t2 = this.parent.is("node") ? this.parent.getPath() : [], i2 = e2.parent.is("node") ? e2.parent.getPath() : [];
          t2.push(this.offset), i2.push(e2.offset);
          const n2 = cn(t2, i2);
          switch (n2) {
            case "prefix":
              return "before";
            case "extension":
              return "after";
            default:
              return t2[n2] < i2[n2] ? "before" : "after";
          }
        }
        getWalker(e2 = {}) {
          return e2.startPosition = this, new ao(e2);
        }
        clone() {
          return new co(this.parent, this.offset);
        }
        static _createAt(e2, t2) {
          if (e2 instanceof co)
            return new this(e2.parent, e2.offset);
          {
            const i2 = e2;
            if (t2 == "end")
              t2 = i2.is("$text") ? i2.data.length : i2.childCount;
            else {
              if (t2 == "before")
                return this._createBefore(i2);
              if (t2 == "after")
                return this._createAfter(i2);
              if (t2 !== 0 && !t2)
                throw new c.a("view-createpositionat-offset-required", i2);
            }
            return new co(i2, t2);
          }
        }
        static _createAfter(e2) {
          if (e2.is("$textProxy"))
            return new co(e2.textNode, e2.offsetInText + e2.data.length);
          if (!e2.parent)
            throw new c.a("view-position-after-root", e2, { root: e2 });
          return new co(e2.parent, e2.index + 1);
        }
        static _createBefore(e2) {
          if (e2.is("$textProxy"))
            return new co(e2.textNode, e2.offsetInText);
          if (!e2.parent)
            throw new c.a("view-position-before-root", e2, { root: e2 });
          return new co(e2.parent, e2.index);
        }
      }
      class lo {
        constructor(e2, t2 = null) {
          this.start = e2.clone(), this.end = t2 ? t2.clone() : e2.clone();
        }
        *[Symbol.iterator]() {
          yield* new ao({ boundaries: this, ignoreElementEnd: true });
        }
        get isCollapsed() {
          return this.start.isEqual(this.end);
        }
        get isFlat() {
          return this.start.parent === this.end.parent;
        }
        get root() {
          return this.start.root;
        }
        getEnlarged() {
          let e2 = this.start.getLastMatchingPosition(ho, { direction: "backward" }), t2 = this.end.getLastMatchingPosition(ho);
          return e2.parent.is("$text") && e2.isAtStart && (e2 = co._createBefore(e2.parent)), t2.parent.is("$text") && t2.isAtEnd && (t2 = co._createAfter(t2.parent)), new lo(e2, t2);
        }
        getTrimmed() {
          let e2 = this.start.getLastMatchingPosition(ho);
          if (e2.isAfter(this.end) || e2.isEqual(this.end))
            return new lo(e2, e2);
          let t2 = this.end.getLastMatchingPosition(ho, { direction: "backward" });
          const i2 = e2.nodeAfter, n2 = t2.nodeBefore;
          return i2 && i2.is("$text") && (e2 = new co(i2, 0)), n2 && n2.is("$text") && (t2 = new co(n2, n2.data.length)), new lo(e2, t2);
        }
        isEqual(e2) {
          return this == e2 || this.start.isEqual(e2.start) && this.end.isEqual(e2.end);
        }
        containsPosition(e2) {
          return e2.isAfter(this.start) && e2.isBefore(this.end);
        }
        containsRange(e2, t2 = false) {
          e2.isCollapsed && (t2 = false);
          const i2 = this.containsPosition(e2.start) || t2 && this.start.isEqual(e2.start), n2 = this.containsPosition(e2.end) || t2 && this.end.isEqual(e2.end);
          return i2 && n2;
        }
        getDifference(e2) {
          const t2 = [];
          return this.isIntersecting(e2) ? (this.containsPosition(e2.start) && t2.push(new lo(this.start, e2.start)), this.containsPosition(e2.end) && t2.push(new lo(e2.end, this.end))) : t2.push(this.clone()), t2;
        }
        getIntersection(e2) {
          if (this.isIntersecting(e2)) {
            let t2 = this.start, i2 = this.end;
            return this.containsPosition(e2.start) && (t2 = e2.start), this.containsPosition(e2.end) && (i2 = e2.end), new lo(t2, i2);
          }
          return null;
        }
        getWalker(e2 = {}) {
          return e2.boundaries = this, new ao(e2);
        }
        getCommonAncestor() {
          return this.start.getCommonAncestor(this.end);
        }
        getContainedElement() {
          if (this.isCollapsed)
            return null;
          let e2 = this.start.nodeAfter, t2 = this.end.nodeBefore;
          return this.start.parent.is("$text") && this.start.isAtEnd && this.start.parent.nextSibling && (e2 = this.start.parent.nextSibling), this.end.parent.is("$text") && this.end.isAtStart && this.end.parent.previousSibling && (t2 = this.end.parent.previousSibling), e2 && e2.is("element") && e2 === t2 ? e2 : null;
        }
        clone() {
          return new lo(this.start, this.end);
        }
        *getItems(e2 = {}) {
          e2.boundaries = this, e2.ignoreElementEnd = true;
          const t2 = new ao(e2);
          for (const e3 of t2)
            yield e3.item;
        }
        *getPositions(e2 = {}) {
          e2.boundaries = this;
          const t2 = new ao(e2);
          yield t2.position;
          for (const e3 of t2)
            yield e3.nextPosition;
        }
        is(e2) {
          return e2 === "range" || e2 === "view:range";
        }
        isIntersecting(e2) {
          return this.start.isBefore(e2.end) && this.end.isAfter(e2.start);
        }
        static _createFromParentsAndOffsets(e2, t2, i2, n2) {
          return new this(new co(e2, t2), new co(i2, n2));
        }
        static _createFromPositionAndShift(e2, t2) {
          const i2 = e2, n2 = e2.getShiftedBy(t2);
          return t2 > 0 ? new this(i2, n2) : new this(n2, i2);
        }
        static _createIn(e2) {
          return this._createFromParentsAndOffsets(e2, 0, e2, e2.childCount);
        }
        static _createOn(e2) {
          const t2 = e2.is("$textProxy") ? e2.offsetSize : 1;
          return this._createFromPositionAndShift(co._createBefore(e2), t2);
        }
      }
      function ho(e2) {
        return !(!e2.item.is("attributeElement") && !e2.item.is("uiElement"));
      }
      function uo(e2) {
        let t2 = 0;
        for (const i2 of e2)
          t2++;
        return t2;
      }
      class go {
        constructor(e2 = null, t2, i2) {
          this._ranges = [], this._lastRangeBackward = false, this._isFake = false, this._fakeSelectionLabel = "", this.setTo(e2, t2, i2);
        }
        get isFake() {
          return this._isFake;
        }
        get fakeSelectionLabel() {
          return this._fakeSelectionLabel;
        }
        get anchor() {
          if (!this._ranges.length)
            return null;
          const e2 = this._ranges[this._ranges.length - 1];
          return (this._lastRangeBackward ? e2.end : e2.start).clone();
        }
        get focus() {
          if (!this._ranges.length)
            return null;
          const e2 = this._ranges[this._ranges.length - 1];
          return (this._lastRangeBackward ? e2.start : e2.end).clone();
        }
        get isCollapsed() {
          return this.rangeCount === 1 && this._ranges[0].isCollapsed;
        }
        get rangeCount() {
          return this._ranges.length;
        }
        get isBackward() {
          return !this.isCollapsed && this._lastRangeBackward;
        }
        get editableElement() {
          return this.anchor ? this.anchor.editableElement : null;
        }
        *getRanges() {
          for (const e2 of this._ranges)
            yield e2.clone();
        }
        getFirstRange() {
          let e2 = null;
          for (const t2 of this._ranges)
            e2 && !t2.start.isBefore(e2.start) || (e2 = t2);
          return e2 ? e2.clone() : null;
        }
        getLastRange() {
          let e2 = null;
          for (const t2 of this._ranges)
            e2 && !t2.end.isAfter(e2.end) || (e2 = t2);
          return e2 ? e2.clone() : null;
        }
        getFirstPosition() {
          const e2 = this.getFirstRange();
          return e2 ? e2.start.clone() : null;
        }
        getLastPosition() {
          const e2 = this.getLastRange();
          return e2 ? e2.end.clone() : null;
        }
        isEqual(e2) {
          if (this.isFake != e2.isFake)
            return false;
          if (this.isFake && this.fakeSelectionLabel != e2.fakeSelectionLabel)
            return false;
          if (this.rangeCount != e2.rangeCount)
            return false;
          if (this.rangeCount === 0)
            return true;
          if (!this.anchor.isEqual(e2.anchor) || !this.focus.isEqual(e2.focus))
            return false;
          for (const t2 of this._ranges) {
            let i2 = false;
            for (const n2 of e2._ranges)
              if (t2.isEqual(n2)) {
                i2 = true;
                break;
              }
            if (!i2)
              return false;
          }
          return true;
        }
        isSimilar(e2) {
          if (this.isBackward != e2.isBackward)
            return false;
          const t2 = uo(this.getRanges());
          if (t2 != uo(e2.getRanges()))
            return false;
          if (t2 == 0)
            return true;
          for (let t3 of this.getRanges()) {
            t3 = t3.getTrimmed();
            let i2 = false;
            for (let n2 of e2.getRanges())
              if (n2 = n2.getTrimmed(), t3.start.isEqual(n2.start) && t3.end.isEqual(n2.end)) {
                i2 = true;
                break;
              }
            if (!i2)
              return false;
          }
          return true;
        }
        getSelectedElement() {
          return this.rangeCount !== 1 ? null : this.getFirstRange().getContainedElement();
        }
        setTo(e2, t2, i2) {
          if (e2 === null)
            this._setRanges([]), this._setFakeOptions(t2);
          else if (e2 instanceof go || e2 instanceof mo)
            this._setRanges(e2.getRanges(), e2.isBackward), this._setFakeOptions({ fake: e2.isFake, label: e2.fakeSelectionLabel });
          else if (e2 instanceof lo)
            this._setRanges([e2], t2 && t2.backward), this._setFakeOptions(t2);
          else if (e2 instanceof co)
            this._setRanges([new lo(e2)]), this._setFakeOptions(t2);
          else if (e2 instanceof dn) {
            const n2 = !!i2 && !!i2.backward;
            let o2;
            if (t2 === void 0)
              throw new c.a("view-selection-setto-required-second-parameter", this);
            o2 = t2 == "in" ? lo._createIn(e2) : t2 == "on" ? lo._createOn(e2) : new lo(co._createAt(e2, t2)), this._setRanges([o2], n2), this._setFakeOptions(i2);
          } else {
            if (!Ji(e2))
              throw new c.a("view-selection-setto-not-selectable", this);
            this._setRanges(e2, t2 && t2.backward), this._setFakeOptions(t2);
          }
          this.fire("change");
        }
        setFocus(e2, t2) {
          if (this.anchor === null)
            throw new c.a("view-selection-setfocus-no-ranges", this);
          const i2 = co._createAt(e2, t2);
          if (i2.compareWith(this.focus) == "same")
            return;
          const n2 = this.anchor;
          this._ranges.pop(), i2.compareWith(n2) == "before" ? this._addRange(new lo(i2, n2), true) : this._addRange(new lo(n2, i2)), this.fire("change");
        }
        is(e2) {
          return e2 === "selection" || e2 === "view:selection";
        }
        _setRanges(e2, t2 = false) {
          e2 = Array.from(e2), this._ranges = [];
          for (const t3 of e2)
            this._addRange(t3);
          this._lastRangeBackward = !!t2;
        }
        _setFakeOptions(e2 = {}) {
          this._isFake = !!e2.fake, this._fakeSelectionLabel = e2.fake && e2.label || "";
        }
        _addRange(e2, t2 = false) {
          if (!(e2 instanceof lo))
            throw new c.a("view-selection-add-range-not-range", this);
          this._pushRange(e2), this._lastRangeBackward = !!t2;
        }
        _pushRange(e2) {
          for (const t2 of this._ranges)
            if (e2.isIntersecting(t2))
              throw new c.a("view-selection-range-intersects", this, { addedRange: e2, intersectingRange: t2 });
          this._ranges.push(new lo(e2.start, e2.end));
        }
      }
      Ke(go, h);
      class mo {
        constructor(e2 = null, t2, i2) {
          this._selection = new go(), this._selection.delegate("change").to(this), this._selection.setTo(e2, t2, i2);
        }
        get isFake() {
          return this._selection.isFake;
        }
        get fakeSelectionLabel() {
          return this._selection.fakeSelectionLabel;
        }
        get anchor() {
          return this._selection.anchor;
        }
        get focus() {
          return this._selection.focus;
        }
        get isCollapsed() {
          return this._selection.isCollapsed;
        }
        get rangeCount() {
          return this._selection.rangeCount;
        }
        get isBackward() {
          return this._selection.isBackward;
        }
        get editableElement() {
          return this._selection.editableElement;
        }
        get _ranges() {
          return this._selection._ranges;
        }
        *getRanges() {
          yield* this._selection.getRanges();
        }
        getFirstRange() {
          return this._selection.getFirstRange();
        }
        getLastRange() {
          return this._selection.getLastRange();
        }
        getFirstPosition() {
          return this._selection.getFirstPosition();
        }
        getLastPosition() {
          return this._selection.getLastPosition();
        }
        getSelectedElement() {
          return this._selection.getSelectedElement();
        }
        isEqual(e2) {
          return this._selection.isEqual(e2);
        }
        isSimilar(e2) {
          return this._selection.isSimilar(e2);
        }
        is(e2) {
          return e2 === "selection" || e2 == "documentSelection" || e2 == "view:selection" || e2 == "view:documentSelection";
        }
        _setTo(e2, t2, i2) {
          this._selection.setTo(e2, t2, i2);
        }
        _setFocus(e2, t2) {
          this._selection.setFocus(e2, t2);
        }
      }
      Ke(mo, h);
      class fo extends o {
        constructor(e2, t2, i2) {
          super(e2, t2), this.startRange = i2, this._eventPhase = "none", this._currentTarget = null;
        }
        get eventPhase() {
          return this._eventPhase;
        }
        get currentTarget() {
          return this._currentTarget;
        }
      }
      const po = Symbol("bubbling contexts");
      var bo = { fire(e2, ...t2) {
        try {
          const i2 = e2 instanceof o ? e2 : new o(this, e2), n2 = vo(this);
          if (!n2.size)
            return;
          if (wo(i2, "capturing", this), ko(n2, "$capture", i2, ...t2))
            return i2.return;
          const r2 = i2.startRange || this.selection.getFirstRange(), s2 = r2 ? r2.getContainedElement() : null, a2 = !!s2 && Boolean(_o(n2, s2));
          let c2 = s2 || function(e3) {
            if (!e3)
              return null;
            const t3 = e3.start.parent, i3 = e3.end.parent, n3 = t3.getPath(), o2 = i3.getPath();
            return n3.length > o2.length ? t3 : i3;
          }(r2);
          if (wo(i2, "atTarget", c2), !a2) {
            if (ko(n2, "$text", i2, ...t2))
              return i2.return;
            wo(i2, "bubbling", c2);
          }
          for (; c2; ) {
            if (c2.is("rootElement")) {
              if (ko(n2, "$root", i2, ...t2))
                return i2.return;
            } else if (c2.is("element") && ko(n2, c2.name, i2, ...t2))
              return i2.return;
            if (ko(n2, c2, i2, ...t2))
              return i2.return;
            c2 = c2.parent, wo(i2, "bubbling", c2);
          }
          return wo(i2, "bubbling", this), ko(n2, "$document", i2, ...t2), i2.return;
        } catch (e3) {
          c.a.rethrowUnexpectedError(e3, this);
        }
      }, _addEventListener(e2, t2, i2) {
        const n2 = en(i2.context || "$document"), o2 = vo(this);
        for (const r2 of n2) {
          let n3 = o2.get(r2);
          n3 || (n3 = Object.create(h), o2.set(r2, n3)), this.listenTo(n3, e2, t2, i2);
        }
      }, _removeEventListener(e2, t2) {
        const i2 = vo(this);
        for (const n2 of i2.values())
          this.stopListening(n2, e2, t2);
      } };
      function wo(e2, t2, i2) {
        e2 instanceof fo && (e2._eventPhase = t2, e2._currentTarget = i2);
      }
      function ko(e2, t2, i2, ...n2) {
        const o2 = typeof t2 == "string" ? e2.get(t2) : _o(e2, t2);
        return !!o2 && (o2.fire(i2, ...n2), i2.stop.called);
      }
      function _o(e2, t2) {
        for (const [i2, n2] of e2)
          if (typeof i2 == "function" && i2(t2))
            return n2;
        return null;
      }
      function vo(e2) {
        return e2[po] || (e2[po] = new Map()), e2[po];
      }
      class yo {
        constructor(e2) {
          this.selection = new mo(), this.roots = new Zi({ idProperty: "rootName" }), this.stylesProcessor = e2, this.set("isReadOnly", false), this.set("isFocused", false), this.set("isComposing", false), this._postFixers = new Set();
        }
        getRoot(e2 = "main") {
          return this.roots.get(e2);
        }
        registerPostFixer(e2) {
          this._postFixers.add(e2);
        }
        destroy() {
          this.roots.map((e2) => e2.destroy()), this.stopListening();
        }
        _callPostFixers(e2) {
          let t2 = false;
          do {
            for (const i2 of this._postFixers)
              if (t2 = i2(e2), t2)
                break;
          } while (t2);
        }
      }
      Ke(yo, bo), Ke(yo, Ue);
      class xo extends eo {
        constructor(e2, t2, i2, n2) {
          super(e2, t2, i2, n2), this.getFillerOffset = Ao, this._priority = 10, this._id = null, this._clonesGroup = null;
        }
        get priority() {
          return this._priority;
        }
        get id() {
          return this._id;
        }
        getElementsWithSameId() {
          if (this.id === null)
            throw new c.a("attribute-element-get-elements-with-same-id-no-id", this);
          return new Set(this._clonesGroup);
        }
        is(e2, t2 = null) {
          return t2 ? t2 === this.name && (e2 === "attributeElement" || e2 === "view:attributeElement" || e2 === "element" || e2 === "view:element") : e2 === "attributeElement" || e2 === "view:attributeElement" || e2 === "element" || e2 === "view:element" || e2 === "node" || e2 === "view:node";
        }
        isSimilar(e2) {
          return this.id !== null || e2.id !== null ? this.id === e2.id : super.isSimilar(e2) && this.priority == e2.priority;
        }
        _clone(e2) {
          const t2 = super._clone(e2);
          return t2._priority = this._priority, t2._id = this._id, t2;
        }
      }
      function Ao() {
        if (Co(this))
          return null;
        let e2 = this.parent;
        for (; e2 && e2.is("attributeElement"); ) {
          if (Co(e2) > 1)
            return null;
          e2 = e2.parent;
        }
        return !e2 || Co(e2) > 1 ? null : this.childCount;
      }
      function Co(e2) {
        return Array.from(e2.getChildren()).filter((e3) => !e3.is("uiElement")).length;
      }
      xo.DEFAULT_PRIORITY = 10;
      class To extends eo {
        constructor(e2, t2, i2, n2) {
          super(e2, t2, i2, n2), this._isAllowedInsideAttributeElement = true, this.getFillerOffset = Eo;
        }
        is(e2, t2 = null) {
          return t2 ? t2 === this.name && (e2 === "emptyElement" || e2 === "view:emptyElement" || e2 === "element" || e2 === "view:element") : e2 === "emptyElement" || e2 === "view:emptyElement" || e2 === "element" || e2 === "view:element" || e2 === "node" || e2 === "view:node";
        }
        _insertChild(e2, t2) {
          if (t2 && (t2 instanceof dn || Array.from(t2).length > 0))
            throw new c.a("view-emptyelement-cannot-add", [this, t2]);
        }
      }
      function Eo() {
        return null;
      }
      const Io = navigator.userAgent.toLowerCase();
      var So = { isMac: function(e2) {
        return e2.indexOf("macintosh") > -1;
      }(Io), isGecko: function(e2) {
        return !!e2.match(/gecko\/\d+/);
      }(Io), isSafari: function(e2) {
        return e2.indexOf(" applewebkit/") > -1 && e2.indexOf("chrome") === -1;
      }(Io), isAndroid: function(e2) {
        return e2.indexOf("android") > -1;
      }(Io), isBlink: function(e2) {
        return e2.indexOf("chrome/") > -1 && e2.indexOf("edge/") < 0;
      }(Io), features: { isRegExpUnicodePropertySupported: function() {
        let e2 = false;
        try {
          e2 = "\u0107".search(new RegExp("[\\p{L}]", "u")) === 0;
        } catch (e3) {
        }
        return e2;
      }() } };
      const Po = { ctrl: "\u2303", cmd: "\u2318", alt: "\u2325", shift: "\u21E7" }, Mo = { ctrl: "Ctrl+", alt: "Alt+", shift: "Shift+" }, No = function() {
        const e2 = { arrowleft: 37, arrowup: 38, arrowright: 39, arrowdown: 40, backspace: 8, delete: 46, enter: 13, space: 32, esc: 27, tab: 9, ctrl: 1114112, shift: 2228224, alt: 4456448, cmd: 8912896 };
        for (let t2 = 65; t2 <= 90; t2++) {
          const i2 = String.fromCharCode(t2);
          e2[i2.toLowerCase()] = t2;
        }
        for (let t2 = 48; t2 <= 57; t2++)
          e2[t2 - 48] = t2;
        for (let t2 = 112; t2 <= 123; t2++)
          e2["f" + (t2 - 111)] = t2;
        for (const t2 of "`-=[];',./\\")
          e2[t2] = t2.charCodeAt(0);
        return e2;
      }(), Ro = Object.fromEntries(Object.entries(No).map(([e2, t2]) => [t2, e2.charAt(0).toUpperCase() + e2.slice(1)]));
      function Oo(e2) {
        let t2;
        if (typeof e2 == "string") {
          if (t2 = No[e2.toLowerCase()], !t2)
            throw new c.a("keyboard-unknown-key", null, { key: e2 });
        } else
          t2 = e2.keyCode + (e2.altKey ? No.alt : 0) + (e2.ctrlKey ? No.ctrl : 0) + (e2.shiftKey ? No.shift : 0) + (e2.metaKey ? No.cmd : 0);
        return t2;
      }
      function zo(e2) {
        return typeof e2 == "string" && (e2 = function(e3) {
          return e3.split("+").map((e4) => e4.trim());
        }(e2)), e2.map((e3) => typeof e3 == "string" ? function(e4) {
          if (e4.endsWith("!"))
            return Oo(e4.slice(0, -1));
          const t2 = Oo(e4);
          return So.isMac && t2 == No.ctrl ? No.cmd : t2;
        }(e3) : e3).reduce((e3, t2) => t2 + e3, 0);
      }
      function Do(e2) {
        let t2 = zo(e2);
        return Object.entries(So.isMac ? Po : Mo).reduce((e3, [i2, n2]) => ((t2 & No[i2]) != 0 && (t2 &= ~No[i2], e3 += n2), e3), "") + (t2 ? Ro[t2] : "");
      }
      function Lo(e2, t2) {
        const i2 = t2 === "ltr";
        switch (e2) {
          case No.arrowleft:
            return i2 ? "left" : "right";
          case No.arrowright:
            return i2 ? "right" : "left";
          case No.arrowup:
            return "up";
          case No.arrowdown:
            return "down";
        }
      }
      class Vo extends eo {
        constructor(e2, t2, i2, n2) {
          super(e2, t2, i2, n2), this._isAllowedInsideAttributeElement = true, this.getFillerOffset = Bo;
        }
        is(e2, t2 = null) {
          return t2 ? t2 === this.name && (e2 === "uiElement" || e2 === "view:uiElement" || e2 === "element" || e2 === "view:element") : e2 === "uiElement" || e2 === "view:uiElement" || e2 === "element" || e2 === "view:element" || e2 === "node" || e2 === "view:node";
        }
        _insertChild(e2, t2) {
          if (t2 && (t2 instanceof dn || Array.from(t2).length > 0))
            throw new c.a("view-uielement-cannot-add", this);
        }
        render(e2) {
          return this.toDomElement(e2);
        }
        toDomElement(e2) {
          const t2 = e2.createElement(this.name);
          for (const e3 of this.getAttributeKeys())
            t2.setAttribute(e3, this.getAttribute(e3));
          return t2;
        }
      }
      function jo(e2) {
        e2.document.on("arrowKey", (t2, i2) => function(e3, t3, i3) {
          if (t3.keyCode == No.arrowright) {
            const e4 = t3.domTarget.ownerDocument.defaultView.getSelection(), n2 = e4.rangeCount == 1 && e4.getRangeAt(0).collapsed;
            if (n2 || t3.shiftKey) {
              const t4 = e4.focusNode, o2 = e4.focusOffset, r2 = i3.domPositionToView(t4, o2);
              if (r2 === null)
                return;
              let s2 = false;
              const a2 = r2.getLastMatchingPosition((e5) => (e5.item.is("uiElement") && (s2 = true), !(!e5.item.is("uiElement") && !e5.item.is("attributeElement"))));
              if (s2) {
                const t5 = i3.viewPositionToDom(a2);
                n2 ? e4.collapse(t5.parent, t5.offset) : e4.extend(t5.parent, t5.offset);
              }
            }
          }
        }(0, i2, e2.domConverter), { priority: "low" });
      }
      function Bo() {
        return null;
      }
      class Fo extends eo {
        constructor(e2, t2, i2, n2) {
          super(e2, t2, i2, n2), this._isAllowedInsideAttributeElement = true, this.getFillerOffset = Ho;
        }
        is(e2, t2 = null) {
          return t2 ? t2 === this.name && (e2 === "rawElement" || e2 === "view:rawElement" || e2 === "element" || e2 === "view:element") : e2 === "rawElement" || e2 === "view:rawElement" || e2 === this.name || e2 === "view:" + this.name || e2 === "element" || e2 === "view:element" || e2 === "node" || e2 === "view:node";
        }
        _insertChild(e2, t2) {
          if (t2 && (t2 instanceof dn || Array.from(t2).length > 0))
            throw new c.a("view-rawelement-cannot-add", [this, t2]);
        }
      }
      function Ho() {
        return null;
      }
      class Uo {
        constructor(e2, t2) {
          this.document = e2, this._children = [], t2 && this._insertChild(0, t2);
        }
        [Symbol.iterator]() {
          return this._children[Symbol.iterator]();
        }
        get childCount() {
          return this._children.length;
        }
        get isEmpty() {
          return this.childCount === 0;
        }
        get root() {
          return this;
        }
        get parent() {
          return null;
        }
        is(e2) {
          return e2 === "documentFragment" || e2 === "view:documentFragment";
        }
        _appendChild(e2) {
          return this._insertChild(this.childCount, e2);
        }
        getChild(e2) {
          return this._children[e2];
        }
        getChildIndex(e2) {
          return this._children.indexOf(e2);
        }
        getChildren() {
          return this._children[Symbol.iterator]();
        }
        _insertChild(e2, t2) {
          this._fireChange("children", this);
          let i2 = 0;
          const n2 = function(e3, t3) {
            if (typeof t3 == "string")
              return [new hn(e3, t3)];
            Ji(t3) || (t3 = [t3]);
            return Array.from(t3).map((t4) => typeof t4 == "string" ? new hn(e3, t4) : t4 instanceof un ? new hn(e3, t4.data) : t4);
          }(this.document, t2);
          for (const t3 of n2)
            t3.parent !== null && t3._remove(), t3.parent = this, this._children.splice(e2, 0, t3), e2++, i2++;
          return i2;
        }
        _removeChildren(e2, t2 = 1) {
          this._fireChange("children", this);
          for (let i2 = e2; i2 < e2 + t2; i2++)
            this._children[i2].parent = null;
          return this._children.splice(e2, t2);
        }
        _fireChange(e2, t2) {
          this.fire("change:" + e2, t2);
        }
      }
      Ke(Uo, h);
      class Wo {
        constructor(e2) {
          this.document = e2, this._cloneGroups = new Map();
        }
        setSelection(e2, t2, i2) {
          this.document.selection._setTo(e2, t2, i2);
        }
        setSelectionFocus(e2, t2) {
          this.document.selection._setFocus(e2, t2);
        }
        createDocumentFragment(e2) {
          return new Uo(this.document, e2);
        }
        createText(e2) {
          return new hn(this.document, e2);
        }
        createAttributeElement(e2, t2, i2 = {}) {
          const n2 = new xo(this.document, e2, t2);
          return typeof i2.priority == "number" && (n2._priority = i2.priority), i2.id && (n2._id = i2.id), n2;
        }
        createContainerElement(e2, t2, i2 = {}) {
          const n2 = new io(this.document, e2, t2);
          return i2.isAllowedInsideAttributeElement !== void 0 && (n2._isAllowedInsideAttributeElement = i2.isAllowedInsideAttributeElement), n2;
        }
        createEditableElement(e2, t2) {
          const i2 = new oo(this.document, e2, t2);
          return i2._document = this.document, i2;
        }
        createEmptyElement(e2, t2, i2 = {}) {
          const n2 = new To(this.document, e2, t2);
          return i2.isAllowedInsideAttributeElement !== void 0 && (n2._isAllowedInsideAttributeElement = i2.isAllowedInsideAttributeElement), n2;
        }
        createUIElement(e2, t2, i2, n2 = {}) {
          const o2 = new Vo(this.document, e2, t2);
          return i2 && (o2.render = i2), n2.isAllowedInsideAttributeElement !== void 0 && (o2._isAllowedInsideAttributeElement = n2.isAllowedInsideAttributeElement), o2;
        }
        createRawElement(e2, t2, i2, n2 = {}) {
          const o2 = new Fo(this.document, e2, t2);
          return o2.render = i2 || (() => {
          }), n2.isAllowedInsideAttributeElement !== void 0 && (o2._isAllowedInsideAttributeElement = n2.isAllowedInsideAttributeElement), o2;
        }
        setAttribute(e2, t2, i2) {
          i2._setAttribute(e2, t2);
        }
        removeAttribute(e2, t2) {
          t2._removeAttribute(e2);
        }
        addClass(e2, t2) {
          t2._addClass(e2);
        }
        removeClass(e2, t2) {
          t2._removeClass(e2);
        }
        setStyle(e2, t2, i2) {
          ct(e2) && i2 === void 0 && (i2 = t2), i2._setStyle(e2, t2);
        }
        removeStyle(e2, t2) {
          t2._removeStyle(e2);
        }
        setCustomProperty(e2, t2, i2) {
          i2._setCustomProperty(e2, t2);
        }
        removeCustomProperty(e2, t2) {
          return t2._removeCustomProperty(e2);
        }
        breakAttributes(e2) {
          return e2 instanceof co ? this._breakAttributes(e2) : this._breakAttributesRange(e2);
        }
        breakContainer(e2) {
          const t2 = e2.parent;
          if (!t2.is("containerElement"))
            throw new c.a("view-writer-break-non-container-element", this.document);
          if (!t2.parent)
            throw new c.a("view-writer-break-root", this.document);
          if (e2.isAtStart)
            return co._createBefore(t2);
          if (!e2.isAtEnd) {
            const i2 = t2._clone(false);
            this.insert(co._createAfter(t2), i2);
            const n2 = new lo(e2, co._createAt(t2, "end")), o2 = new co(i2, 0);
            this.move(n2, o2);
          }
          return co._createAfter(t2);
        }
        mergeAttributes(e2) {
          const t2 = e2.offset, i2 = e2.parent;
          if (i2.is("$text"))
            return e2;
          if (i2.is("attributeElement") && i2.childCount === 0) {
            const e3 = i2.parent, t3 = i2.index;
            return i2._remove(), this._removeFromClonedElementsGroup(i2), this.mergeAttributes(new co(e3, t3));
          }
          const n2 = i2.getChild(t2 - 1), o2 = i2.getChild(t2);
          if (!n2 || !o2)
            return e2;
          if (n2.is("$text") && o2.is("$text"))
            return Ko(n2, o2);
          if (n2.is("attributeElement") && o2.is("attributeElement") && n2.isSimilar(o2)) {
            const e3 = n2.childCount;
            return n2._appendChild(o2.getChildren()), o2._remove(), this._removeFromClonedElementsGroup(o2), this.mergeAttributes(new co(n2, e3));
          }
          return e2;
        }
        mergeContainers(e2) {
          const t2 = e2.nodeBefore, i2 = e2.nodeAfter;
          if (!(t2 && i2 && t2.is("containerElement") && i2.is("containerElement")))
            throw new c.a("view-writer-merge-containers-invalid-position", this.document);
          const n2 = t2.getChild(t2.childCount - 1), o2 = n2 instanceof hn ? co._createAt(n2, "end") : co._createAt(t2, "end");
          return this.move(lo._createIn(i2), co._createAt(t2, "end")), this.remove(lo._createOn(i2)), o2;
        }
        insert(e2, t2) {
          (function e3(t3, i3) {
            for (const n3 of t3) {
              if (!Qo.some((e4) => n3 instanceof e4))
                throw new c.a("view-writer-insert-invalid-node-type", i3);
              n3.is("$text") || e3(n3.getChildren(), i3);
            }
          })(t2 = Ji(t2) ? [...t2] : [t2], this.document);
          const i2 = t2.reduce((e3, t3) => {
            const i3 = e3[e3.length - 1], n3 = !(t3.is("uiElement") && t3.isAllowedInsideAttributeElement);
            return i3 && i3.breakAttributes == n3 ? i3.nodes.push(t3) : e3.push({ breakAttributes: n3, nodes: [t3] }), e3;
          }, []);
          let n2 = null, o2 = e2;
          for (const { nodes: e3, breakAttributes: t3 } of i2) {
            const i3 = this._insertNodes(o2, e3, t3);
            n2 || (n2 = i3.start), o2 = i3.end;
          }
          return n2 ? new lo(n2, o2) : new lo(e2);
        }
        remove(e2) {
          const t2 = e2 instanceof lo ? e2 : lo._createOn(e2);
          if (Zo(t2, this.document), t2.isCollapsed)
            return new Uo(this.document);
          const { start: i2, end: n2 } = this._breakAttributesRange(t2, true), o2 = i2.parent, r2 = n2.offset - i2.offset, s2 = o2._removeChildren(i2.offset, r2);
          for (const e3 of s2)
            this._removeFromClonedElementsGroup(e3);
          const a2 = this.mergeAttributes(i2);
          return t2.start = a2, t2.end = a2.clone(), new Uo(this.document, s2);
        }
        clear(e2, t2) {
          Zo(e2, this.document);
          const i2 = e2.getWalker({ direction: "backward", ignoreElementEnd: true });
          for (const n2 of i2) {
            const i3 = n2.item;
            let o2;
            if (i3.is("element") && t2.isSimilar(i3))
              o2 = lo._createOn(i3);
            else if (!n2.nextPosition.isAfter(e2.start) && i3.is("$textProxy")) {
              const e3 = i3.getAncestors().find((e4) => e4.is("element") && t2.isSimilar(e4));
              e3 && (o2 = lo._createIn(e3));
            }
            o2 && (o2.end.isAfter(e2.end) && (o2.end = e2.end), o2.start.isBefore(e2.start) && (o2.start = e2.start), this.remove(o2));
          }
        }
        move(e2, t2) {
          let i2;
          if (t2.isAfter(e2.end)) {
            const n2 = (t2 = this._breakAttributes(t2, true)).parent, o2 = n2.childCount;
            e2 = this._breakAttributesRange(e2, true), i2 = this.remove(e2), t2.offset += n2.childCount - o2;
          } else
            i2 = this.remove(e2);
          return this.insert(t2, i2);
        }
        wrap(e2, t2) {
          if (!(t2 instanceof xo))
            throw new c.a("view-writer-wrap-invalid-attribute", this.document);
          if (Zo(e2, this.document), e2.isCollapsed) {
            let n2 = e2.start;
            n2.parent.is("element") && (i2 = n2.parent, !Array.from(i2.getChildren()).some((e3) => !e3.is("uiElement"))) && (n2 = n2.getLastMatchingPosition((e3) => e3.item.is("uiElement"))), n2 = this._wrapPosition(n2, t2);
            const o2 = this.document.selection;
            return o2.isCollapsed && o2.getFirstPosition().isEqual(e2.start) && this.setSelection(n2), new lo(n2);
          }
          return this._wrapRange(e2, t2);
          var i2;
        }
        unwrap(e2, t2) {
          if (!(t2 instanceof xo))
            throw new c.a("view-writer-unwrap-invalid-attribute", this.document);
          if (Zo(e2, this.document), e2.isCollapsed)
            return e2;
          const { start: i2, end: n2 } = this._breakAttributesRange(e2, true), o2 = i2.parent, r2 = this._unwrapChildren(o2, i2.offset, n2.offset, t2), s2 = this.mergeAttributes(r2.start);
          s2.isEqual(r2.start) || r2.end.offset--;
          const a2 = this.mergeAttributes(r2.end);
          return new lo(s2, a2);
        }
        rename(e2, t2) {
          const i2 = new io(this.document, e2, t2.getAttributes());
          return this.insert(co._createAfter(t2), i2), this.move(lo._createIn(t2), co._createAt(i2, 0)), this.remove(lo._createOn(t2)), i2;
        }
        clearClonedElementsGroup(e2) {
          this._cloneGroups.delete(e2);
        }
        createPositionAt(e2, t2) {
          return co._createAt(e2, t2);
        }
        createPositionAfter(e2) {
          return co._createAfter(e2);
        }
        createPositionBefore(e2) {
          return co._createBefore(e2);
        }
        createRange(e2, t2) {
          return new lo(e2, t2);
        }
        createRangeOn(e2) {
          return lo._createOn(e2);
        }
        createRangeIn(e2) {
          return lo._createIn(e2);
        }
        createSelection(e2, t2, i2) {
          return new go(e2, t2, i2);
        }
        _insertNodes(e2, t2, i2) {
          let n2, o2;
          if (n2 = i2 ? qo(e2) : e2.parent.is("$text") ? e2.parent.parent : e2.parent, !n2)
            throw new c.a("view-writer-invalid-position-container", this.document);
          o2 = i2 ? this._breakAttributes(e2, true) : e2.parent.is("$text") ? Go(e2) : e2;
          const r2 = n2._insertChild(o2.offset, t2);
          for (const e3 of t2)
            this._addToClonedElementsGroup(e3);
          const s2 = o2.getShiftedBy(r2), a2 = this.mergeAttributes(o2);
          a2.isEqual(o2) || s2.offset--;
          const l2 = this.mergeAttributes(s2);
          return new lo(a2, l2);
        }
        _wrapChildren(e2, t2, i2, n2) {
          let o2 = t2;
          const r2 = [];
          for (; o2 < i2; ) {
            const t3 = e2.getChild(o2), i3 = t3.is("$text"), s3 = t3.is("attributeElement"), a2 = t3.isAllowedInsideAttributeElement;
            if (s3 && this._wrapAttributeElement(n2, t3))
              r2.push(new co(e2, o2));
            else if (i3 || a2 || s3 && $o(n2, t3)) {
              const i4 = n2._clone();
              t3._remove(), i4._appendChild(t3), e2._insertChild(o2, i4), this._addToClonedElementsGroup(i4), r2.push(new co(e2, o2));
            } else
              s3 && this._wrapChildren(t3, 0, t3.childCount, n2);
            o2++;
          }
          let s2 = 0;
          for (const e3 of r2) {
            if (e3.offset -= s2, e3.offset == t2)
              continue;
            this.mergeAttributes(e3).isEqual(e3) || (s2++, i2--);
          }
          return lo._createFromParentsAndOffsets(e2, t2, e2, i2);
        }
        _unwrapChildren(e2, t2, i2, n2) {
          let o2 = t2;
          const r2 = [];
          for (; o2 < i2; ) {
            const t3 = e2.getChild(o2);
            if (t3.is("attributeElement"))
              if (t3.isSimilar(n2)) {
                const n3 = t3.getChildren(), s3 = t3.childCount;
                t3._remove(), e2._insertChild(o2, n3), this._removeFromClonedElementsGroup(t3), r2.push(new co(e2, o2), new co(e2, o2 + s3)), o2 += s3, i2 += s3 - 1;
              } else
                this._unwrapAttributeElement(n2, t3) ? (r2.push(new co(e2, o2), new co(e2, o2 + 1)), o2++) : (this._unwrapChildren(t3, 0, t3.childCount, n2), o2++);
            else
              o2++;
          }
          let s2 = 0;
          for (const e3 of r2) {
            if (e3.offset -= s2, e3.offset == t2 || e3.offset == i2)
              continue;
            this.mergeAttributes(e3).isEqual(e3) || (s2++, i2--);
          }
          return lo._createFromParentsAndOffsets(e2, t2, e2, i2);
        }
        _wrapRange(e2, t2) {
          const { start: i2, end: n2 } = this._breakAttributesRange(e2, true), o2 = i2.parent, r2 = this._wrapChildren(o2, i2.offset, n2.offset, t2), s2 = this.mergeAttributes(r2.start);
          s2.isEqual(r2.start) || r2.end.offset--;
          const a2 = this.mergeAttributes(r2.end);
          return new lo(s2, a2);
        }
        _wrapPosition(e2, t2) {
          if (t2.isSimilar(e2.parent))
            return Yo(e2.clone());
          e2.parent.is("$text") && (e2 = Go(e2));
          const i2 = this.createAttributeElement();
          i2._priority = Number.POSITIVE_INFINITY, i2.isSimilar = () => false, e2.parent._insertChild(e2.offset, i2);
          const n2 = new lo(e2, e2.getShiftedBy(1));
          this.wrap(n2, t2);
          const o2 = new co(i2.parent, i2.index);
          i2._remove();
          const r2 = o2.nodeBefore, s2 = o2.nodeAfter;
          return r2 instanceof hn && s2 instanceof hn ? Ko(r2, s2) : Yo(o2);
        }
        _wrapAttributeElement(e2, t2) {
          if (!Xo(e2, t2))
            return false;
          if (e2.name !== t2.name || e2.priority !== t2.priority)
            return false;
          for (const i2 of e2.getAttributeKeys())
            if (i2 !== "class" && i2 !== "style" && t2.hasAttribute(i2) && t2.getAttribute(i2) !== e2.getAttribute(i2))
              return false;
          for (const i2 of e2.getStyleNames())
            if (t2.hasStyle(i2) && t2.getStyle(i2) !== e2.getStyle(i2))
              return false;
          for (const i2 of e2.getAttributeKeys())
            i2 !== "class" && i2 !== "style" && (t2.hasAttribute(i2) || this.setAttribute(i2, e2.getAttribute(i2), t2));
          for (const i2 of e2.getStyleNames())
            t2.hasStyle(i2) || this.setStyle(i2, e2.getStyle(i2), t2);
          for (const i2 of e2.getClassNames())
            t2.hasClass(i2) || this.addClass(i2, t2);
          return true;
        }
        _unwrapAttributeElement(e2, t2) {
          if (!Xo(e2, t2))
            return false;
          if (e2.name !== t2.name || e2.priority !== t2.priority)
            return false;
          for (const i2 of e2.getAttributeKeys())
            if (i2 !== "class" && i2 !== "style" && (!t2.hasAttribute(i2) || t2.getAttribute(i2) !== e2.getAttribute(i2)))
              return false;
          if (!t2.hasClass(...e2.getClassNames()))
            return false;
          for (const i2 of e2.getStyleNames())
            if (!t2.hasStyle(i2) || t2.getStyle(i2) !== e2.getStyle(i2))
              return false;
          for (const i2 of e2.getAttributeKeys())
            i2 !== "class" && i2 !== "style" && this.removeAttribute(i2, t2);
          return this.removeClass(Array.from(e2.getClassNames()), t2), this.removeStyle(Array.from(e2.getStyleNames()), t2), true;
        }
        _breakAttributesRange(e2, t2 = false) {
          const i2 = e2.start, n2 = e2.end;
          if (Zo(e2, this.document), e2.isCollapsed) {
            const i3 = this._breakAttributes(e2.start, t2);
            return new lo(i3, i3);
          }
          const o2 = this._breakAttributes(n2, t2), r2 = o2.parent.childCount, s2 = this._breakAttributes(i2, t2);
          return o2.offset += o2.parent.childCount - r2, new lo(s2, o2);
        }
        _breakAttributes(e2, t2 = false) {
          const i2 = e2.offset, n2 = e2.parent;
          if (e2.parent.is("emptyElement"))
            throw new c.a("view-writer-cannot-break-empty-element", this.document);
          if (e2.parent.is("uiElement"))
            throw new c.a("view-writer-cannot-break-ui-element", this.document);
          if (e2.parent.is("rawElement"))
            throw new c.a("view-writer-cannot-break-raw-element", this.document);
          if (!t2 && n2.is("$text") && Jo(n2.parent))
            return e2.clone();
          if (Jo(n2))
            return e2.clone();
          if (n2.is("$text"))
            return this._breakAttributes(Go(e2), t2);
          if (i2 == n2.childCount) {
            const e3 = new co(n2.parent, n2.index + 1);
            return this._breakAttributes(e3, t2);
          }
          if (i2 === 0) {
            const e3 = new co(n2.parent, n2.index);
            return this._breakAttributes(e3, t2);
          }
          {
            const e3 = n2.index + 1, o2 = n2._clone();
            n2.parent._insertChild(e3, o2), this._addToClonedElementsGroup(o2);
            const r2 = n2.childCount - i2, s2 = n2._removeChildren(i2, r2);
            o2._appendChild(s2);
            const a2 = new co(n2.parent, e3);
            return this._breakAttributes(a2, t2);
          }
        }
        _addToClonedElementsGroup(e2) {
          if (!e2.root.is("rootElement"))
            return;
          if (e2.is("element"))
            for (const t3 of e2.getChildren())
              this._addToClonedElementsGroup(t3);
          const t2 = e2.id;
          if (!t2)
            return;
          let i2 = this._cloneGroups.get(t2);
          i2 || (i2 = new Set(), this._cloneGroups.set(t2, i2)), i2.add(e2), e2._clonesGroup = i2;
        }
        _removeFromClonedElementsGroup(e2) {
          if (e2.is("element"))
            for (const t3 of e2.getChildren())
              this._removeFromClonedElementsGroup(t3);
          const t2 = e2.id;
          if (!t2)
            return;
          const i2 = this._cloneGroups.get(t2);
          i2 && i2.delete(e2);
        }
      }
      function qo(e2) {
        let t2 = e2.parent;
        for (; !Jo(t2); ) {
          if (!t2)
            return;
          t2 = t2.parent;
        }
        return t2;
      }
      function $o(e2, t2) {
        return e2.priority < t2.priority || !(e2.priority > t2.priority) && e2.getIdentity() < t2.getIdentity();
      }
      function Yo(e2) {
        const t2 = e2.nodeBefore;
        if (t2 && t2.is("$text"))
          return new co(t2, t2.data.length);
        const i2 = e2.nodeAfter;
        return i2 && i2.is("$text") ? new co(i2, 0) : e2;
      }
      function Go(e2) {
        if (e2.offset == e2.parent.data.length)
          return new co(e2.parent.parent, e2.parent.index + 1);
        if (e2.offset === 0)
          return new co(e2.parent.parent, e2.parent.index);
        const t2 = e2.parent.data.slice(e2.offset);
        return e2.parent._data = e2.parent.data.slice(0, e2.offset), e2.parent.parent._insertChild(e2.parent.index + 1, new hn(e2.root.document, t2)), new co(e2.parent.parent, e2.parent.index + 1);
      }
      function Ko(e2, t2) {
        const i2 = e2.data.length;
        return e2._data += t2.data, t2._remove(), new co(e2, i2);
      }
      const Qo = [hn, xo, io, To, Fo, Vo];
      function Jo(e2) {
        return e2 && (e2.is("containerElement") || e2.is("documentFragment"));
      }
      function Zo(e2, t2) {
        const i2 = qo(e2.start), n2 = qo(e2.end);
        if (!i2 || !n2 || i2 !== n2)
          throw new c.a("view-writer-invalid-range-container", t2);
      }
      function Xo(e2, t2) {
        return e2.id === null && t2.id === null;
      }
      function er(e2) {
        return Object.prototype.toString.call(e2) == "[object Text]";
      }
      const tr = (e2) => e2.createTextNode("\xA0"), ir = (e2) => {
        const t2 = e2.createElement("span");
        return t2.dataset.ckeFiller = true, t2.innerHTML = "\xA0", t2;
      }, nr = (e2) => {
        const t2 = e2.createElement("br");
        return t2.dataset.ckeFiller = true, t2;
      }, or = "\u2060".repeat(7);
      function rr(e2) {
        return er(e2) && e2.data.substr(0, 7) === or;
      }
      function sr(e2) {
        return e2.data.length == 7 && rr(e2);
      }
      function ar(e2) {
        return rr(e2) ? e2.data.slice(7) : e2.data;
      }
      function cr(e2, t2) {
        if (t2.keyCode == No.arrowleft) {
          const e3 = t2.domTarget.ownerDocument.defaultView.getSelection();
          if (e3.rangeCount == 1 && e3.getRangeAt(0).collapsed) {
            const t3 = e3.getRangeAt(0).startContainer, i2 = e3.getRangeAt(0).startOffset;
            rr(t3) && i2 <= 7 && e3.collapse(t3, 0);
          }
        }
      }
      function lr(e2, t2, i2, n2 = false) {
        i2 = i2 || function(e3, t3) {
          return e3 === t3;
        }, Array.isArray(e2) || (e2 = Array.prototype.slice.call(e2)), Array.isArray(t2) || (t2 = Array.prototype.slice.call(t2));
        const o2 = function(e3, t3, i3) {
          const n3 = dr(e3, t3, i3);
          if (n3 === -1)
            return { firstIndex: -1, lastIndexOld: -1, lastIndexNew: -1 };
          const o3 = hr(e3, n3), r2 = hr(t3, n3), s2 = dr(o3, r2, i3), a2 = e3.length - s2, c2 = t3.length - s2;
          return { firstIndex: n3, lastIndexOld: a2, lastIndexNew: c2 };
        }(e2, t2, i2);
        return n2 ? function(e3, t3) {
          const { firstIndex: i3, lastIndexOld: n3, lastIndexNew: o3 } = e3;
          if (i3 === -1)
            return Array(t3).fill("equal");
          let r2 = [];
          i3 > 0 && (r2 = r2.concat(Array(i3).fill("equal")));
          o3 - i3 > 0 && (r2 = r2.concat(Array(o3 - i3).fill("insert")));
          n3 - i3 > 0 && (r2 = r2.concat(Array(n3 - i3).fill("delete")));
          o3 < t3 && (r2 = r2.concat(Array(t3 - o3).fill("equal")));
          return r2;
        }(o2, t2.length) : function(e3, t3) {
          const i3 = [], { firstIndex: n3, lastIndexOld: o3, lastIndexNew: r2 } = t3;
          r2 - n3 > 0 && i3.push({ index: n3, type: "insert", values: e3.slice(n3, r2) });
          o3 - n3 > 0 && i3.push({ index: n3 + (r2 - n3), type: "delete", howMany: o3 - n3 });
          return i3;
        }(t2, o2);
      }
      function dr(e2, t2, i2) {
        for (let n2 = 0; n2 < Math.max(e2.length, t2.length); n2++)
          if (e2[n2] === void 0 || t2[n2] === void 0 || !i2(e2[n2], t2[n2]))
            return n2;
        return -1;
      }
      function hr(e2, t2) {
        return e2.slice(t2).reverse();
      }
      function ur(e2, t2, i2) {
        i2 = i2 || function(e3, t3) {
          return e3 === t3;
        };
        const n2 = e2.length, o2 = t2.length;
        if (n2 > 200 || o2 > 200 || n2 + o2 > 300)
          return ur.fastDiff(e2, t2, i2, true);
        let r2, s2;
        if (o2 < n2) {
          const i3 = e2;
          e2 = t2, t2 = i3, r2 = "delete", s2 = "insert";
        } else
          r2 = "insert", s2 = "delete";
        const a2 = e2.length, c2 = t2.length, l2 = c2 - a2, d2 = {}, h2 = {};
        function u2(n3) {
          const o3 = (h2[n3 - 1] !== void 0 ? h2[n3 - 1] : -1) + 1, l3 = h2[n3 + 1] !== void 0 ? h2[n3 + 1] : -1, u3 = o3 > l3 ? -1 : 1;
          d2[n3 + u3] && (d2[n3] = d2[n3 + u3].slice(0)), d2[n3] || (d2[n3] = []), d2[n3].push(o3 > l3 ? r2 : s2);
          let g3 = Math.max(o3, l3), m3 = g3 - n3;
          for (; m3 < a2 && g3 < c2 && i2(e2[m3], t2[g3]); )
            m3++, g3++, d2[n3].push("equal");
          return g3;
        }
        let g2, m2 = 0;
        do {
          for (g2 = -m2; g2 < l2; g2++)
            h2[g2] = u2(g2);
          for (g2 = l2 + m2; g2 > l2; g2--)
            h2[g2] = u2(g2);
          h2[l2] = u2(l2), m2++;
        } while (h2[l2] !== c2);
        return d2[l2].slice(1);
      }
      function gr(e2, t2, i2) {
        e2.insertBefore(i2, e2.childNodes[t2] || null);
      }
      function mr(e2) {
        const t2 = e2.parentNode;
        t2 && t2.removeChild(e2);
      }
      function fr(e2) {
        if (e2) {
          if (e2.defaultView)
            return e2 instanceof e2.defaultView.Document;
          if (e2.ownerDocument && e2.ownerDocument.defaultView)
            return e2 instanceof e2.ownerDocument.defaultView.Node;
        }
        return false;
      }
      ur.fastDiff = lr;
      class pr {
        constructor(e2, t2) {
          this.domDocuments = new Set(), this.domConverter = e2, this.markedAttributes = new Set(), this.markedChildren = new Set(), this.markedTexts = new Set(), this.selection = t2, this.isFocused = false, this._inlineFiller = null, this._fakeSelectionContainer = null;
        }
        markToSync(e2, t2) {
          if (e2 === "text")
            this.domConverter.mapViewToDom(t2.parent) && this.markedTexts.add(t2);
          else {
            if (!this.domConverter.mapViewToDom(t2))
              return;
            if (e2 === "attributes")
              this.markedAttributes.add(t2);
            else {
              if (e2 !== "children")
                throw new c.a("view-renderer-unknown-type", this);
              this.markedChildren.add(t2);
            }
          }
        }
        render() {
          let e2;
          for (const e3 of this.markedChildren)
            this._updateChildrenMappings(e3);
          this._inlineFiller && !this._isSelectionInInlineFiller() && this._removeInlineFiller(), this._inlineFiller ? e2 = this._getInlineFillerPosition() : this._needsInlineFillerAtSelection() && (e2 = this.selection.getFirstPosition(), this.markedChildren.add(e2.parent));
          for (const e3 of this.markedAttributes)
            this._updateAttrs(e3);
          for (const t2 of this.markedChildren)
            this._updateChildren(t2, { inlineFillerPosition: e2 });
          for (const t2 of this.markedTexts)
            !this.markedChildren.has(t2.parent) && this.domConverter.mapViewToDom(t2.parent) && this._updateText(t2, { inlineFillerPosition: e2 });
          if (e2) {
            const t2 = this.domConverter.viewPositionToDom(e2), i2 = t2.parent.ownerDocument;
            rr(t2.parent) ? this._inlineFiller = t2.parent : this._inlineFiller = br(i2, t2.parent, t2.offset);
          } else
            this._inlineFiller = null;
          this._updateFocus(), this._updateSelection(), this.markedTexts.clear(), this.markedAttributes.clear(), this.markedChildren.clear();
        }
        _updateChildrenMappings(e2) {
          const t2 = this.domConverter.mapViewToDom(e2);
          if (!t2)
            return;
          const i2 = Array.from(this.domConverter.mapViewToDom(e2).childNodes), n2 = Array.from(this.domConverter.viewChildrenToDom(e2, t2.ownerDocument, { withChildren: false })), o2 = this._diffNodeLists(i2, n2), r2 = this._findReplaceActions(o2, i2, n2);
          if (r2.indexOf("replace") !== -1) {
            const t3 = { equal: 0, insert: 0, delete: 0 };
            for (const o3 of r2)
              if (o3 === "replace") {
                const o4 = t3.equal + t3.insert, r3 = t3.equal + t3.delete, s2 = e2.getChild(o4);
                !s2 || s2.is("uiElement") || s2.is("rawElement") || this._updateElementMappings(s2, i2[r3]), mr(n2[o4]), t3.equal++;
              } else
                t3[o3]++;
          }
        }
        _updateElementMappings(e2, t2) {
          this.domConverter.unbindDomElement(t2), this.domConverter.bindElements(t2, e2), this.markedChildren.add(e2), this.markedAttributes.add(e2);
        }
        _getInlineFillerPosition() {
          const e2 = this.selection.getFirstPosition();
          return e2.parent.is("$text") ? co._createBefore(this.selection.getFirstPosition().parent) : e2;
        }
        _isSelectionInInlineFiller() {
          if (this.selection.rangeCount != 1 || !this.selection.isCollapsed)
            return false;
          const e2 = this.selection.getFirstPosition(), t2 = this.domConverter.viewPositionToDom(e2);
          return !!(t2 && er(t2.parent) && rr(t2.parent));
        }
        _removeInlineFiller() {
          const e2 = this._inlineFiller;
          if (!rr(e2))
            throw new c.a("view-renderer-filler-was-lost", this);
          sr(e2) ? e2.parentNode.removeChild(e2) : e2.data = e2.data.substr(7), this._inlineFiller = null;
        }
        _needsInlineFillerAtSelection() {
          if (this.selection.rangeCount != 1 || !this.selection.isCollapsed)
            return false;
          const e2 = this.selection.getFirstPosition(), t2 = e2.parent, i2 = e2.offset;
          if (!this.domConverter.mapViewToDom(t2.root))
            return false;
          if (!t2.is("element"))
            return false;
          if (!function(e3) {
            if (e3.getAttribute("contenteditable") == "false")
              return false;
            const t3 = e3.findAncestor((e4) => e4.hasAttribute("contenteditable"));
            return !t3 || t3.getAttribute("contenteditable") == "true";
          }(t2))
            return false;
          if (i2 === t2.getFillerOffset())
            return false;
          const n2 = e2.nodeBefore, o2 = e2.nodeAfter;
          return !(n2 instanceof hn || o2 instanceof hn);
        }
        _updateText(e2, t2) {
          const i2 = this.domConverter.findCorrespondingDomText(e2), n2 = this.domConverter.viewToDom(e2, i2.ownerDocument), o2 = i2.data;
          let r2 = n2.data;
          const s2 = t2.inlineFillerPosition;
          if (s2 && s2.parent == e2.parent && s2.offset == e2.index && (r2 = or + r2), o2 != r2) {
            const e3 = lr(o2, r2);
            for (const t3 of e3)
              t3.type === "insert" ? i2.insertData(t3.index, t3.values.join("")) : i2.deleteData(t3.index, t3.howMany);
          }
        }
        _updateAttrs(e2) {
          const t2 = this.domConverter.mapViewToDom(e2);
          if (!t2)
            return;
          const i2 = Array.from(t2.attributes).map((e3) => e3.name), n2 = e2.getAttributeKeys();
          for (const i3 of n2)
            t2.setAttribute(i3, e2.getAttribute(i3));
          for (const n3 of i2)
            e2.hasAttribute(n3) || t2.removeAttribute(n3);
        }
        _updateChildren(e2, t2) {
          const i2 = this.domConverter.mapViewToDom(e2);
          if (!i2)
            return;
          const n2 = t2.inlineFillerPosition, o2 = this.domConverter.mapViewToDom(e2).childNodes, r2 = Array.from(this.domConverter.viewChildrenToDom(e2, i2.ownerDocument, { bind: true, inlineFillerPosition: n2 }));
          n2 && n2.parent === e2 && br(i2.ownerDocument, r2, n2.offset);
          const s2 = this._diffNodeLists(o2, r2);
          let a2 = 0;
          const c2 = new Set();
          for (const e3 of s2)
            e3 === "delete" ? (c2.add(o2[a2]), mr(o2[a2])) : e3 === "equal" && a2++;
          a2 = 0;
          for (const e3 of s2)
            e3 === "insert" ? (gr(i2, a2, r2[a2]), a2++) : e3 === "equal" && (this._markDescendantTextToSync(this.domConverter.domToView(r2[a2])), a2++);
          for (const e3 of c2)
            e3.parentNode || this.domConverter.unbindDomElement(e3);
        }
        _diffNodeLists(e2, t2) {
          return ur(e2 = function(e3, t3) {
            const i2 = Array.from(e3);
            if (i2.length == 0 || !t3)
              return i2;
            i2[i2.length - 1] == t3 && i2.pop();
            return i2;
          }(e2, this._fakeSelectionContainer), t2, kr.bind(null, this.domConverter));
        }
        _findReplaceActions(e2, t2, i2) {
          if (e2.indexOf("insert") === -1 || e2.indexOf("delete") === -1)
            return e2;
          let n2 = [], o2 = [], r2 = [];
          const s2 = { equal: 0, insert: 0, delete: 0 };
          for (const a2 of e2)
            a2 === "insert" ? r2.push(i2[s2.equal + s2.insert]) : a2 === "delete" ? o2.push(t2[s2.equal + s2.delete]) : (n2 = n2.concat(ur(o2, r2, wr).map((e3) => e3 === "equal" ? "replace" : e3)), n2.push("equal"), o2 = [], r2 = []), s2[a2]++;
          return n2.concat(ur(o2, r2, wr).map((e3) => e3 === "equal" ? "replace" : e3));
        }
        _markDescendantTextToSync(e2) {
          if (e2) {
            if (e2.is("$text"))
              this.markedTexts.add(e2);
            else if (e2.is("element"))
              for (const t2 of e2.getChildren())
                this._markDescendantTextToSync(t2);
          }
        }
        _updateSelection() {
          if (this.selection.rangeCount === 0)
            return this._removeDomSelection(), void this._removeFakeSelection();
          const e2 = this.domConverter.mapViewToDom(this.selection.editableElement);
          this.isFocused && e2 && (this.selection.isFake ? this._updateFakeSelection(e2) : (this._removeFakeSelection(), this._updateDomSelection(e2)));
        }
        _updateFakeSelection(e2) {
          const t2 = e2.ownerDocument;
          this._fakeSelectionContainer || (this._fakeSelectionContainer = function(e3) {
            const t3 = e3.createElement("div");
            return t3.className = "ck-fake-selection-container", Object.assign(t3.style, { position: "fixed", top: 0, left: "-9999px", width: "42px" }), t3.textContent = "\xA0", t3;
          }(t2));
          const i2 = this._fakeSelectionContainer;
          if (this.domConverter.bindFakeSelection(i2, this.selection), !this._fakeSelectionNeedsUpdate(e2))
            return;
          i2.parentElement && i2.parentElement == e2 || e2.appendChild(i2), i2.textContent = this.selection.fakeSelectionLabel || "\xA0";
          const n2 = t2.getSelection(), o2 = t2.createRange();
          n2.removeAllRanges(), o2.selectNodeContents(i2), n2.addRange(o2);
        }
        _updateDomSelection(e2) {
          const t2 = e2.ownerDocument.defaultView.getSelection();
          if (!this._domSelectionNeedsUpdate(t2))
            return;
          const i2 = this.domConverter.viewPositionToDom(this.selection.anchor), n2 = this.domConverter.viewPositionToDom(this.selection.focus);
          t2.collapse(i2.parent, i2.offset), t2.extend(n2.parent, n2.offset), So.isGecko && function(e3, t3) {
            const i3 = e3.parent;
            if (i3.nodeType != Node.ELEMENT_NODE || e3.offset != i3.childNodes.length - 1)
              return;
            const n3 = i3.childNodes[e3.offset];
            n3 && n3.tagName == "BR" && t3.addRange(t3.getRangeAt(0));
          }(n2, t2);
        }
        _domSelectionNeedsUpdate(e2) {
          if (!this.domConverter.isDomSelectionCorrect(e2))
            return true;
          const t2 = e2 && this.domConverter.domSelectionToView(e2);
          return (!t2 || !this.selection.isEqual(t2)) && !(!this.selection.isCollapsed && this.selection.isSimilar(t2));
        }
        _fakeSelectionNeedsUpdate(e2) {
          const t2 = this._fakeSelectionContainer, i2 = e2.ownerDocument.getSelection();
          return !t2 || t2.parentElement !== e2 || (i2.anchorNode !== t2 && !t2.contains(i2.anchorNode) || t2.textContent !== this.selection.fakeSelectionLabel);
        }
        _removeDomSelection() {
          for (const e2 of this.domDocuments) {
            if (e2.getSelection().rangeCount) {
              const t2 = e2.activeElement, i2 = this.domConverter.mapDomToView(t2);
              t2 && i2 && e2.getSelection().removeAllRanges();
            }
          }
        }
        _removeFakeSelection() {
          const e2 = this._fakeSelectionContainer;
          e2 && e2.remove();
        }
        _updateFocus() {
          if (this.isFocused) {
            const e2 = this.selection.editableElement;
            e2 && this.domConverter.focus(e2);
          }
        }
      }
      function br(e2, t2, i2) {
        const n2 = t2 instanceof Array ? t2 : t2.childNodes, o2 = n2[i2];
        if (er(o2))
          return o2.data = or + o2.data, o2;
        {
          const o3 = e2.createTextNode(or);
          return Array.isArray(t2) ? n2.splice(i2, 0, o3) : gr(t2, i2, o3), o3;
        }
      }
      function wr(e2, t2) {
        return fr(e2) && fr(t2) && !er(e2) && !er(t2) && e2.nodeType !== Node.COMMENT_NODE && t2.nodeType !== Node.COMMENT_NODE && e2.tagName.toLowerCase() === t2.tagName.toLowerCase();
      }
      function kr(e2, t2, i2) {
        return t2 === i2 || (er(t2) && er(i2) ? t2.data === i2.data : !(!e2.isBlockFiller(t2) || !e2.isBlockFiller(i2)));
      }
      Ke(pr, Ue);
      var _r = { window, document };
      function vr(e2) {
        let t2 = 0;
        for (; e2.previousSibling; )
          e2 = e2.previousSibling, t2++;
        return t2;
      }
      function yr(e2) {
        const t2 = [];
        for (; e2 && e2.nodeType != Node.DOCUMENT_NODE; )
          t2.unshift(e2), e2 = e2.parentNode;
        return t2;
      }
      const xr = nr(document), Ar = tr(document), Cr = ir(document);
      class Tr {
        constructor(e2, t2 = {}) {
          this.document = e2, this.blockFillerMode = t2.blockFillerMode || "br", this.preElements = ["pre"], this.blockElements = ["address", "article", "aside", "blockquote", "caption", "center", "dd", "details", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "legend", "li", "main", "menu", "nav", "ol", "p", "pre", "section", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "tr", "ul"], this.inlineObjectElements = ["object", "iframe", "input", "button", "textarea", "select", "option", "video", "embed", "audio", "img", "canvas"], this._domToViewMapping = new WeakMap(), this._viewToDomMapping = new WeakMap(), this._fakeSelectionMapping = new WeakMap(), this._rawContentElementMatcher = new mn(), this._encounteredRawContentDomNodes = new WeakSet();
        }
        bindFakeSelection(e2, t2) {
          this._fakeSelectionMapping.set(e2, new go(t2));
        }
        fakeSelectionToView(e2) {
          return this._fakeSelectionMapping.get(e2);
        }
        bindElements(e2, t2) {
          this._domToViewMapping.set(e2, t2), this._viewToDomMapping.set(t2, e2);
        }
        unbindDomElement(e2) {
          const t2 = this._domToViewMapping.get(e2);
          if (t2) {
            this._domToViewMapping.delete(e2), this._viewToDomMapping.delete(t2);
            for (const t3 of e2.childNodes)
              this.unbindDomElement(t3);
          }
        }
        bindDocumentFragments(e2, t2) {
          this._domToViewMapping.set(e2, t2), this._viewToDomMapping.set(t2, e2);
        }
        viewToDom(e2, t2, i2 = {}) {
          if (e2.is("$text")) {
            const i3 = this._processDataFromViewText(e2);
            return t2.createTextNode(i3);
          }
          {
            if (this.mapViewToDom(e2))
              return this.mapViewToDom(e2);
            let n2;
            if (e2.is("documentFragment"))
              n2 = t2.createDocumentFragment(), i2.bind && this.bindDocumentFragments(n2, e2);
            else {
              if (e2.is("uiElement"))
                return n2 = e2.name === "$comment" ? t2.createComment(e2.getCustomProperty("$rawContent")) : e2.render(t2), i2.bind && this.bindElements(n2, e2), n2;
              n2 = e2.hasAttribute("xmlns") ? t2.createElementNS(e2.getAttribute("xmlns"), e2.name) : t2.createElement(e2.name), e2.is("rawElement") && e2.render(n2), i2.bind && this.bindElements(n2, e2);
              for (const t3 of e2.getAttributeKeys())
                n2.setAttribute(t3, e2.getAttribute(t3));
            }
            if (i2.withChildren !== false)
              for (const o2 of this.viewChildrenToDom(e2, t2, i2))
                n2.appendChild(o2);
            return n2;
          }
        }
        *viewChildrenToDom(e2, t2, i2 = {}) {
          const n2 = e2.getFillerOffset && e2.getFillerOffset();
          let o2 = 0;
          for (const r2 of e2.getChildren())
            n2 === o2 && (yield this._getBlockFiller(t2)), yield this.viewToDom(r2, t2, i2), o2++;
          n2 === o2 && (yield this._getBlockFiller(t2));
        }
        viewRangeToDom(e2) {
          const t2 = this.viewPositionToDom(e2.start), i2 = this.viewPositionToDom(e2.end), n2 = document.createRange();
          return n2.setStart(t2.parent, t2.offset), n2.setEnd(i2.parent, i2.offset), n2;
        }
        viewPositionToDom(e2) {
          const t2 = e2.parent;
          if (t2.is("$text")) {
            const i2 = this.findCorrespondingDomText(t2);
            if (!i2)
              return null;
            let n2 = e2.offset;
            return rr(i2) && (n2 += 7), { parent: i2, offset: n2 };
          }
          {
            let i2, n2, o2;
            if (e2.offset === 0) {
              if (i2 = this.mapViewToDom(t2), !i2)
                return null;
              o2 = i2.childNodes[0];
            } else {
              const t3 = e2.nodeBefore;
              if (n2 = t3.is("$text") ? this.findCorrespondingDomText(t3) : this.mapViewToDom(e2.nodeBefore), !n2)
                return null;
              i2 = n2.parentNode, o2 = n2.nextSibling;
            }
            if (er(o2) && rr(o2))
              return { parent: o2, offset: 7 };
            return { parent: i2, offset: n2 ? vr(n2) + 1 : 0 };
          }
        }
        domToView(e2, t2 = {}) {
          if (this.isBlockFiller(e2))
            return null;
          const i2 = this.getHostViewElement(e2);
          if (i2)
            return i2;
          if (this.isComment(e2) && t2.skipComments)
            return null;
          if (er(e2)) {
            if (sr(e2))
              return null;
            {
              const t3 = this._processDataFromDomText(e2);
              return t3 === "" ? null : new hn(this.document, t3);
            }
          }
          {
            if (this.mapDomToView(e2))
              return this.mapDomToView(e2);
            let i3;
            if (this.isDocumentFragment(e2))
              i3 = new Uo(this.document), t2.bind && this.bindDocumentFragments(e2, i3);
            else {
              i3 = this._createViewElement(e2, t2), t2.bind && this.bindElements(e2, i3);
              const n2 = e2.attributes;
              if (n2)
                for (let e3 = n2.length - 1; e3 >= 0; e3--)
                  i3._setAttribute(n2[e3].name, n2[e3].value);
              if (this._isViewElementWithRawContent(i3, t2) || this.isComment(e2)) {
                const t3 = this.isComment(e2) ? e2.data : e2.innerHTML;
                return i3._setCustomProperty("$rawContent", t3), this._encounteredRawContentDomNodes.add(e2), i3;
              }
            }
            if (t2.withChildren !== false)
              for (const n2 of this.domChildrenToView(e2, t2))
                i3._appendChild(n2);
            return i3;
          }
        }
        *domChildrenToView(e2, t2 = {}) {
          for (let i2 = 0; i2 < e2.childNodes.length; i2++) {
            const n2 = e2.childNodes[i2], o2 = this.domToView(n2, t2);
            o2 !== null && (yield o2);
          }
        }
        domSelectionToView(e2) {
          if (e2.rangeCount === 1) {
            let t3 = e2.getRangeAt(0).startContainer;
            er(t3) && (t3 = t3.parentNode);
            const i3 = this.fakeSelectionToView(t3);
            if (i3)
              return i3;
          }
          const t2 = this.isDomSelectionBackward(e2), i2 = [];
          for (let t3 = 0; t3 < e2.rangeCount; t3++) {
            const n2 = e2.getRangeAt(t3), o2 = this.domRangeToView(n2);
            o2 && i2.push(o2);
          }
          return new go(i2, { backward: t2 });
        }
        domRangeToView(e2) {
          const t2 = this.domPositionToView(e2.startContainer, e2.startOffset), i2 = this.domPositionToView(e2.endContainer, e2.endOffset);
          return t2 && i2 ? new lo(t2, i2) : null;
        }
        domPositionToView(e2, t2) {
          if (this.isBlockFiller(e2))
            return this.domPositionToView(e2.parentNode, vr(e2));
          const i2 = this.mapDomToView(e2);
          if (i2 && (i2.is("uiElement") || i2.is("rawElement")))
            return co._createBefore(i2);
          if (er(e2)) {
            if (sr(e2))
              return this.domPositionToView(e2.parentNode, vr(e2));
            const i3 = this.findCorrespondingViewText(e2);
            let n2 = t2;
            return i3 ? (rr(e2) && (n2 -= 7, n2 = n2 < 0 ? 0 : n2), new co(i3, n2)) : null;
          }
          if (t2 === 0) {
            const t3 = this.mapDomToView(e2);
            if (t3)
              return new co(t3, 0);
          } else {
            const i3 = e2.childNodes[t2 - 1], n2 = er(i3) ? this.findCorrespondingViewText(i3) : this.mapDomToView(i3);
            if (n2 && n2.parent)
              return new co(n2.parent, n2.index + 1);
          }
          return null;
        }
        mapDomToView(e2) {
          return this.getHostViewElement(e2) || this._domToViewMapping.get(e2);
        }
        findCorrespondingViewText(e2) {
          if (sr(e2))
            return null;
          const t2 = this.getHostViewElement(e2);
          if (t2)
            return t2;
          const i2 = e2.previousSibling;
          if (i2) {
            if (!this.isElement(i2))
              return null;
            const e3 = this.mapDomToView(i2);
            if (e3) {
              return e3.nextSibling instanceof hn ? e3.nextSibling : null;
            }
          } else {
            const t3 = this.mapDomToView(e2.parentNode);
            if (t3) {
              const e3 = t3.getChild(0);
              return e3 instanceof hn ? e3 : null;
            }
          }
          return null;
        }
        mapViewToDom(e2) {
          return this._viewToDomMapping.get(e2);
        }
        findCorrespondingDomText(e2) {
          const t2 = e2.previousSibling;
          return t2 && this.mapViewToDom(t2) ? this.mapViewToDom(t2).nextSibling : !t2 && e2.parent && this.mapViewToDom(e2.parent) ? this.mapViewToDom(e2.parent).childNodes[0] : null;
        }
        focus(e2) {
          const t2 = this.mapViewToDom(e2);
          if (t2 && t2.ownerDocument.activeElement !== t2) {
            const { scrollX: e3, scrollY: i2 } = _r.window, n2 = [];
            Er(t2, (e4) => {
              const { scrollLeft: t3, scrollTop: i3 } = e4;
              n2.push([t3, i3]);
            }), t2.focus(), Er(t2, (e4) => {
              const [t3, i3] = n2.shift();
              e4.scrollLeft = t3, e4.scrollTop = i3;
            }), _r.window.scrollTo(e3, i2);
          }
        }
        isElement(e2) {
          return e2 && e2.nodeType == Node.ELEMENT_NODE;
        }
        isDocumentFragment(e2) {
          return e2 && e2.nodeType == Node.DOCUMENT_FRAGMENT_NODE;
        }
        isComment(e2) {
          return e2 && e2.nodeType == Node.COMMENT_NODE;
        }
        isBlockFiller(e2) {
          return this.blockFillerMode == "br" ? e2.isEqualNode(xr) : !(e2.tagName !== "BR" || !Ir(e2, this.blockElements) || e2.parentNode.childNodes.length !== 1) || (e2.isEqualNode(Cr) || function(e3, t2) {
            return e3.isEqualNode(Ar) && Ir(e3, t2) && e3.parentNode.childNodes.length === 1;
          }(e2, this.blockElements));
        }
        isDomSelectionBackward(e2) {
          if (e2.isCollapsed)
            return false;
          const t2 = document.createRange();
          t2.setStart(e2.anchorNode, e2.anchorOffset), t2.setEnd(e2.focusNode, e2.focusOffset);
          const i2 = t2.collapsed;
          return t2.detach(), i2;
        }
        getHostViewElement(e2) {
          const t2 = yr(e2);
          for (t2.pop(); t2.length; ) {
            const e3 = t2.pop(), i2 = this._domToViewMapping.get(e3);
            if (i2 && (i2.is("uiElement") || i2.is("rawElement")))
              return i2;
          }
          return null;
        }
        isDomSelectionCorrect(e2) {
          return this._isDomSelectionPositionCorrect(e2.anchorNode, e2.anchorOffset) && this._isDomSelectionPositionCorrect(e2.focusNode, e2.focusOffset);
        }
        registerRawContentMatcher(e2) {
          this._rawContentElementMatcher.add(e2);
        }
        _getBlockFiller(e2) {
          switch (this.blockFillerMode) {
            case "nbsp":
              return tr(e2);
            case "markedNbsp":
              return ir(e2);
            case "br":
              return nr(e2);
          }
        }
        _isDomSelectionPositionCorrect(e2, t2) {
          if (er(e2) && rr(e2) && t2 < 7)
            return false;
          if (this.isElement(e2) && rr(e2.childNodes[t2]))
            return false;
          const i2 = this.mapDomToView(e2);
          return !i2 || !i2.is("uiElement") && !i2.is("rawElement");
        }
        _processDataFromViewText(e2) {
          let t2 = e2.data;
          if (e2.getAncestors().some((e3) => this.preElements.includes(e3.name)))
            return t2;
          if (t2.charAt(0) == " ") {
            const i2 = this._getTouchingInlineViewNode(e2, false);
            !(i2 && i2.is("$textProxy") && this._nodeEndsWithSpace(i2)) && i2 || (t2 = "\xA0" + t2.substr(1));
          }
          if (t2.charAt(t2.length - 1) == " ") {
            const i2 = this._getTouchingInlineViewNode(e2, true), n2 = i2 && i2.is("$textProxy") && i2.data.charAt(0) == " ";
            t2.charAt(t2.length - 2) != " " && i2 && !n2 || (t2 = t2.substr(0, t2.length - 1) + "\xA0");
          }
          return t2.replace(/ {2}/g, " \xA0");
        }
        _nodeEndsWithSpace(e2) {
          if (e2.getAncestors().some((e3) => this.preElements.includes(e3.name)))
            return false;
          const t2 = this._processDataFromViewText(e2);
          return t2.charAt(t2.length - 1) == " ";
        }
        _processDataFromDomText(e2) {
          let t2 = e2.data;
          if (function(e3, t3) {
            return yr(e3).some((e4) => e4.tagName && t3.includes(e4.tagName.toLowerCase()));
          }(e2, this.preElements))
            return ar(e2);
          t2 = t2.replace(/[ \n\t\r]{1,}/g, " ");
          const i2 = this._getTouchingInlineDomNode(e2, false), n2 = this._getTouchingInlineDomNode(e2, true), o2 = this._checkShouldLeftTrimDomText(e2, i2), r2 = this._checkShouldRightTrimDomText(e2, n2);
          o2 && (t2 = t2.replace(/^ /, "")), r2 && (t2 = t2.replace(/ $/, "")), t2 = ar(new Text(t2)), t2 = t2.replace(/ \u00A0/g, "  ");
          const s2 = n2 && this.isElement(n2) && n2.tagName != "BR", a2 = n2 && er(n2) && n2.data.charAt(0) == " ";
          return (/( |\u00A0)\u00A0$/.test(t2) || !n2 || s2 || a2) && (t2 = t2.replace(/\u00A0$/, " ")), (o2 || i2 && this.isElement(i2) && i2.tagName != "BR") && (t2 = t2.replace(/^\u00A0/, " ")), t2;
        }
        _checkShouldLeftTrimDomText(e2, t2) {
          return !t2 || (this.isElement(t2) ? t2.tagName === "BR" : !this._encounteredRawContentDomNodes.has(e2.previousSibling) && /[^\S\u00A0]/.test(t2.data.charAt(t2.data.length - 1)));
        }
        _checkShouldRightTrimDomText(e2, t2) {
          return !t2 && !rr(e2);
        }
        _getTouchingInlineViewNode(e2, t2) {
          const i2 = new ao({ startPosition: t2 ? co._createAfter(e2) : co._createBefore(e2), direction: t2 ? "forward" : "backward" });
          for (const e3 of i2) {
            if (e3.item.is("element") && this.inlineObjectElements.includes(e3.item.name))
              return e3.item;
            if (e3.item.is("containerElement"))
              return null;
            if (e3.item.is("element", "br"))
              return null;
            if (e3.item.is("$textProxy"))
              return e3.item;
          }
          return null;
        }
        _getTouchingInlineDomNode(e2, t2) {
          if (!e2.parentNode)
            return null;
          const i2 = t2 ? "firstChild" : "lastChild", n2 = t2 ? "nextSibling" : "previousSibling";
          let o2 = true;
          do {
            if (!o2 && e2[i2] ? e2 = e2[i2] : e2[n2] ? (e2 = e2[n2], o2 = false) : (e2 = e2.parentNode, o2 = true), !e2 || this._isBlockElement(e2))
              return null;
          } while (!er(e2) && e2.tagName != "BR" && !this._isInlineObjectElement(e2));
          return e2;
        }
        _isBlockElement(e2) {
          return this.isElement(e2) && this.blockElements.includes(e2.tagName.toLowerCase());
        }
        _isInlineObjectElement(e2) {
          return this.isElement(e2) && this.inlineObjectElements.includes(e2.tagName.toLowerCase());
        }
        _createViewElement(e2, t2) {
          if (this.isComment(e2))
            return new Vo(this.document, "$comment");
          const i2 = t2.keepOriginalCase ? e2.tagName : e2.tagName.toLowerCase();
          return new eo(this.document, i2);
        }
        _isViewElementWithRawContent(e2, t2) {
          return t2.withChildren !== false && this._rawContentElementMatcher.match(e2);
        }
      }
      function Er(e2, t2) {
        for (; e2 && e2 != _r.document; )
          t2(e2), e2 = e2.parentNode;
      }
      function Ir(e2, t2) {
        const i2 = e2.parentNode;
        return i2 && i2.tagName && t2.includes(i2.tagName.toLowerCase());
      }
      function Sr(e2) {
        const t2 = Object.prototype.toString.apply(e2);
        return t2 == "[object Window]" || t2 == "[object global]";
      }
      var Pr = De({}, h, { listenTo(e2, ...t2) {
        if (fr(e2) || Sr(e2)) {
          const i2 = this._getProxyEmitter(e2) || new Mr(e2);
          i2.attach(...t2), e2 = i2;
        }
        h.listenTo.call(this, e2, ...t2);
      }, stopListening(e2, t2, i2) {
        if (fr(e2) || Sr(e2)) {
          const t3 = this._getProxyEmitter(e2);
          if (!t3)
            return;
          e2 = t3;
        }
        h.stopListening.call(this, e2, t2, i2), e2 instanceof Mr && e2.detach(t2);
      }, _getProxyEmitter(e2) {
        return t2 = this, i2 = Nr(e2), t2[l] && t2[l][i2] ? t2[l][i2].emitter : null;
        var t2, i2;
      } });
      class Mr {
        constructor(e2) {
          u(this, Nr(e2)), this._domNode = e2;
        }
      }
      function Nr(e2) {
        return e2["data-ck-expando"] || (e2["data-ck-expando"] = s());
      }
      De(Mr.prototype, h, { attach(e2, t2, i2 = {}) {
        if (this._domListeners && this._domListeners[e2])
          return;
        const n2 = { capture: !!i2.useCapture, passive: !!i2.usePassive }, o2 = this._createDomListener(e2, n2);
        this._domNode.addEventListener(e2, o2, n2), this._domListeners || (this._domListeners = {}), this._domListeners[e2] = o2;
      }, detach(e2) {
        let t2;
        !this._domListeners[e2] || (t2 = this._events[e2]) && t2.callbacks.length || this._domListeners[e2].removeListener();
      }, _createDomListener(e2, t2) {
        const i2 = (t3) => {
          this.fire(e2, t3);
        };
        return i2.removeListener = () => {
          this._domNode.removeEventListener(e2, i2, t2), delete this._domListeners[e2];
        }, i2;
      } });
      class Rr {
        constructor(e2) {
          this.view = e2, this.document = e2.document, this.isEnabled = false;
        }
        enable() {
          this.isEnabled = true;
        }
        disable() {
          this.isEnabled = false;
        }
        destroy() {
          this.disable(), this.stopListening();
        }
        checkShouldIgnoreEventFromTarget(e2) {
          return e2 && e2.nodeType === 3 && (e2 = e2.parentNode), !(!e2 || e2.nodeType !== 1) && e2.matches("[data-cke-ignore-events], [data-cke-ignore-events] *");
        }
      }
      Ke(Rr, Pr);
      var Or = function(e2) {
        return this.__data__.set(e2, "__lodash_hash_undefined__"), this;
      };
      var zr = function(e2) {
        return this.__data__.has(e2);
      };
      function Dr(e2) {
        var t2 = -1, i2 = e2 == null ? 0 : e2.length;
        for (this.__data__ = new Ft(); ++t2 < i2; )
          this.add(e2[t2]);
      }
      Dr.prototype.add = Dr.prototype.push = Or, Dr.prototype.has = zr;
      var Lr = Dr;
      var Vr = function(e2, t2) {
        for (var i2 = -1, n2 = e2 == null ? 0 : e2.length; ++i2 < n2; )
          if (t2(e2[i2], i2, e2))
            return true;
        return false;
      };
      var jr = function(e2, t2) {
        return e2.has(t2);
      };
      var Br = function(e2, t2, i2, n2, o2, r2) {
        var s2 = 1 & i2, a2 = e2.length, c2 = t2.length;
        if (a2 != c2 && !(s2 && c2 > a2))
          return false;
        var l2 = r2.get(e2), d2 = r2.get(t2);
        if (l2 && d2)
          return l2 == t2 && d2 == e2;
        var h2 = -1, u2 = true, g2 = 2 & i2 ? new Lr() : void 0;
        for (r2.set(e2, t2), r2.set(t2, e2); ++h2 < a2; ) {
          var m2 = e2[h2], f2 = t2[h2];
          if (n2)
            var p2 = s2 ? n2(f2, m2, h2, t2, e2, r2) : n2(m2, f2, h2, e2, t2, r2);
          if (p2 !== void 0) {
            if (p2)
              continue;
            u2 = false;
            break;
          }
          if (g2) {
            if (!Vr(t2, function(e3, t3) {
              if (!jr(g2, t3) && (m2 === e3 || o2(m2, e3, i2, n2, r2)))
                return g2.push(t3);
            })) {
              u2 = false;
              break;
            }
          } else if (m2 !== f2 && !o2(m2, f2, i2, n2, r2)) {
            u2 = false;
            break;
          }
        }
        return r2.delete(e2), r2.delete(t2), u2;
      };
      var Fr = function(e2) {
        var t2 = -1, i2 = Array(e2.size);
        return e2.forEach(function(e3, n2) {
          i2[++t2] = [n2, e3];
        }), i2;
      };
      var Hr = function(e2) {
        var t2 = -1, i2 = Array(e2.size);
        return e2.forEach(function(e3) {
          i2[++t2] = e3;
        }), i2;
      }, Ur = _ ? _.prototype : void 0, Wr = Ur ? Ur.valueOf : void 0;
      var qr = function(e2, t2, i2, n2, o2, r2, s2) {
        switch (i2) {
          case "[object DataView]":
            if (e2.byteLength != t2.byteLength || e2.byteOffset != t2.byteOffset)
              return false;
            e2 = e2.buffer, t2 = t2.buffer;
          case "[object ArrayBuffer]":
            return !(e2.byteLength != t2.byteLength || !r2(new Ci(e2), new Ci(t2)));
          case "[object Boolean]":
          case "[object Date]":
          case "[object Number]":
            return G(+e2, +t2);
          case "[object Error]":
            return e2.name == t2.name && e2.message == t2.message;
          case "[object RegExp]":
          case "[object String]":
            return e2 == t2 + "";
          case "[object Map]":
            var a2 = Fr;
          case "[object Set]":
            var c2 = 1 & n2;
            if (a2 || (a2 = Hr), e2.size != t2.size && !c2)
              return false;
            var l2 = s2.get(e2);
            if (l2)
              return l2 == t2;
            n2 |= 2, s2.set(e2, t2);
            var d2 = Br(a2(e2), a2(t2), n2, o2, r2, s2);
            return s2.delete(e2), d2;
          case "[object Symbol]":
            if (Wr)
              return Wr.call(e2) == Wr.call(t2);
        }
        return false;
      }, $r = Object.prototype.hasOwnProperty;
      var Yr = function(e2, t2, i2, n2, o2, r2) {
        var s2 = 1 & i2, a2 = di(e2), c2 = a2.length;
        if (c2 != di(t2).length && !s2)
          return false;
        for (var l2 = c2; l2--; ) {
          var d2 = a2[l2];
          if (!(s2 ? d2 in t2 : $r.call(t2, d2)))
            return false;
        }
        var h2 = r2.get(e2), u2 = r2.get(t2);
        if (h2 && u2)
          return h2 == t2 && u2 == e2;
        var g2 = true;
        r2.set(e2, t2), r2.set(t2, e2);
        for (var m2 = s2; ++l2 < c2; ) {
          var f2 = e2[d2 = a2[l2]], p2 = t2[d2];
          if (n2)
            var b2 = s2 ? n2(p2, f2, d2, t2, e2, r2) : n2(f2, p2, d2, e2, t2, r2);
          if (!(b2 === void 0 ? f2 === p2 || o2(f2, p2, i2, n2, r2) : b2)) {
            g2 = false;
            break;
          }
          m2 || (m2 = d2 == "constructor");
        }
        if (g2 && !m2) {
          var w2 = e2.constructor, k2 = t2.constructor;
          w2 == k2 || !("constructor" in e2) || !("constructor" in t2) || typeof w2 == "function" && w2 instanceof w2 && typeof k2 == "function" && k2 instanceof k2 || (g2 = false);
        }
        return r2.delete(e2), r2.delete(t2), g2;
      }, Gr = Object.prototype.hasOwnProperty;
      var Kr = function(e2, t2, i2, n2, o2, r2) {
        var s2 = _e(e2), a2 = _e(t2), c2 = s2 ? "[object Array]" : yi(e2), l2 = a2 ? "[object Array]" : yi(t2), d2 = (c2 = c2 == "[object Arguments]" ? "[object Object]" : c2) == "[object Object]", h2 = (l2 = l2 == "[object Arguments]" ? "[object Object]" : l2) == "[object Object]", u2 = c2 == l2;
        if (u2 && Object(ve.a)(e2)) {
          if (!Object(ve.a)(t2))
            return false;
          s2 = true, d2 = false;
        }
        if (u2 && !d2)
          return r2 || (r2 = new Wt()), s2 || Ee(e2) ? Br(e2, t2, i2, n2, o2, r2) : qr(e2, t2, c2, i2, n2, o2, r2);
        if (!(1 & i2)) {
          var g2 = d2 && Gr.call(e2, "__wrapped__"), m2 = h2 && Gr.call(t2, "__wrapped__");
          if (g2 || m2) {
            var f2 = g2 ? e2.value() : e2, p2 = m2 ? t2.value() : t2;
            return r2 || (r2 = new Wt()), o2(f2, p2, i2, n2, r2);
          }
        }
        return !!u2 && (r2 || (r2 = new Wt()), Yr(e2, t2, i2, n2, o2, r2));
      };
      var Qr = function e2(t2, i2, n2, o2, r2) {
        return t2 === i2 || (t2 == null || i2 == null || !me(t2) && !me(i2) ? t2 != t2 && i2 != i2 : Kr(t2, i2, n2, o2, e2, r2));
      };
      var Jr = function(e2, t2, i2) {
        var n2 = (i2 = typeof i2 == "function" ? i2 : void 0) ? i2(e2, t2) : void 0;
        return n2 === void 0 ? Qr(e2, t2, void 0, i2) : !!n2;
      };
      class Zr extends Rr {
        constructor(e2) {
          super(e2), this._config = { childList: true, characterData: true, characterDataOldValue: true, subtree: true }, this.domConverter = e2.domConverter, this.renderer = e2._renderer, this._domElements = [], this._mutationObserver = new window.MutationObserver(this._onMutations.bind(this));
        }
        flush() {
          this._onMutations(this._mutationObserver.takeRecords());
        }
        observe(e2) {
          this._domElements.push(e2), this.isEnabled && this._mutationObserver.observe(e2, this._config);
        }
        enable() {
          super.enable();
          for (const e2 of this._domElements)
            this._mutationObserver.observe(e2, this._config);
        }
        disable() {
          super.disable(), this._mutationObserver.disconnect();
        }
        destroy() {
          super.destroy(), this._mutationObserver.disconnect();
        }
        _onMutations(e2) {
          if (e2.length === 0)
            return;
          const t2 = this.domConverter, i2 = new Map(), n2 = new Set();
          for (const i3 of e2)
            if (i3.type === "childList") {
              const e3 = t2.mapDomToView(i3.target);
              if (e3 && (e3.is("uiElement") || e3.is("rawElement")))
                continue;
              e3 && !this._isBogusBrMutation(i3) && n2.add(e3);
            }
          for (const o3 of e2) {
            const e3 = t2.mapDomToView(o3.target);
            if ((!e3 || !e3.is("uiElement") && !e3.is("rawElement")) && o3.type === "characterData") {
              const e4 = t2.findCorrespondingViewText(o3.target);
              e4 && !n2.has(e4.parent) ? i2.set(e4, { type: "text", oldText: e4.data, newText: ar(o3.target), node: e4 }) : !e4 && rr(o3.target) && n2.add(t2.mapDomToView(o3.target.parentNode));
            }
          }
          const o2 = [];
          for (const e3 of i2.values())
            this.renderer.markToSync("text", e3.node), o2.push(e3);
          for (const e3 of n2) {
            const i3 = t2.mapViewToDom(e3), n3 = Array.from(e3.getChildren()), r3 = Array.from(t2.domChildrenToView(i3, { withChildren: false }));
            Jr(n3, r3, a2) || (this.renderer.markToSync("children", e3), o2.push({ type: "children", oldChildren: n3, newChildren: r3, node: e3 }));
          }
          const r2 = e2[0].target.ownerDocument.getSelection();
          let s2 = null;
          if (r2 && r2.anchorNode) {
            const e3 = t2.domPositionToView(r2.anchorNode, r2.anchorOffset), i3 = t2.domPositionToView(r2.focusNode, r2.focusOffset);
            e3 && i3 && (s2 = new go(e3), s2.setFocus(i3));
          }
          function a2(e3, t3) {
            if (!Array.isArray(e3))
              return e3 === t3 || !(!e3.is("$text") || !t3.is("$text")) && e3.data === t3.data;
          }
          o2.length && (this.document.fire("mutations", o2, s2), this.view.forceRender());
        }
        _isBogusBrMutation(e2) {
          let t2 = null;
          return e2.nextSibling === null && e2.removedNodes.length === 0 && e2.addedNodes.length == 1 && (t2 = this.domConverter.domToView(e2.addedNodes[0], { withChildren: false })), t2 && t2.is("element", "br");
        }
      }
      class Xr {
        constructor(e2, t2, i2) {
          this.view = e2, this.document = e2.document, this.domEvent = t2, this.domTarget = t2.target, De(this, i2);
        }
        get target() {
          return this.view.domConverter.mapDomToView(this.domTarget);
        }
        preventDefault() {
          this.domEvent.preventDefault();
        }
        stopPropagation() {
          this.domEvent.stopPropagation();
        }
      }
      class es extends Rr {
        constructor(e2) {
          super(e2), this.useCapture = false;
        }
        observe(e2) {
          (typeof this.domEventType == "string" ? [this.domEventType] : this.domEventType).forEach((t2) => {
            this.listenTo(e2, t2, (e3, t3) => {
              this.isEnabled && !this.checkShouldIgnoreEventFromTarget(t3.target) && this.onDomEvent(t3);
            }, { useCapture: this.useCapture });
          });
        }
        fire(e2, t2, i2) {
          this.isEnabled && this.document.fire(e2, new Xr(this.view, t2, i2));
        }
      }
      class ts extends es {
        constructor(e2) {
          super(e2), this.domEventType = ["keydown", "keyup"];
        }
        onDomEvent(e2) {
          this.fire(e2.type, e2, { keyCode: e2.keyCode, altKey: e2.altKey, ctrlKey: e2.ctrlKey, shiftKey: e2.shiftKey, metaKey: e2.metaKey, get keystroke() {
            return Oo(this);
          } });
        }
      }
      var is = function() {
        return k.a.Date.now();
      }, ns = /\s/;
      var os = function(e2) {
        for (var t2 = e2.length; t2-- && ns.test(e2.charAt(t2)); )
          ;
        return t2;
      }, rs = /^\s+/;
      var ss = function(e2) {
        return e2 ? e2.slice(0, os(e2) + 1).replace(rs, "") : e2;
      }, as = /^[-+]0x[0-9a-f]+$/i, cs = /^0b[01]+$/i, ls = /^0o[0-7]+$/i, ds = parseInt;
      var hs = function(e2) {
        if (typeof e2 == "number")
          return e2;
        if (bn(e2))
          return NaN;
        if (w(e2)) {
          var t2 = typeof e2.valueOf == "function" ? e2.valueOf() : e2;
          e2 = w(t2) ? t2 + "" : t2;
        }
        if (typeof e2 != "string")
          return e2 === 0 ? e2 : +e2;
        e2 = ss(e2);
        var i2 = cs.test(e2);
        return i2 || ls.test(e2) ? ds(e2.slice(2), i2 ? 2 : 8) : as.test(e2) ? NaN : +e2;
      }, us = Math.max, gs = Math.min;
      var ms = function(e2, t2, i2) {
        var n2, o2, r2, s2, a2, c2, l2 = 0, d2 = false, h2 = false, u2 = true;
        if (typeof e2 != "function")
          throw new TypeError("Expected a function");
        function g2(t3) {
          var i3 = n2, r3 = o2;
          return n2 = o2 = void 0, l2 = t3, s2 = e2.apply(r3, i3);
        }
        function m2(e3) {
          return l2 = e3, a2 = setTimeout(p2, t2), d2 ? g2(e3) : s2;
        }
        function f2(e3) {
          var i3 = e3 - c2;
          return c2 === void 0 || i3 >= t2 || i3 < 0 || h2 && e3 - l2 >= r2;
        }
        function p2() {
          var e3 = is();
          if (f2(e3))
            return b2(e3);
          a2 = setTimeout(p2, function(e4) {
            var i3 = t2 - (e4 - c2);
            return h2 ? gs(i3, r2 - (e4 - l2)) : i3;
          }(e3));
        }
        function b2(e3) {
          return a2 = void 0, u2 && n2 ? g2(e3) : (n2 = o2 = void 0, s2);
        }
        function k2() {
          var e3 = is(), i3 = f2(e3);
          if (n2 = arguments, o2 = this, c2 = e3, i3) {
            if (a2 === void 0)
              return m2(c2);
            if (h2)
              return clearTimeout(a2), a2 = setTimeout(p2, t2), g2(c2);
          }
          return a2 === void 0 && (a2 = setTimeout(p2, t2)), s2;
        }
        return t2 = hs(t2) || 0, w(i2) && (d2 = !!i2.leading, r2 = (h2 = "maxWait" in i2) ? us(hs(i2.maxWait) || 0, t2) : r2, u2 = "trailing" in i2 ? !!i2.trailing : u2), k2.cancel = function() {
          a2 !== void 0 && clearTimeout(a2), l2 = 0, n2 = c2 = o2 = a2 = void 0;
        }, k2.flush = function() {
          return a2 === void 0 ? s2 : b2(is());
        }, k2;
      };
      class fs extends Rr {
        constructor(e2) {
          super(e2), this._fireSelectionChangeDoneDebounced = ms((e3) => this.document.fire("selectionChangeDone", e3), 200);
        }
        observe() {
          const e2 = this.document;
          e2.on("arrowKey", (t2, i2) => {
            e2.selection.isFake && this.isEnabled && i2.preventDefault();
          }, { context: "$capture" }), e2.on("arrowKey", (t2, i2) => {
            e2.selection.isFake && this.isEnabled && this._handleSelectionMove(i2.keyCode);
          }, { priority: "lowest" });
        }
        destroy() {
          super.destroy(), this._fireSelectionChangeDoneDebounced.cancel();
        }
        _handleSelectionMove(e2) {
          const t2 = this.document.selection, i2 = new go(t2.getRanges(), { backward: t2.isBackward, fake: false });
          e2 != No.arrowleft && e2 != No.arrowup || i2.setTo(i2.getFirstPosition()), e2 != No.arrowright && e2 != No.arrowdown || i2.setTo(i2.getLastPosition());
          const n2 = { oldSelection: t2, newSelection: i2, domSelection: null };
          this.document.fire("selectionChange", n2), this._fireSelectionChangeDoneDebounced(n2);
        }
      }
      class ps extends Rr {
        constructor(e2) {
          super(e2), this.mutationObserver = e2.getObserver(Zr), this.selection = this.document.selection, this.domConverter = e2.domConverter, this._documents = new WeakSet(), this._fireSelectionChangeDoneDebounced = ms((e3) => this.document.fire("selectionChangeDone", e3), 200), this._clearInfiniteLoopInterval = setInterval(() => this._clearInfiniteLoop(), 1e3), this._loopbackCounter = 0;
        }
        observe(e2) {
          const t2 = e2.ownerDocument;
          this._documents.has(t2) || (this.listenTo(t2, "selectionchange", (e3, i2) => {
            this._handleSelectionChange(i2, t2);
          }), this._documents.add(t2));
        }
        destroy() {
          super.destroy(), clearInterval(this._clearInfiniteLoopInterval), this._fireSelectionChangeDoneDebounced.cancel();
        }
        _handleSelectionChange(e2, t2) {
          if (!this.isEnabled)
            return;
          const i2 = t2.defaultView.getSelection();
          if (this.checkShouldIgnoreEventFromTarget(i2.anchorNode))
            return;
          this.mutationObserver.flush();
          const n2 = this.domConverter.domSelectionToView(i2);
          if (n2.rangeCount != 0) {
            if (this.view.hasDomSelection = true, !(this.selection.isEqual(n2) && this.domConverter.isDomSelectionCorrect(i2) || ++this._loopbackCounter > 60))
              if (this.selection.isSimilar(n2))
                this.view.forceRender();
              else {
                const e3 = { oldSelection: this.selection, newSelection: n2, domSelection: i2 };
                this.document.fire("selectionChange", e3), this._fireSelectionChangeDoneDebounced(e3);
              }
          } else
            this.view.hasDomSelection = false;
        }
        _clearInfiniteLoop() {
          this._loopbackCounter = 0;
        }
      }
      class bs extends es {
        constructor(e2) {
          super(e2), this.domEventType = ["focus", "blur"], this.useCapture = true;
          const t2 = this.document;
          t2.on("focus", () => {
            t2.isFocused = true, this._renderTimeoutId = setTimeout(() => e2.change(() => {
            }), 50);
          }), t2.on("blur", (i2, n2) => {
            const o2 = t2.selection.editableElement;
            o2 !== null && o2 !== n2.target || (t2.isFocused = false, e2.change(() => {
            }));
          });
        }
        onDomEvent(e2) {
          this.fire(e2.type, e2);
        }
        destroy() {
          this._renderTimeoutId && clearTimeout(this._renderTimeoutId), super.destroy();
        }
      }
      class ws extends es {
        constructor(e2) {
          super(e2), this.domEventType = ["compositionstart", "compositionupdate", "compositionend"];
          const t2 = this.document;
          t2.on("compositionstart", () => {
            t2.isComposing = true;
          }), t2.on("compositionend", () => {
            t2.isComposing = false;
          });
        }
        onDomEvent(e2) {
          this.fire(e2.type, e2);
        }
      }
      class ks extends es {
        constructor(e2) {
          super(e2), this.domEventType = ["beforeinput"];
        }
        onDomEvent(e2) {
          this.fire(e2.type, e2);
        }
      }
      class _s {
        constructor() {
          this._replacedElements = [];
        }
        replace(e2, t2) {
          this._replacedElements.push({ element: e2, newElement: t2 }), e2.style.display = "none", t2 && e2.parentNode.insertBefore(t2, e2.nextSibling);
        }
        restore() {
          this._replacedElements.forEach(({ element: e2, newElement: t2 }) => {
            e2.style.display = "", t2 && t2.remove();
          }), this._replacedElements = [];
        }
      }
      var vs = function(e2) {
        return typeof e2 == "string" || !_e(e2) && me(e2) && S(e2) == "[object String]";
      };
      function ys(e2) {
        return Object.prototype.toString.apply(e2) == "[object Range]";
      }
      function xs(e2) {
        const t2 = e2.ownerDocument.defaultView.getComputedStyle(e2);
        return { top: parseInt(t2.borderTopWidth, 10), right: parseInt(t2.borderRightWidth, 10), bottom: parseInt(t2.borderBottomWidth, 10), left: parseInt(t2.borderLeftWidth, 10) };
      }
      const As = ["top", "right", "bottom", "left", "width", "height"];
      class Cs {
        constructor(e2) {
          const t2 = ys(e2);
          if (Object.defineProperty(this, "_source", { value: e2._source || e2, writable: true, enumerable: false }), Yi(e2) || t2)
            if (t2) {
              const t3 = Cs.getDomRangeRects(e2);
              Ts(this, Cs.getBoundingRect(t3));
            } else
              Ts(this, e2.getBoundingClientRect());
          else if (Sr(e2)) {
            const { innerWidth: t3, innerHeight: i2 } = e2;
            Ts(this, { top: 0, right: t3, bottom: i2, left: 0, width: t3, height: i2 });
          } else
            Ts(this, e2);
        }
        clone() {
          return new Cs(this);
        }
        moveTo(e2, t2) {
          return this.top = t2, this.right = e2 + this.width, this.bottom = t2 + this.height, this.left = e2, this;
        }
        moveBy(e2, t2) {
          return this.top += t2, this.right += e2, this.left += e2, this.bottom += t2, this;
        }
        getIntersection(e2) {
          const t2 = { top: Math.max(this.top, e2.top), right: Math.min(this.right, e2.right), bottom: Math.min(this.bottom, e2.bottom), left: Math.max(this.left, e2.left) };
          return t2.width = t2.right - t2.left, t2.height = t2.bottom - t2.top, t2.width < 0 || t2.height < 0 ? null : new Cs(t2);
        }
        getIntersectionArea(e2) {
          const t2 = this.getIntersection(e2);
          return t2 ? t2.getArea() : 0;
        }
        getArea() {
          return this.width * this.height;
        }
        getVisible() {
          const e2 = this._source;
          let t2 = this.clone();
          if (!Es(e2)) {
            let i2 = e2.parentNode || e2.commonAncestorContainer;
            for (; i2 && !Es(i2); ) {
              const e3 = new Cs(i2), n2 = t2.getIntersection(e3);
              if (!n2)
                return null;
              n2.getArea() < t2.getArea() && (t2 = n2), i2 = i2.parentNode;
            }
          }
          return t2;
        }
        isEqual(e2) {
          for (const t2 of As)
            if (this[t2] !== e2[t2])
              return false;
          return true;
        }
        contains(e2) {
          const t2 = this.getIntersection(e2);
          return !(!t2 || !t2.isEqual(e2));
        }
        excludeScrollbarsAndBorders() {
          const e2 = this._source;
          let t2, i2, n2;
          if (Sr(e2))
            t2 = e2.innerWidth - e2.document.documentElement.clientWidth, i2 = e2.innerHeight - e2.document.documentElement.clientHeight, n2 = e2.getComputedStyle(e2.document.documentElement).direction;
          else {
            const o2 = xs(this._source);
            t2 = e2.offsetWidth - e2.clientWidth - o2.left - o2.right, i2 = e2.offsetHeight - e2.clientHeight - o2.top - o2.bottom, n2 = e2.ownerDocument.defaultView.getComputedStyle(e2).direction, this.left += o2.left, this.top += o2.top, this.right -= o2.right, this.bottom -= o2.bottom, this.width = this.right - this.left, this.height = this.bottom - this.top;
          }
          return this.width -= t2, n2 === "ltr" ? this.right -= t2 : this.left += t2, this.height -= i2, this.bottom -= i2, this;
        }
        static getDomRangeRects(e2) {
          const t2 = [], i2 = Array.from(e2.getClientRects());
          if (i2.length)
            for (const e3 of i2)
              t2.push(new Cs(e3));
          else {
            let i3 = e2.startContainer;
            er(i3) && (i3 = i3.parentNode);
            const n2 = new Cs(i3.getBoundingClientRect());
            n2.right = n2.left, n2.width = 0, t2.push(n2);
          }
          return t2;
        }
        static getBoundingRect(e2) {
          const t2 = { left: Number.POSITIVE_INFINITY, top: Number.POSITIVE_INFINITY, right: Number.NEGATIVE_INFINITY, bottom: Number.NEGATIVE_INFINITY };
          let i2 = 0;
          for (const n2 of e2)
            i2++, t2.left = Math.min(t2.left, n2.left), t2.top = Math.min(t2.top, n2.top), t2.right = Math.max(t2.right, n2.right), t2.bottom = Math.max(t2.bottom, n2.bottom);
          return i2 == 0 ? null : (t2.width = t2.right - t2.left, t2.height = t2.bottom - t2.top, new Cs(t2));
        }
      }
      function Ts(e2, t2) {
        for (const i2 of As)
          e2[i2] = t2[i2];
      }
      function Es(e2) {
        return !!Yi(e2) && e2 === e2.ownerDocument.body;
      }
      class Is {
        constructor(e2, t2) {
          Is._observerInstance || Is._createObserver(), this._element = e2, this._callback = t2, Is._addElementCallback(e2, t2), Is._observerInstance.observe(e2);
        }
        destroy() {
          Is._deleteElementCallback(this._element, this._callback);
        }
        static _addElementCallback(e2, t2) {
          Is._elementCallbacks || (Is._elementCallbacks = new Map());
          let i2 = Is._elementCallbacks.get(e2);
          i2 || (i2 = new Set(), Is._elementCallbacks.set(e2, i2)), i2.add(t2);
        }
        static _deleteElementCallback(e2, t2) {
          const i2 = Is._getElementCallbacks(e2);
          i2 && (i2.delete(t2), i2.size || (Is._elementCallbacks.delete(e2), Is._observerInstance.unobserve(e2))), Is._elementCallbacks && !Is._elementCallbacks.size && (Is._observerInstance = null, Is._elementCallbacks = null);
        }
        static _getElementCallbacks(e2) {
          return Is._elementCallbacks ? Is._elementCallbacks.get(e2) : null;
        }
        static _createObserver() {
          let e2;
          e2 = typeof _r.window.ResizeObserver == "function" ? _r.window.ResizeObserver : Ss, Is._observerInstance = new e2((e3) => {
            for (const t2 of e3) {
              const e4 = Is._getElementCallbacks(t2.target);
              if (e4)
                for (const i2 of e4)
                  i2(t2);
            }
          });
        }
      }
      Is._observerInstance = null, Is._elementCallbacks = null;
      class Ss {
        constructor(e2) {
          this._callback = e2, this._elements = new Set(), this._previousRects = new Map(), this._periodicCheckTimeout = null;
        }
        observe(e2) {
          this._elements.add(e2), this._checkElementRectsAndExecuteCallback(), this._elements.size === 1 && this._startPeriodicCheck();
        }
        unobserve(e2) {
          this._elements.delete(e2), this._previousRects.delete(e2), this._elements.size || this._stopPeriodicCheck();
        }
        _startPeriodicCheck() {
          const e2 = () => {
            this._checkElementRectsAndExecuteCallback(), this._periodicCheckTimeout = setTimeout(e2, 100);
          };
          this.listenTo(_r.window, "resize", () => {
            this._checkElementRectsAndExecuteCallback();
          }), this._periodicCheckTimeout = setTimeout(e2, 100);
        }
        _stopPeriodicCheck() {
          clearTimeout(this._periodicCheckTimeout), this.stopListening(), this._previousRects.clear();
        }
        _checkElementRectsAndExecuteCallback() {
          const e2 = [];
          for (const t2 of this._elements)
            this._hasRectChanged(t2) && e2.push({ target: t2, contentRect: this._previousRects.get(t2) });
          e2.length && this._callback(e2);
        }
        _hasRectChanged(e2) {
          if (!e2.ownerDocument.body.contains(e2))
            return false;
          const t2 = new Cs(e2), i2 = this._previousRects.get(e2), n2 = !i2 || !i2.isEqual(t2);
          return this._previousRects.set(e2, t2), n2;
        }
      }
      function Ps(e2) {
        return (t2) => t2 + e2;
      }
      function Ms(e2) {
        const t2 = e2.next();
        return t2.done ? null : t2.value;
      }
      Ke(Ss, Pr);
      class Ns {
        constructor() {
          this.set("isFocused", false), this.set("focusedElement", null), this._elements = new Set(), this._nextEventLoopTimeout = null;
        }
        add(e2) {
          if (this._elements.has(e2))
            throw new c.a("focustracker-add-element-already-exist", this);
          this.listenTo(e2, "focus", () => this._focus(e2), { useCapture: true }), this.listenTo(e2, "blur", () => this._blur(), { useCapture: true }), this._elements.add(e2);
        }
        remove(e2) {
          e2 === this.focusedElement && this._blur(e2), this._elements.has(e2) && (this.stopListening(e2), this._elements.delete(e2));
        }
        destroy() {
          this.stopListening();
        }
        _focus(e2) {
          clearTimeout(this._nextEventLoopTimeout), this.focusedElement = e2, this.isFocused = true;
        }
        _blur() {
          clearTimeout(this._nextEventLoopTimeout), this._nextEventLoopTimeout = setTimeout(() => {
            this.focusedElement = null, this.isFocused = false;
          }, 0);
        }
      }
      Ke(Ns, Pr), Ke(Ns, Ue);
      class Rs {
        constructor() {
          this._listener = Object.create(Pr);
        }
        listenTo(e2) {
          this._listener.listenTo(e2, "keydown", (e3, t2) => {
            this._listener.fire("_keydown:" + Oo(t2), t2);
          });
        }
        set(e2, t2, i2 = {}) {
          const n2 = zo(e2), o2 = i2.priority;
          this._listener.listenTo(this._listener, "_keydown:" + n2, (e3, i3) => {
            t2(i3, () => {
              i3.preventDefault(), i3.stopPropagation(), e3.stop();
            }), e3.return = true;
          }, { priority: o2 });
        }
        press(e2) {
          return !!this._listener.fire("_keydown:" + Oo(e2), e2);
        }
        destroy() {
          this._listener.stopListening();
        }
      }
      class Os extends Rr {
        constructor(e2) {
          super(e2), this.document.on("keydown", (e3, t2) => {
            if (this.isEnabled && ((i2 = t2.keyCode) == No.arrowright || i2 == No.arrowleft || i2 == No.arrowup || i2 == No.arrowdown)) {
              const i3 = new fo(this.document, "arrowKey", this.document.selection.getFirstRange());
              this.document.fire(i3, t2), i3.stop.called && e3.stop();
            }
            var i2;
          });
        }
        observe() {
        }
      }
      function zs({ target: e2, viewportOffset: t2 = 0 }) {
        const i2 = Hs(e2);
        let n2 = i2, o2 = null;
        for (; n2; ) {
          let r2;
          r2 = Us(n2 == i2 ? e2 : o2), Ls(r2, () => Ws(e2, n2));
          const s2 = Ws(e2, n2);
          if (Ds(n2, s2, t2), n2.parent != n2) {
            if (o2 = n2.frameElement, n2 = n2.parent, !o2)
              return;
          } else
            n2 = null;
        }
      }
      function Ds(e2, t2, i2) {
        const n2 = t2.clone().moveBy(0, i2), o2 = t2.clone().moveBy(0, -i2), r2 = new Cs(e2).excludeScrollbarsAndBorders();
        if (![o2, n2].every((e3) => r2.contains(e3))) {
          let { scrollX: s2, scrollY: a2 } = e2;
          js(o2, r2) ? a2 -= r2.top - t2.top + i2 : Vs(n2, r2) && (a2 += t2.bottom - r2.bottom + i2), Bs(t2, r2) ? s2 -= r2.left - t2.left + i2 : Fs(t2, r2) && (s2 += t2.right - r2.right + i2), e2.scrollTo(s2, a2);
        }
      }
      function Ls(e2, t2) {
        const i2 = Hs(e2);
        let n2, o2;
        for (; e2 != i2.document.body; )
          o2 = t2(), n2 = new Cs(e2).excludeScrollbarsAndBorders(), n2.contains(o2) || (js(o2, n2) ? e2.scrollTop -= n2.top - o2.top : Vs(o2, n2) && (e2.scrollTop += o2.bottom - n2.bottom), Bs(o2, n2) ? e2.scrollLeft -= n2.left - o2.left : Fs(o2, n2) && (e2.scrollLeft += o2.right - n2.right)), e2 = e2.parentNode;
      }
      function Vs(e2, t2) {
        return e2.bottom > t2.bottom;
      }
      function js(e2, t2) {
        return e2.top < t2.top;
      }
      function Bs(e2, t2) {
        return e2.left < t2.left;
      }
      function Fs(e2, t2) {
        return e2.right > t2.right;
      }
      function Hs(e2) {
        return ys(e2) ? e2.startContainer.ownerDocument.defaultView : e2.ownerDocument.defaultView;
      }
      function Us(e2) {
        if (ys(e2)) {
          let t2 = e2.commonAncestorContainer;
          return er(t2) && (t2 = t2.parentNode), t2;
        }
        return e2.parentNode;
      }
      function Ws(e2, t2) {
        const i2 = Hs(e2), n2 = new Cs(e2);
        if (i2 === t2)
          return n2;
        {
          let e3 = i2;
          for (; e3 != t2; ) {
            const t3 = e3.frameElement, i3 = new Cs(t3).excludeScrollbarsAndBorders();
            n2.moveBy(i3.left, i3.top), e3 = e3.parent;
          }
        }
        return n2;
      }
      Object.assign({}, { scrollViewportToShowTarget: zs, scrollAncestorsToShowTarget: function(e2) {
        Ls(Us(e2), () => new Cs(e2));
      } });
      class qs {
        constructor(e2) {
          this.document = new yo(e2), this.domConverter = new Tr(this.document), this.domRoots = new Map(), this.set("isRenderingInProgress", false), this.set("hasDomSelection", false), this._renderer = new pr(this.domConverter, this.document.selection), this._renderer.bind("isFocused").to(this.document), this._initialDomRootAttributes = new WeakMap(), this._observers = new Map(), this._ongoingChange = false, this._postFixersInProgress = false, this._renderingDisabled = false, this._hasChangedSinceTheLastRendering = false, this._writer = new Wo(this.document), this.addObserver(Zr), this.addObserver(ps), this.addObserver(bs), this.addObserver(ts), this.addObserver(fs), this.addObserver(ws), this.addObserver(Os), So.isAndroid && this.addObserver(ks), this.document.on("arrowKey", cr, { priority: "low" }), jo(this), this.on("render", () => {
            this._render(), this.document.fire("layoutChanged"), this._hasChangedSinceTheLastRendering = false;
          }), this.listenTo(this.document.selection, "change", () => {
            this._hasChangedSinceTheLastRendering = true;
          }), this.listenTo(this.document, "change:isFocused", () => {
            this._hasChangedSinceTheLastRendering = true;
          });
        }
        attachDomRoot(e2, t2 = "main") {
          const i2 = this.document.getRoot(t2);
          i2._name = e2.tagName.toLowerCase();
          const n2 = {};
          for (const { name: t3, value: o3 } of Array.from(e2.attributes))
            n2[t3] = o3, t3 === "class" ? this._writer.addClass(o3.split(" "), i2) : this._writer.setAttribute(t3, o3, i2);
          this._initialDomRootAttributes.set(e2, n2);
          const o2 = () => {
            this._writer.setAttribute("contenteditable", !i2.isReadOnly, i2), i2.isReadOnly ? this._writer.addClass("ck-read-only", i2) : this._writer.removeClass("ck-read-only", i2);
          };
          o2(), this.domRoots.set(t2, e2), this.domConverter.bindElements(e2, i2), this._renderer.markToSync("children", i2), this._renderer.markToSync("attributes", i2), this._renderer.domDocuments.add(e2.ownerDocument), i2.on("change:children", (e3, t3) => this._renderer.markToSync("children", t3)), i2.on("change:attributes", (e3, t3) => this._renderer.markToSync("attributes", t3)), i2.on("change:text", (e3, t3) => this._renderer.markToSync("text", t3)), i2.on("change:isReadOnly", () => this.change(o2)), i2.on("change", () => {
            this._hasChangedSinceTheLastRendering = true;
          });
          for (const i3 of this._observers.values())
            i3.observe(e2, t2);
        }
        detachDomRoot(e2) {
          const t2 = this.domRoots.get(e2);
          Array.from(t2.attributes).forEach(({ name: e3 }) => t2.removeAttribute(e3));
          const i2 = this._initialDomRootAttributes.get(t2);
          for (const e3 in i2)
            t2.setAttribute(e3, i2[e3]);
          this.domRoots.delete(e2), this.domConverter.unbindDomElement(t2);
        }
        getDomRoot(e2 = "main") {
          return this.domRoots.get(e2);
        }
        addObserver(e2) {
          let t2 = this._observers.get(e2);
          if (t2)
            return t2;
          t2 = new e2(this), this._observers.set(e2, t2);
          for (const [e3, i2] of this.domRoots)
            t2.observe(i2, e3);
          return t2.enable(), t2;
        }
        getObserver(e2) {
          return this._observers.get(e2);
        }
        disableObservers() {
          for (const e2 of this._observers.values())
            e2.disable();
        }
        enableObservers() {
          for (const e2 of this._observers.values())
            e2.enable();
        }
        scrollToTheSelection() {
          const e2 = this.document.selection.getFirstRange();
          e2 && zs({ target: this.domConverter.viewRangeToDom(e2), viewportOffset: 20 });
        }
        focus() {
          if (!this.document.isFocused) {
            const e2 = this.document.selection.editableElement;
            e2 && (this.domConverter.focus(e2), this.forceRender());
          }
        }
        change(e2) {
          if (this.isRenderingInProgress || this._postFixersInProgress)
            throw new c.a("cannot-change-view-tree", this);
          try {
            if (this._ongoingChange)
              return e2(this._writer);
            this._ongoingChange = true;
            const t2 = e2(this._writer);
            return this._ongoingChange = false, !this._renderingDisabled && this._hasChangedSinceTheLastRendering && (this._postFixersInProgress = true, this.document._callPostFixers(this._writer), this._postFixersInProgress = false, this.fire("render")), t2;
          } catch (e3) {
            c.a.rethrowUnexpectedError(e3, this);
          }
        }
        forceRender() {
          this._hasChangedSinceTheLastRendering = true, this.change(() => {
          });
        }
        destroy() {
          for (const e2 of this._observers.values())
            e2.destroy();
          this.document.destroy(), this.stopListening();
        }
        createPositionAt(e2, t2) {
          return co._createAt(e2, t2);
        }
        createPositionAfter(e2) {
          return co._createAfter(e2);
        }
        createPositionBefore(e2) {
          return co._createBefore(e2);
        }
        createRange(e2, t2) {
          return new lo(e2, t2);
        }
        createRangeOn(e2) {
          return lo._createOn(e2);
        }
        createRangeIn(e2) {
          return lo._createIn(e2);
        }
        createSelection(e2, t2, i2) {
          return new go(e2, t2, i2);
        }
        _disableRendering(e2) {
          this._renderingDisabled = e2, e2 == 0 && this.change(() => {
          });
        }
        _render() {
          this.isRenderingInProgress = true, this.disableObservers(), this._renderer.render(), this.enableObservers(), this.isRenderingInProgress = false;
        }
      }
      Ke(qs, Ue);
      class $s {
        constructor(e2) {
          this.parent = null, this._attrs = gn(e2);
        }
        get index() {
          let e2;
          if (!this.parent)
            return null;
          if ((e2 = this.parent.getChildIndex(this)) === null)
            throw new c.a("model-node-not-found-in-parent", this);
          return e2;
        }
        get startOffset() {
          let e2;
          if (!this.parent)
            return null;
          if ((e2 = this.parent.getChildStartOffset(this)) === null)
            throw new c.a("model-node-not-found-in-parent", this);
          return e2;
        }
        get offsetSize() {
          return 1;
        }
        get endOffset() {
          return this.parent ? this.startOffset + this.offsetSize : null;
        }
        get nextSibling() {
          const e2 = this.index;
          return e2 !== null && this.parent.getChild(e2 + 1) || null;
        }
        get previousSibling() {
          const e2 = this.index;
          return e2 !== null && this.parent.getChild(e2 - 1) || null;
        }
        get root() {
          let e2 = this;
          for (; e2.parent; )
            e2 = e2.parent;
          return e2;
        }
        isAttached() {
          return this.root.is("rootElement");
        }
        getPath() {
          const e2 = [];
          let t2 = this;
          for (; t2.parent; )
            e2.unshift(t2.startOffset), t2 = t2.parent;
          return e2;
        }
        getAncestors(e2 = { includeSelf: false, parentFirst: false }) {
          const t2 = [];
          let i2 = e2.includeSelf ? this : this.parent;
          for (; i2; )
            t2[e2.parentFirst ? "push" : "unshift"](i2), i2 = i2.parent;
          return t2;
        }
        getCommonAncestor(e2, t2 = {}) {
          const i2 = this.getAncestors(t2), n2 = e2.getAncestors(t2);
          let o2 = 0;
          for (; i2[o2] == n2[o2] && i2[o2]; )
            o2++;
          return o2 === 0 ? null : i2[o2 - 1];
        }
        isBefore(e2) {
          if (this == e2)
            return false;
          if (this.root !== e2.root)
            return false;
          const t2 = this.getPath(), i2 = e2.getPath(), n2 = cn(t2, i2);
          switch (n2) {
            case "prefix":
              return true;
            case "extension":
              return false;
            default:
              return t2[n2] < i2[n2];
          }
        }
        isAfter(e2) {
          return this != e2 && (this.root === e2.root && !this.isBefore(e2));
        }
        hasAttribute(e2) {
          return this._attrs.has(e2);
        }
        getAttribute(e2) {
          return this._attrs.get(e2);
        }
        getAttributes() {
          return this._attrs.entries();
        }
        getAttributeKeys() {
          return this._attrs.keys();
        }
        toJSON() {
          const e2 = {};
          return this._attrs.size && (e2.attributes = Array.from(this._attrs).reduce((e3, t2) => (e3[t2[0]] = t2[1], e3), {})), e2;
        }
        is(e2) {
          return e2 === "node" || e2 === "model:node";
        }
        _clone() {
          return new $s(this._attrs);
        }
        _remove() {
          this.parent._removeChildren(this.index);
        }
        _setAttribute(e2, t2) {
          this._attrs.set(e2, t2);
        }
        _setAttributesTo(e2) {
          this._attrs = gn(e2);
        }
        _removeAttribute(e2) {
          return this._attrs.delete(e2);
        }
        _clearAttributes() {
          this._attrs.clear();
        }
      }
      class Ys extends $s {
        constructor(e2, t2) {
          super(t2), this._data = e2 || "";
        }
        get offsetSize() {
          return this.data.length;
        }
        get data() {
          return this._data;
        }
        is(e2) {
          return e2 === "$text" || e2 === "model:$text" || e2 === "text" || e2 === "model:text" || e2 === "node" || e2 === "model:node";
        }
        toJSON() {
          const e2 = super.toJSON();
          return e2.data = this.data, e2;
        }
        _clone() {
          return new Ys(this.data, this.getAttributes());
        }
        static fromJSON(e2) {
          return new Ys(e2.data, e2.attributes);
        }
      }
      class Gs {
        constructor(e2, t2, i2) {
          if (this.textNode = e2, t2 < 0 || t2 > e2.offsetSize)
            throw new c.a("model-textproxy-wrong-offsetintext", this);
          if (i2 < 0 || t2 + i2 > e2.offsetSize)
            throw new c.a("model-textproxy-wrong-length", this);
          this.data = e2.data.substring(t2, t2 + i2), this.offsetInText = t2;
        }
        get startOffset() {
          return this.textNode.startOffset !== null ? this.textNode.startOffset + this.offsetInText : null;
        }
        get offsetSize() {
          return this.data.length;
        }
        get endOffset() {
          return this.startOffset !== null ? this.startOffset + this.offsetSize : null;
        }
        get isPartial() {
          return this.offsetSize !== this.textNode.offsetSize;
        }
        get parent() {
          return this.textNode.parent;
        }
        get root() {
          return this.textNode.root;
        }
        is(e2) {
          return e2 === "$textProxy" || e2 === "model:$textProxy" || e2 === "textProxy" || e2 === "model:textProxy";
        }
        getPath() {
          const e2 = this.textNode.getPath();
          return e2.length > 0 && (e2[e2.length - 1] += this.offsetInText), e2;
        }
        getAncestors(e2 = { includeSelf: false, parentFirst: false }) {
          const t2 = [];
          let i2 = e2.includeSelf ? this : this.parent;
          for (; i2; )
            t2[e2.parentFirst ? "push" : "unshift"](i2), i2 = i2.parent;
          return t2;
        }
        hasAttribute(e2) {
          return this.textNode.hasAttribute(e2);
        }
        getAttribute(e2) {
          return this.textNode.getAttribute(e2);
        }
        getAttributes() {
          return this.textNode.getAttributes();
        }
        getAttributeKeys() {
          return this.textNode.getAttributeKeys();
        }
      }
      class Ks {
        constructor(e2) {
          this._nodes = [], e2 && this._insertNodes(0, e2);
        }
        [Symbol.iterator]() {
          return this._nodes[Symbol.iterator]();
        }
        get length() {
          return this._nodes.length;
        }
        get maxOffset() {
          return this._nodes.reduce((e2, t2) => e2 + t2.offsetSize, 0);
        }
        getNode(e2) {
          return this._nodes[e2] || null;
        }
        getNodeIndex(e2) {
          const t2 = this._nodes.indexOf(e2);
          return t2 == -1 ? null : t2;
        }
        getNodeStartOffset(e2) {
          const t2 = this.getNodeIndex(e2);
          return t2 === null ? null : this._nodes.slice(0, t2).reduce((e3, t3) => e3 + t3.offsetSize, 0);
        }
        indexToOffset(e2) {
          if (e2 == this._nodes.length)
            return this.maxOffset;
          const t2 = this._nodes[e2];
          if (!t2)
            throw new c.a("model-nodelist-index-out-of-bounds", this);
          return this.getNodeStartOffset(t2);
        }
        offsetToIndex(e2) {
          let t2 = 0;
          for (const i2 of this._nodes) {
            if (e2 >= t2 && e2 < t2 + i2.offsetSize)
              return this.getNodeIndex(i2);
            t2 += i2.offsetSize;
          }
          if (t2 != e2)
            throw new c.a("model-nodelist-offset-out-of-bounds", this, { offset: e2, nodeList: this });
          return this.length;
        }
        _insertNodes(e2, t2) {
          for (const e3 of t2)
            if (!(e3 instanceof $s))
              throw new c.a("model-nodelist-insertnodes-not-node", this);
          this._nodes.splice(e2, 0, ...t2);
        }
        _removeNodes(e2, t2 = 1) {
          return this._nodes.splice(e2, t2);
        }
        toJSON() {
          return this._nodes.map((e2) => e2.toJSON());
        }
      }
      class Qs extends $s {
        constructor(e2, t2, i2) {
          super(t2), this.name = e2, this._children = new Ks(), i2 && this._insertChild(0, i2);
        }
        get childCount() {
          return this._children.length;
        }
        get maxOffset() {
          return this._children.maxOffset;
        }
        get isEmpty() {
          return this.childCount === 0;
        }
        is(e2, t2 = null) {
          return t2 ? t2 === this.name && (e2 === "element" || e2 === "model:element") : e2 === "element" || e2 === "model:element" || e2 === "node" || e2 === "model:node";
        }
        getChild(e2) {
          return this._children.getNode(e2);
        }
        getChildren() {
          return this._children[Symbol.iterator]();
        }
        getChildIndex(e2) {
          return this._children.getNodeIndex(e2);
        }
        getChildStartOffset(e2) {
          return this._children.getNodeStartOffset(e2);
        }
        offsetToIndex(e2) {
          return this._children.offsetToIndex(e2);
        }
        getNodeByPath(e2) {
          let t2 = this;
          for (const i2 of e2)
            t2 = t2.getChild(t2.offsetToIndex(i2));
          return t2;
        }
        findAncestor(e2, t2 = { includeSelf: false }) {
          let i2 = t2.includeSelf ? this : this.parent;
          for (; i2; ) {
            if (i2.name === e2)
              return i2;
            i2 = i2.parent;
          }
          return null;
        }
        toJSON() {
          const e2 = super.toJSON();
          if (e2.name = this.name, this._children.length > 0) {
            e2.children = [];
            for (const t2 of this._children)
              e2.children.push(t2.toJSON());
          }
          return e2;
        }
        _clone(e2 = false) {
          const t2 = e2 ? Array.from(this._children).map((e3) => e3._clone(true)) : null;
          return new Qs(this.name, this.getAttributes(), t2);
        }
        _appendChild(e2) {
          this._insertChild(this.childCount, e2);
        }
        _insertChild(e2, t2) {
          const i2 = function(e3) {
            if (typeof e3 == "string")
              return [new Ys(e3)];
            Ji(e3) || (e3 = [e3]);
            return Array.from(e3).map((e4) => typeof e4 == "string" ? new Ys(e4) : e4 instanceof Gs ? new Ys(e4.data, e4.getAttributes()) : e4);
          }(t2);
          for (const e3 of i2)
            e3.parent !== null && e3._remove(), e3.parent = this;
          this._children._insertNodes(e2, i2);
        }
        _removeChildren(e2, t2 = 1) {
          const i2 = this._children._removeNodes(e2, t2);
          for (const e3 of i2)
            e3.parent = null;
          return i2;
        }
        static fromJSON(e2) {
          let t2 = null;
          if (e2.children) {
            t2 = [];
            for (const i2 of e2.children)
              i2.name ? t2.push(Qs.fromJSON(i2)) : t2.push(Ys.fromJSON(i2));
          }
          return new Qs(e2.name, e2.attributes, t2);
        }
      }
      class Js {
        constructor(e2 = {}) {
          if (!e2.boundaries && !e2.startPosition)
            throw new c.a("model-tree-walker-no-start-position", null);
          const t2 = e2.direction || "forward";
          if (t2 != "forward" && t2 != "backward")
            throw new c.a("model-tree-walker-unknown-direction", e2, { direction: t2 });
          this.direction = t2, this.boundaries = e2.boundaries || null, e2.startPosition ? this.position = e2.startPosition.clone() : this.position = Xs._createAt(this.boundaries[this.direction == "backward" ? "end" : "start"]), this.position.stickiness = "toNone", this.singleCharacters = !!e2.singleCharacters, this.shallow = !!e2.shallow, this.ignoreElementEnd = !!e2.ignoreElementEnd, this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null, this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null, this._visitedParent = this.position.parent;
        }
        [Symbol.iterator]() {
          return this;
        }
        skip(e2) {
          let t2, i2, n2, o2;
          do {
            n2 = this.position, o2 = this._visitedParent, { done: t2, value: i2 } = this.next();
          } while (!t2 && e2(i2));
          t2 || (this.position = n2, this._visitedParent = o2);
        }
        next() {
          return this.direction == "forward" ? this._next() : this._previous();
        }
        _next() {
          const e2 = this.position, t2 = this.position.clone(), i2 = this._visitedParent;
          if (i2.parent === null && t2.offset === i2.maxOffset)
            return { done: true };
          if (i2 === this._boundaryEndParent && t2.offset == this.boundaries.end.offset)
            return { done: true };
          const n2 = t2.parent, o2 = ea(t2, n2), r2 = o2 || ta(t2, n2, o2);
          if (r2 instanceof Qs)
            return this.shallow ? t2.offset++ : (t2.path.push(0), this._visitedParent = r2), this.position = t2, Zs("elementStart", r2, e2, t2, 1);
          if (r2 instanceof Ys) {
            let n3;
            if (this.singleCharacters)
              n3 = 1;
            else {
              let e3 = r2.endOffset;
              this._boundaryEndParent == i2 && this.boundaries.end.offset < e3 && (e3 = this.boundaries.end.offset), n3 = e3 - t2.offset;
            }
            const o3 = t2.offset - r2.startOffset, s2 = new Gs(r2, o3, n3);
            return t2.offset += n3, this.position = t2, Zs("text", s2, e2, t2, n3);
          }
          return t2.path.pop(), t2.offset++, this.position = t2, this._visitedParent = i2.parent, this.ignoreElementEnd ? this._next() : Zs("elementEnd", i2, e2, t2);
        }
        _previous() {
          const e2 = this.position, t2 = this.position.clone(), i2 = this._visitedParent;
          if (i2.parent === null && t2.offset === 0)
            return { done: true };
          if (i2 == this._boundaryStartParent && t2.offset == this.boundaries.start.offset)
            return { done: true };
          const n2 = t2.parent, o2 = ea(t2, n2), r2 = o2 || ia(t2, n2, o2);
          if (r2 instanceof Qs)
            return t2.offset--, this.shallow ? (this.position = t2, Zs("elementStart", r2, e2, t2, 1)) : (t2.path.push(r2.maxOffset), this.position = t2, this._visitedParent = r2, this.ignoreElementEnd ? this._previous() : Zs("elementEnd", r2, e2, t2));
          if (r2 instanceof Ys) {
            let n3;
            if (this.singleCharacters)
              n3 = 1;
            else {
              let e3 = r2.startOffset;
              this._boundaryStartParent == i2 && this.boundaries.start.offset > e3 && (e3 = this.boundaries.start.offset), n3 = t2.offset - e3;
            }
            const o3 = t2.offset - r2.startOffset, s2 = new Gs(r2, o3 - n3, n3);
            return t2.offset -= n3, this.position = t2, Zs("text", s2, e2, t2, n3);
          }
          return t2.path.pop(), this.position = t2, this._visitedParent = i2.parent, Zs("elementStart", i2, e2, t2, 1);
        }
      }
      function Zs(e2, t2, i2, n2, o2) {
        return { done: false, value: { type: e2, item: t2, previousPosition: i2, nextPosition: n2, length: o2 } };
      }
      class Xs {
        constructor(e2, t2, i2 = "toNone") {
          if (!e2.is("element") && !e2.is("documentFragment"))
            throw new c.a("model-position-root-invalid", e2);
          if (!(t2 instanceof Array) || t2.length === 0)
            throw new c.a("model-position-path-incorrect-format", e2, { path: t2 });
          e2.is("rootElement") ? t2 = t2.slice() : (t2 = [...e2.getPath(), ...t2], e2 = e2.root), this.root = e2, this.path = t2, this.stickiness = i2;
        }
        get offset() {
          return this.path[this.path.length - 1];
        }
        set offset(e2) {
          this.path[this.path.length - 1] = e2;
        }
        get parent() {
          let e2 = this.root;
          for (let t2 = 0; t2 < this.path.length - 1; t2++)
            if (e2 = e2.getChild(e2.offsetToIndex(this.path[t2])), !e2)
              throw new c.a("model-position-path-incorrect", this, { position: this });
          if (e2.is("$text"))
            throw new c.a("model-position-path-incorrect", this, { position: this });
          return e2;
        }
        get index() {
          return this.parent.offsetToIndex(this.offset);
        }
        get textNode() {
          return ea(this, this.parent);
        }
        get nodeAfter() {
          const e2 = this.parent;
          return ta(this, e2, ea(this, e2));
        }
        get nodeBefore() {
          const e2 = this.parent;
          return ia(this, e2, ea(this, e2));
        }
        get isAtStart() {
          return this.offset === 0;
        }
        get isAtEnd() {
          return this.offset == this.parent.maxOffset;
        }
        compareWith(e2) {
          if (this.root != e2.root)
            return "different";
          const t2 = cn(this.path, e2.path);
          switch (t2) {
            case "same":
              return "same";
            case "prefix":
              return "before";
            case "extension":
              return "after";
            default:
              return this.path[t2] < e2.path[t2] ? "before" : "after";
          }
        }
        getLastMatchingPosition(e2, t2 = {}) {
          t2.startPosition = this;
          const i2 = new Js(t2);
          return i2.skip(e2), i2.position;
        }
        getParentPath() {
          return this.path.slice(0, -1);
        }
        getAncestors() {
          const e2 = this.parent;
          return e2.is("documentFragment") ? [e2] : e2.getAncestors({ includeSelf: true });
        }
        findAncestor(e2) {
          const t2 = this.parent;
          return t2.is("element") ? t2.findAncestor(e2, { includeSelf: true }) : null;
        }
        getCommonPath(e2) {
          if (this.root != e2.root)
            return [];
          const t2 = cn(this.path, e2.path), i2 = typeof t2 == "string" ? Math.min(this.path.length, e2.path.length) : t2;
          return this.path.slice(0, i2);
        }
        getCommonAncestor(e2) {
          const t2 = this.getAncestors(), i2 = e2.getAncestors();
          let n2 = 0;
          for (; t2[n2] == i2[n2] && t2[n2]; )
            n2++;
          return n2 === 0 ? null : t2[n2 - 1];
        }
        getShiftedBy(e2) {
          const t2 = this.clone(), i2 = t2.offset + e2;
          return t2.offset = i2 < 0 ? 0 : i2, t2;
        }
        isAfter(e2) {
          return this.compareWith(e2) == "after";
        }
        isBefore(e2) {
          return this.compareWith(e2) == "before";
        }
        isEqual(e2) {
          return this.compareWith(e2) == "same";
        }
        isTouching(e2) {
          let t2 = null, i2 = null;
          switch (this.compareWith(e2)) {
            case "same":
              return true;
            case "before":
              t2 = Xs._createAt(this), i2 = Xs._createAt(e2);
              break;
            case "after":
              t2 = Xs._createAt(e2), i2 = Xs._createAt(this);
              break;
            default:
              return false;
          }
          let n2 = t2.parent;
          for (; t2.path.length + i2.path.length; ) {
            if (t2.isEqual(i2))
              return true;
            if (t2.path.length > i2.path.length) {
              if (t2.offset !== n2.maxOffset)
                return false;
              t2.path = t2.path.slice(0, -1), n2 = n2.parent, t2.offset++;
            } else {
              if (i2.offset !== 0)
                return false;
              i2.path = i2.path.slice(0, -1);
            }
          }
        }
        is(e2) {
          return e2 === "position" || e2 === "model:position";
        }
        hasSameParentAs(e2) {
          if (this.root !== e2.root)
            return false;
          return cn(this.getParentPath(), e2.getParentPath()) == "same";
        }
        getTransformedByOperation(e2) {
          let t2;
          switch (e2.type) {
            case "insert":
              t2 = this._getTransformedByInsertOperation(e2);
              break;
            case "move":
            case "remove":
            case "reinsert":
              t2 = this._getTransformedByMoveOperation(e2);
              break;
            case "split":
              t2 = this._getTransformedBySplitOperation(e2);
              break;
            case "merge":
              t2 = this._getTransformedByMergeOperation(e2);
              break;
            default:
              t2 = Xs._createAt(this);
          }
          return t2;
        }
        _getTransformedByInsertOperation(e2) {
          return this._getTransformedByInsertion(e2.position, e2.howMany);
        }
        _getTransformedByMoveOperation(e2) {
          return this._getTransformedByMove(e2.sourcePosition, e2.targetPosition, e2.howMany);
        }
        _getTransformedBySplitOperation(e2) {
          const t2 = e2.movedRange;
          return t2.containsPosition(this) || t2.start.isEqual(this) && this.stickiness == "toNext" ? this._getCombined(e2.splitPosition, e2.moveTargetPosition) : e2.graveyardPosition ? this._getTransformedByMove(e2.graveyardPosition, e2.insertionPosition, 1) : this._getTransformedByInsertion(e2.insertionPosition, 1);
        }
        _getTransformedByMergeOperation(e2) {
          const t2 = e2.movedRange;
          let i2;
          return t2.containsPosition(this) || t2.start.isEqual(this) ? (i2 = this._getCombined(e2.sourcePosition, e2.targetPosition), e2.sourcePosition.isBefore(e2.targetPosition) && (i2 = i2._getTransformedByDeletion(e2.deletionPosition, 1))) : i2 = this.isEqual(e2.deletionPosition) ? Xs._createAt(e2.deletionPosition) : this._getTransformedByMove(e2.deletionPosition, e2.graveyardPosition, 1), i2;
        }
        _getTransformedByDeletion(e2, t2) {
          const i2 = Xs._createAt(this);
          if (this.root != e2.root)
            return i2;
          if (cn(e2.getParentPath(), this.getParentPath()) == "same") {
            if (e2.offset < this.offset) {
              if (e2.offset + t2 > this.offset)
                return null;
              i2.offset -= t2;
            }
          } else if (cn(e2.getParentPath(), this.getParentPath()) == "prefix") {
            const n2 = e2.path.length - 1;
            if (e2.offset <= this.path[n2]) {
              if (e2.offset + t2 > this.path[n2])
                return null;
              i2.path[n2] -= t2;
            }
          }
          return i2;
        }
        _getTransformedByInsertion(e2, t2) {
          const i2 = Xs._createAt(this);
          if (this.root != e2.root)
            return i2;
          if (cn(e2.getParentPath(), this.getParentPath()) == "same")
            (e2.offset < this.offset || e2.offset == this.offset && this.stickiness != "toPrevious") && (i2.offset += t2);
          else if (cn(e2.getParentPath(), this.getParentPath()) == "prefix") {
            const n2 = e2.path.length - 1;
            e2.offset <= this.path[n2] && (i2.path[n2] += t2);
          }
          return i2;
        }
        _getTransformedByMove(e2, t2, i2) {
          if (t2 = t2._getTransformedByDeletion(e2, i2), e2.isEqual(t2))
            return Xs._createAt(this);
          const n2 = this._getTransformedByDeletion(e2, i2);
          return n2 === null || e2.isEqual(this) && this.stickiness == "toNext" || e2.getShiftedBy(i2).isEqual(this) && this.stickiness == "toPrevious" ? this._getCombined(e2, t2) : n2._getTransformedByInsertion(t2, i2);
        }
        _getCombined(e2, t2) {
          const i2 = e2.path.length - 1, n2 = Xs._createAt(t2);
          return n2.stickiness = this.stickiness, n2.offset = n2.offset + this.path[i2] - e2.offset, n2.path = [...n2.path, ...this.path.slice(i2 + 1)], n2;
        }
        toJSON() {
          return { root: this.root.toJSON(), path: Array.from(this.path), stickiness: this.stickiness };
        }
        clone() {
          return new this.constructor(this.root, this.path, this.stickiness);
        }
        static _createAt(e2, t2, i2 = "toNone") {
          if (e2 instanceof Xs)
            return new Xs(e2.root, e2.path, e2.stickiness);
          {
            const n2 = e2;
            if (t2 == "end")
              t2 = n2.maxOffset;
            else {
              if (t2 == "before")
                return this._createBefore(n2, i2);
              if (t2 == "after")
                return this._createAfter(n2, i2);
              if (t2 !== 0 && !t2)
                throw new c.a("model-createpositionat-offset-required", [this, e2]);
            }
            if (!n2.is("element") && !n2.is("documentFragment"))
              throw new c.a("model-position-parent-incorrect", [this, e2]);
            const o2 = n2.getPath();
            return o2.push(t2), new this(n2.root, o2, i2);
          }
        }
        static _createAfter(e2, t2) {
          if (!e2.parent)
            throw new c.a("model-position-after-root", [this, e2], { root: e2 });
          return this._createAt(e2.parent, e2.endOffset, t2);
        }
        static _createBefore(e2, t2) {
          if (!e2.parent)
            throw new c.a("model-position-before-root", e2, { root: e2 });
          return this._createAt(e2.parent, e2.startOffset, t2);
        }
        static fromJSON(e2, t2) {
          if (e2.root === "$graveyard") {
            const i2 = new Xs(t2.graveyard, e2.path);
            return i2.stickiness = e2.stickiness, i2;
          }
          if (!t2.getRoot(e2.root))
            throw new c.a("model-position-fromjson-no-root", t2, { rootName: e2.root });
          return new Xs(t2.getRoot(e2.root), e2.path, e2.stickiness);
        }
      }
      function ea(e2, t2) {
        const i2 = t2.getChild(t2.offsetToIndex(e2.offset));
        return i2 && i2.is("$text") && i2.startOffset < e2.offset ? i2 : null;
      }
      function ta(e2, t2, i2) {
        return i2 !== null ? null : t2.getChild(t2.offsetToIndex(e2.offset));
      }
      function ia(e2, t2, i2) {
        return i2 !== null ? null : t2.getChild(t2.offsetToIndex(e2.offset) - 1);
      }
      class na {
        constructor(e2, t2 = null) {
          this.start = Xs._createAt(e2), this.end = t2 ? Xs._createAt(t2) : Xs._createAt(e2), this.start.stickiness = this.isCollapsed ? "toNone" : "toNext", this.end.stickiness = this.isCollapsed ? "toNone" : "toPrevious";
        }
        *[Symbol.iterator]() {
          yield* new Js({ boundaries: this, ignoreElementEnd: true });
        }
        get isCollapsed() {
          return this.start.isEqual(this.end);
        }
        get isFlat() {
          return cn(this.start.getParentPath(), this.end.getParentPath()) == "same";
        }
        get root() {
          return this.start.root;
        }
        containsPosition(e2) {
          return e2.isAfter(this.start) && e2.isBefore(this.end);
        }
        containsRange(e2, t2 = false) {
          e2.isCollapsed && (t2 = false);
          const i2 = this.containsPosition(e2.start) || t2 && this.start.isEqual(e2.start), n2 = this.containsPosition(e2.end) || t2 && this.end.isEqual(e2.end);
          return i2 && n2;
        }
        containsItem(e2) {
          const t2 = Xs._createBefore(e2);
          return this.containsPosition(t2) || this.start.isEqual(t2);
        }
        is(e2) {
          return e2 === "range" || e2 === "model:range";
        }
        isEqual(e2) {
          return this.start.isEqual(e2.start) && this.end.isEqual(e2.end);
        }
        isIntersecting(e2) {
          return this.start.isBefore(e2.end) && this.end.isAfter(e2.start);
        }
        getDifference(e2) {
          const t2 = [];
          return this.isIntersecting(e2) ? (this.containsPosition(e2.start) && t2.push(new na(this.start, e2.start)), this.containsPosition(e2.end) && t2.push(new na(e2.end, this.end))) : t2.push(new na(this.start, this.end)), t2;
        }
        getIntersection(e2) {
          if (this.isIntersecting(e2)) {
            let t2 = this.start, i2 = this.end;
            return this.containsPosition(e2.start) && (t2 = e2.start), this.containsPosition(e2.end) && (i2 = e2.end), new na(t2, i2);
          }
          return null;
        }
        getJoined(e2, t2 = false) {
          let i2 = this.isIntersecting(e2);
          if (i2 || (i2 = this.start.isBefore(e2.start) ? t2 ? this.end.isTouching(e2.start) : this.end.isEqual(e2.start) : t2 ? e2.end.isTouching(this.start) : e2.end.isEqual(this.start)), !i2)
            return null;
          let n2 = this.start, o2 = this.end;
          return e2.start.isBefore(n2) && (n2 = e2.start), e2.end.isAfter(o2) && (o2 = e2.end), new na(n2, o2);
        }
        getMinimalFlatRanges() {
          const e2 = [], t2 = this.start.getCommonPath(this.end).length, i2 = Xs._createAt(this.start);
          let n2 = i2.parent;
          for (; i2.path.length > t2 + 1; ) {
            const t3 = n2.maxOffset - i2.offset;
            t3 !== 0 && e2.push(new na(i2, i2.getShiftedBy(t3))), i2.path = i2.path.slice(0, -1), i2.offset++, n2 = n2.parent;
          }
          for (; i2.path.length <= this.end.path.length; ) {
            const t3 = this.end.path[i2.path.length - 1], n3 = t3 - i2.offset;
            n3 !== 0 && e2.push(new na(i2, i2.getShiftedBy(n3))), i2.offset = t3, i2.path.push(0);
          }
          return e2;
        }
        getWalker(e2 = {}) {
          return e2.boundaries = this, new Js(e2);
        }
        *getItems(e2 = {}) {
          e2.boundaries = this, e2.ignoreElementEnd = true;
          const t2 = new Js(e2);
          for (const e3 of t2)
            yield e3.item;
        }
        *getPositions(e2 = {}) {
          e2.boundaries = this;
          const t2 = new Js(e2);
          yield t2.position;
          for (const e3 of t2)
            yield e3.nextPosition;
        }
        getTransformedByOperation(e2) {
          switch (e2.type) {
            case "insert":
              return this._getTransformedByInsertOperation(e2);
            case "move":
            case "remove":
            case "reinsert":
              return this._getTransformedByMoveOperation(e2);
            case "split":
              return [this._getTransformedBySplitOperation(e2)];
            case "merge":
              return [this._getTransformedByMergeOperation(e2)];
          }
          return [new na(this.start, this.end)];
        }
        getTransformedByOperations(e2) {
          const t2 = [new na(this.start, this.end)];
          for (const i2 of e2)
            for (let e3 = 0; e3 < t2.length; e3++) {
              const n2 = t2[e3].getTransformedByOperation(i2);
              t2.splice(e3, 1, ...n2), e3 += n2.length - 1;
            }
          for (let e3 = 0; e3 < t2.length; e3++) {
            const i2 = t2[e3];
            for (let n2 = e3 + 1; n2 < t2.length; n2++) {
              const e4 = t2[n2];
              (i2.containsRange(e4) || e4.containsRange(i2) || i2.isEqual(e4)) && t2.splice(n2, 1);
            }
          }
          return t2;
        }
        getCommonAncestor() {
          return this.start.getCommonAncestor(this.end);
        }
        getContainedElement() {
          if (this.isCollapsed)
            return null;
          const e2 = this.start.nodeAfter, t2 = this.end.nodeBefore;
          return e2 && e2.is("element") && e2 === t2 ? e2 : null;
        }
        toJSON() {
          return { start: this.start.toJSON(), end: this.end.toJSON() };
        }
        clone() {
          return new this.constructor(this.start, this.end);
        }
        _getTransformedByInsertOperation(e2, t2 = false) {
          return this._getTransformedByInsertion(e2.position, e2.howMany, t2);
        }
        _getTransformedByMoveOperation(e2, t2 = false) {
          const i2 = e2.sourcePosition, n2 = e2.howMany, o2 = e2.targetPosition;
          return this._getTransformedByMove(i2, o2, n2, t2);
        }
        _getTransformedBySplitOperation(e2) {
          const t2 = this.start._getTransformedBySplitOperation(e2);
          let i2 = this.end._getTransformedBySplitOperation(e2);
          return this.end.isEqual(e2.insertionPosition) && (i2 = this.end.getShiftedBy(1)), t2.root != i2.root && (i2 = this.end.getShiftedBy(-1)), new na(t2, i2);
        }
        _getTransformedByMergeOperation(e2) {
          if (this.start.isEqual(e2.targetPosition) && this.end.isEqual(e2.deletionPosition))
            return new na(this.start);
          let t2 = this.start._getTransformedByMergeOperation(e2), i2 = this.end._getTransformedByMergeOperation(e2);
          return t2.root != i2.root && (i2 = this.end.getShiftedBy(-1)), t2.isAfter(i2) ? (e2.sourcePosition.isBefore(e2.targetPosition) ? (t2 = Xs._createAt(i2), t2.offset = 0) : (e2.deletionPosition.isEqual(t2) || (i2 = e2.deletionPosition), t2 = e2.targetPosition), new na(t2, i2)) : new na(t2, i2);
        }
        _getTransformedByInsertion(e2, t2, i2 = false) {
          if (i2 && this.containsPosition(e2))
            return [new na(this.start, e2), new na(e2.getShiftedBy(t2), this.end._getTransformedByInsertion(e2, t2))];
          {
            const i3 = new na(this.start, this.end);
            return i3.start = i3.start._getTransformedByInsertion(e2, t2), i3.end = i3.end._getTransformedByInsertion(e2, t2), [i3];
          }
        }
        _getTransformedByMove(e2, t2, i2, n2 = false) {
          if (this.isCollapsed) {
            const n3 = this.start._getTransformedByMove(e2, t2, i2);
            return [new na(n3)];
          }
          const o2 = na._createFromPositionAndShift(e2, i2), r2 = t2._getTransformedByDeletion(e2, i2);
          if (this.containsPosition(t2) && !n2 && (o2.containsPosition(this.start) || o2.containsPosition(this.end))) {
            const n3 = this.start._getTransformedByMove(e2, t2, i2), o3 = this.end._getTransformedByMove(e2, t2, i2);
            return [new na(n3, o3)];
          }
          let s2;
          const a2 = this.getDifference(o2);
          let c2 = null;
          const l2 = this.getIntersection(o2);
          if (a2.length == 1 ? c2 = new na(a2[0].start._getTransformedByDeletion(e2, i2), a2[0].end._getTransformedByDeletion(e2, i2)) : a2.length == 2 && (c2 = new na(this.start, this.end._getTransformedByDeletion(e2, i2))), s2 = c2 ? c2._getTransformedByInsertion(r2, i2, l2 !== null || n2) : [], l2) {
            const e3 = new na(l2.start._getCombined(o2.start, r2), l2.end._getCombined(o2.start, r2));
            s2.length == 2 ? s2.splice(1, 0, e3) : s2.push(e3);
          }
          return s2;
        }
        _getTransformedByDeletion(e2, t2) {
          let i2 = this.start._getTransformedByDeletion(e2, t2), n2 = this.end._getTransformedByDeletion(e2, t2);
          return i2 == null && n2 == null ? null : (i2 == null && (i2 = e2), n2 == null && (n2 = e2), new na(i2, n2));
        }
        static _createFromPositionAndShift(e2, t2) {
          const i2 = e2, n2 = e2.getShiftedBy(t2);
          return t2 > 0 ? new this(i2, n2) : new this(n2, i2);
        }
        static _createIn(e2) {
          return new this(Xs._createAt(e2, 0), Xs._createAt(e2, e2.maxOffset));
        }
        static _createOn(e2) {
          return this._createFromPositionAndShift(Xs._createBefore(e2), e2.offsetSize);
        }
        static _createFromRanges(e2) {
          if (e2.length === 0)
            throw new c.a("range-create-from-ranges-empty-array", null);
          if (e2.length == 1)
            return e2[0].clone();
          const t2 = e2[0];
          e2.sort((e3, t3) => e3.start.isAfter(t3.start) ? 1 : -1);
          const i2 = e2.indexOf(t2), n2 = new this(t2.start, t2.end);
          if (i2 > 0)
            for (let t3 = i2 - 1; e2[t3].end.isEqual(n2.start); t3++)
              n2.start = Xs._createAt(e2[t3].start);
          for (let t3 = i2 + 1; t3 < e2.length && e2[t3].start.isEqual(n2.end); t3++)
            n2.end = Xs._createAt(e2[t3].end);
          return n2;
        }
        static fromJSON(e2, t2) {
          return new this(Xs.fromJSON(e2.start, t2), Xs.fromJSON(e2.end, t2));
        }
      }
      class oa {
        constructor() {
          this._modelToViewMapping = new WeakMap(), this._viewToModelMapping = new WeakMap(), this._viewToModelLengthCallbacks = new Map(), this._markerNameToElements = new Map(), this._elementToMarkerNames = new Map(), this._unboundMarkerNames = new Set(), this.on("modelToViewPosition", (e2, t2) => {
            if (t2.viewPosition)
              return;
            const i2 = this._modelToViewMapping.get(t2.modelPosition.parent);
            t2.viewPosition = this.findPositionIn(i2, t2.modelPosition.offset);
          }, { priority: "low" }), this.on("viewToModelPosition", (e2, t2) => {
            if (t2.modelPosition)
              return;
            const i2 = this.findMappedViewAncestor(t2.viewPosition), n2 = this._viewToModelMapping.get(i2), o2 = this._toModelOffset(t2.viewPosition.parent, t2.viewPosition.offset, i2);
            t2.modelPosition = Xs._createAt(n2, o2);
          }, { priority: "low" });
        }
        bindElements(e2, t2) {
          this._modelToViewMapping.set(e2, t2), this._viewToModelMapping.set(t2, e2);
        }
        unbindViewElement(e2) {
          const t2 = this.toModelElement(e2);
          if (this._viewToModelMapping.delete(e2), this._elementToMarkerNames.has(e2))
            for (const t3 of this._elementToMarkerNames.get(e2))
              this._unboundMarkerNames.add(t3);
          this._modelToViewMapping.get(t2) == e2 && this._modelToViewMapping.delete(t2);
        }
        unbindModelElement(e2) {
          const t2 = this.toViewElement(e2);
          this._modelToViewMapping.delete(e2), this._viewToModelMapping.get(t2) == e2 && this._viewToModelMapping.delete(t2);
        }
        bindElementToMarker(e2, t2) {
          const i2 = this._markerNameToElements.get(t2) || new Set();
          i2.add(e2);
          const n2 = this._elementToMarkerNames.get(e2) || new Set();
          n2.add(t2), this._markerNameToElements.set(t2, i2), this._elementToMarkerNames.set(e2, n2);
        }
        unbindElementFromMarkerName(e2, t2) {
          const i2 = this._markerNameToElements.get(t2);
          i2 && (i2.delete(e2), i2.size == 0 && this._markerNameToElements.delete(t2));
          const n2 = this._elementToMarkerNames.get(e2);
          n2 && (n2.delete(t2), n2.size == 0 && this._elementToMarkerNames.delete(e2));
        }
        flushUnboundMarkerNames() {
          const e2 = Array.from(this._unboundMarkerNames);
          return this._unboundMarkerNames.clear(), e2;
        }
        clearBindings() {
          this._modelToViewMapping = new WeakMap(), this._viewToModelMapping = new WeakMap(), this._markerNameToElements = new Map(), this._elementToMarkerNames = new Map(), this._unboundMarkerNames = new Set();
        }
        toModelElement(e2) {
          return this._viewToModelMapping.get(e2);
        }
        toViewElement(e2) {
          return this._modelToViewMapping.get(e2);
        }
        toModelRange(e2) {
          return new na(this.toModelPosition(e2.start), this.toModelPosition(e2.end));
        }
        toViewRange(e2) {
          return new lo(this.toViewPosition(e2.start), this.toViewPosition(e2.end));
        }
        toModelPosition(e2) {
          const t2 = { viewPosition: e2, mapper: this };
          return this.fire("viewToModelPosition", t2), t2.modelPosition;
        }
        toViewPosition(e2, t2 = { isPhantom: false }) {
          const i2 = { modelPosition: e2, mapper: this, isPhantom: t2.isPhantom };
          return this.fire("modelToViewPosition", i2), i2.viewPosition;
        }
        markerNameToElements(e2) {
          const t2 = this._markerNameToElements.get(e2);
          if (!t2)
            return null;
          const i2 = new Set();
          for (const e3 of t2)
            if (e3.is("attributeElement"))
              for (const t3 of e3.getElementsWithSameId())
                i2.add(t3);
            else
              i2.add(e3);
          return i2;
        }
        registerViewToModelLength(e2, t2) {
          this._viewToModelLengthCallbacks.set(e2, t2);
        }
        findMappedViewAncestor(e2) {
          let t2 = e2.parent;
          for (; !this._viewToModelMapping.has(t2); )
            t2 = t2.parent;
          return t2;
        }
        _toModelOffset(e2, t2, i2) {
          if (i2 != e2) {
            return this._toModelOffset(e2.parent, e2.index, i2) + this._toModelOffset(e2, t2, e2);
          }
          if (e2.is("$text"))
            return t2;
          let n2 = 0;
          for (let i3 = 0; i3 < t2; i3++)
            n2 += this.getModelLength(e2.getChild(i3));
          return n2;
        }
        getModelLength(e2) {
          if (this._viewToModelLengthCallbacks.get(e2.name)) {
            return this._viewToModelLengthCallbacks.get(e2.name)(e2);
          }
          if (this._viewToModelMapping.has(e2))
            return 1;
          if (e2.is("$text"))
            return e2.data.length;
          if (e2.is("uiElement"))
            return 0;
          {
            let t2 = 0;
            for (const i2 of e2.getChildren())
              t2 += this.getModelLength(i2);
            return t2;
          }
        }
        findPositionIn(e2, t2) {
          let i2, n2 = 0, o2 = 0, r2 = 0;
          if (e2.is("$text"))
            return new co(e2, t2);
          for (; o2 < t2; )
            i2 = e2.getChild(r2), n2 = this.getModelLength(i2), o2 += n2, r2++;
          return o2 == t2 ? this._moveViewPositionToTextNode(new co(e2, r2)) : this.findPositionIn(i2, t2 - (o2 - n2));
        }
        _moveViewPositionToTextNode(e2) {
          const t2 = e2.nodeBefore, i2 = e2.nodeAfter;
          return t2 instanceof hn ? new co(t2, t2.data.length) : i2 instanceof hn ? new co(i2, 0) : e2;
        }
      }
      Ke(oa, h);
      class ra {
        constructor() {
          this._consumable = new Map(), this._textProxyRegistry = new Map();
        }
        add(e2, t2) {
          t2 = sa(t2), e2 instanceof Gs && (e2 = this._getSymbolForTextProxy(e2)), this._consumable.has(e2) || this._consumable.set(e2, new Map()), this._consumable.get(e2).set(t2, true);
        }
        consume(e2, t2) {
          return t2 = sa(t2), e2 instanceof Gs && (e2 = this._getSymbolForTextProxy(e2)), !!this.test(e2, t2) && (this._consumable.get(e2).set(t2, false), true);
        }
        test(e2, t2) {
          t2 = sa(t2), e2 instanceof Gs && (e2 = this._getSymbolForTextProxy(e2));
          const i2 = this._consumable.get(e2);
          if (i2 === void 0)
            return null;
          const n2 = i2.get(t2);
          return n2 === void 0 ? null : n2;
        }
        revert(e2, t2) {
          t2 = sa(t2), e2 instanceof Gs && (e2 = this._getSymbolForTextProxy(e2));
          const i2 = this.test(e2, t2);
          return i2 === false ? (this._consumable.get(e2).set(t2, true), true) : i2 !== true && null;
        }
        _getSymbolForTextProxy(e2) {
          let t2 = null;
          const i2 = this._textProxyRegistry.get(e2.startOffset);
          if (i2) {
            const n2 = i2.get(e2.endOffset);
            n2 && (t2 = n2.get(e2.parent));
          }
          return t2 || (t2 = this._addSymbolForTextProxy(e2.startOffset, e2.endOffset, e2.parent)), t2;
        }
        _addSymbolForTextProxy(e2, t2, i2) {
          const n2 = Symbol("textProxySymbol");
          let o2, r2;
          return o2 = this._textProxyRegistry.get(e2), o2 || (o2 = new Map(), this._textProxyRegistry.set(e2, o2)), r2 = o2.get(t2), r2 || (r2 = new Map(), o2.set(t2, r2)), r2.set(i2, n2), n2;
        }
      }
      function sa(e2) {
        const t2 = e2.split(":");
        return t2[0] == "addMarker" || t2[0] == "removeMarker" ? e2 : t2.length > 1 ? t2[0] + ":" + t2[1] : t2[0];
      }
      class aa {
        constructor(e2) {
          this.conversionApi = Object.assign({ dispatcher: this }, e2), this._reconversionEventsMapping = new Map();
        }
        convertChanges(e2, t2, i2) {
          for (const t3 of e2.getMarkersToRemove())
            this.convertMarkerRemove(t3.name, t3.range, i2);
          const n2 = this._mapChangesWithAutomaticReconversion(e2);
          for (const e3 of n2)
            e3.type === "insert" ? this.convertInsert(na._createFromPositionAndShift(e3.position, e3.length), i2) : e3.type === "remove" ? this.convertRemove(e3.position, e3.length, e3.name, i2) : e3.type === "reconvert" ? this.reconvertElement(e3.element, i2) : this.convertAttribute(e3.range, e3.attributeKey, e3.attributeOldValue, e3.attributeNewValue, i2);
          for (const e3 of this.conversionApi.mapper.flushUnboundMarkerNames()) {
            const n3 = t2.get(e3).getRange();
            this.convertMarkerRemove(e3, n3, i2), this.convertMarkerAdd(e3, n3, i2);
          }
          for (const t3 of e2.getMarkersToAdd())
            this.convertMarkerAdd(t3.name, t3.range, i2);
        }
        convertInsert(e2, t2) {
          this.conversionApi.writer = t2, this.conversionApi.consumable = this._createInsertConsumable(e2);
          for (const t3 of Array.from(e2).map(la))
            this._convertInsertWithAttributes(t3);
          this._clearConversionApi();
        }
        convertRemove(e2, t2, i2, n2) {
          this.conversionApi.writer = n2, this.fire("remove:" + i2, { position: e2, length: t2 }, this.conversionApi), this._clearConversionApi();
        }
        convertAttribute(e2, t2, i2, n2, o2) {
          this.conversionApi.writer = o2, this.conversionApi.consumable = this._createConsumableForRange(e2, "attribute:" + t2);
          for (const o3 of e2) {
            const e3 = { item: o3.item, range: na._createFromPositionAndShift(o3.previousPosition, o3.length), attributeKey: t2, attributeOldValue: i2, attributeNewValue: n2 };
            this._testAndFire("attribute:" + t2, e3);
          }
          this._clearConversionApi();
        }
        reconvertElement(e2, t2) {
          const i2 = na._createOn(e2);
          this.conversionApi.writer = t2, this.conversionApi.consumable = this._createInsertConsumable(i2);
          const n2 = this.conversionApi.mapper, o2 = n2.toViewElement(e2);
          t2.remove(o2), this._convertInsertWithAttributes({ item: e2, range: i2 });
          const r2 = n2.toViewElement(e2);
          for (const i3 of na._createIn(e2)) {
            const { item: e3 } = i3, o3 = da(e3, n2);
            o3 ? o3.root !== r2.root && t2.move(t2.createRangeOn(o3), n2.toViewPosition(Xs._createBefore(e3))) : this._convertInsertWithAttributes(la(i3));
          }
          n2.unbindViewElement(o2), this._clearConversionApi();
        }
        convertSelection(e2, t2, i2) {
          const n2 = Array.from(t2.getMarkersAtPosition(e2.getFirstPosition()));
          if (this.conversionApi.writer = i2, this.conversionApi.consumable = this._createSelectionConsumable(e2, n2), this.fire("selection", { selection: e2 }, this.conversionApi), e2.isCollapsed) {
            for (const t3 of n2) {
              const i3 = t3.getRange();
              if (!ca(e2.getFirstPosition(), t3, this.conversionApi.mapper))
                continue;
              const n3 = { item: e2, markerName: t3.name, markerRange: i3 };
              this.conversionApi.consumable.test(e2, "addMarker:" + t3.name) && this.fire("addMarker:" + t3.name, n3, this.conversionApi);
            }
            for (const t3 of e2.getAttributeKeys()) {
              const i3 = { item: e2, range: e2.getFirstRange(), attributeKey: t3, attributeOldValue: null, attributeNewValue: e2.getAttribute(t3) };
              this.conversionApi.consumable.test(e2, "attribute:" + i3.attributeKey) && this.fire("attribute:" + i3.attributeKey + ":$text", i3, this.conversionApi);
            }
            this._clearConversionApi();
          } else
            this._clearConversionApi();
        }
        convertMarkerAdd(e2, t2, i2) {
          if (t2.root.rootName == "$graveyard")
            return;
          this.conversionApi.writer = i2;
          const n2 = "addMarker:" + e2, o2 = new ra();
          if (o2.add(t2, n2), this.conversionApi.consumable = o2, this.fire(n2, { markerName: e2, markerRange: t2 }, this.conversionApi), o2.test(t2, n2)) {
            this.conversionApi.consumable = this._createConsumableForRange(t2, n2);
            for (const i3 of t2.getItems()) {
              if (!this.conversionApi.consumable.test(i3, n2))
                continue;
              const o3 = { item: i3, range: na._createOn(i3), markerName: e2, markerRange: t2 };
              this.fire(n2, o3, this.conversionApi);
            }
            this._clearConversionApi();
          } else
            this._clearConversionApi();
        }
        convertMarkerRemove(e2, t2, i2) {
          t2.root.rootName != "$graveyard" && (this.conversionApi.writer = i2, this.fire("removeMarker:" + e2, { markerName: e2, markerRange: t2 }, this.conversionApi), this._clearConversionApi());
        }
        _mapReconversionTriggerEvent(e2, t2) {
          this._reconversionEventsMapping.set(t2, e2);
        }
        _createInsertConsumable(e2) {
          const t2 = new ra();
          for (const i2 of e2) {
            const e3 = i2.item;
            t2.add(e3, "insert");
            for (const i3 of e3.getAttributeKeys())
              t2.add(e3, "attribute:" + i3);
          }
          return t2;
        }
        _createConsumableForRange(e2, t2) {
          const i2 = new ra();
          for (const n2 of e2.getItems())
            i2.add(n2, t2);
          return i2;
        }
        _createSelectionConsumable(e2, t2) {
          const i2 = new ra();
          i2.add(e2, "selection");
          for (const n2 of t2)
            i2.add(e2, "addMarker:" + n2.name);
          for (const t3 of e2.getAttributeKeys())
            i2.add(e2, "attribute:" + t3);
          return i2;
        }
        _testAndFire(e2, t2) {
          this.conversionApi.consumable.test(t2.item, e2) && this.fire(function(e3, t3) {
            const i2 = t3.item.name || "$text";
            return `${e3}:${i2}`;
          }(e2, t2), t2, this.conversionApi);
        }
        _clearConversionApi() {
          delete this.conversionApi.writer, delete this.conversionApi.consumable;
        }
        _convertInsertWithAttributes(e2) {
          this._testAndFire("insert", e2);
          for (const t2 of e2.item.getAttributeKeys())
            e2.attributeKey = t2, e2.attributeOldValue = null, e2.attributeNewValue = e2.item.getAttribute(t2), this._testAndFire("attribute:" + t2, e2);
        }
        _mapChangesWithAutomaticReconversion(e2) {
          const t2 = new Set(), i2 = [];
          for (const n2 of e2.getChanges()) {
            const e3 = n2.position || n2.range.start, o2 = e3.parent;
            if (ea(e3, o2)) {
              i2.push(n2);
              continue;
            }
            const r2 = n2.type === "attribute" ? ta(e3, o2, null) : o2;
            if (r2.is("$text")) {
              i2.push(n2);
              continue;
            }
            let s2;
            if (s2 = n2.type === "attribute" ? `attribute:${n2.attributeKey}:${r2.name}` : `${n2.type}:${n2.name}`, this._isReconvertTriggerEvent(s2, r2.name)) {
              if (t2.has(r2))
                continue;
              t2.add(r2), i2.push({ type: "reconvert", element: r2 });
            } else
              i2.push(n2);
          }
          return i2;
        }
        _isReconvertTriggerEvent(e2, t2) {
          return this._reconversionEventsMapping.get(e2) === t2;
        }
      }
      function ca(e2, t2, i2) {
        const n2 = t2.getRange(), o2 = Array.from(e2.getAncestors());
        o2.shift(), o2.reverse();
        return !o2.some((e3) => {
          if (n2.containsItem(e3)) {
            return !!i2.toViewElement(e3).getCustomProperty("addHighlight");
          }
        });
      }
      function la(e2) {
        return { item: e2.item, range: na._createFromPositionAndShift(e2.previousPosition, e2.length) };
      }
      function da(e2, t2) {
        if (e2.is("textProxy")) {
          const i2 = t2.toViewPosition(Xs._createBefore(e2)).parent;
          return i2.is("$text") ? i2 : null;
        }
        return t2.toViewElement(e2);
      }
      Ke(aa, h);
      class ha {
        constructor(e2, t2, i2) {
          this._lastRangeBackward = false, this._ranges = [], this._attrs = new Map(), e2 && this.setTo(e2, t2, i2);
        }
        get anchor() {
          if (this._ranges.length > 0) {
            const e2 = this._ranges[this._ranges.length - 1];
            return this._lastRangeBackward ? e2.end : e2.start;
          }
          return null;
        }
        get focus() {
          if (this._ranges.length > 0) {
            const e2 = this._ranges[this._ranges.length - 1];
            return this._lastRangeBackward ? e2.start : e2.end;
          }
          return null;
        }
        get isCollapsed() {
          return this._ranges.length === 1 && this._ranges[0].isCollapsed;
        }
        get rangeCount() {
          return this._ranges.length;
        }
        get isBackward() {
          return !this.isCollapsed && this._lastRangeBackward;
        }
        isEqual(e2) {
          if (this.rangeCount != e2.rangeCount)
            return false;
          if (this.rangeCount === 0)
            return true;
          if (!this.anchor.isEqual(e2.anchor) || !this.focus.isEqual(e2.focus))
            return false;
          for (const t2 of this._ranges) {
            let i2 = false;
            for (const n2 of e2._ranges)
              if (t2.isEqual(n2)) {
                i2 = true;
                break;
              }
            if (!i2)
              return false;
          }
          return true;
        }
        *getRanges() {
          for (const e2 of this._ranges)
            yield new na(e2.start, e2.end);
        }
        getFirstRange() {
          let e2 = null;
          for (const t2 of this._ranges)
            e2 && !t2.start.isBefore(e2.start) || (e2 = t2);
          return e2 ? new na(e2.start, e2.end) : null;
        }
        getLastRange() {
          let e2 = null;
          for (const t2 of this._ranges)
            e2 && !t2.end.isAfter(e2.end) || (e2 = t2);
          return e2 ? new na(e2.start, e2.end) : null;
        }
        getFirstPosition() {
          const e2 = this.getFirstRange();
          return e2 ? e2.start.clone() : null;
        }
        getLastPosition() {
          const e2 = this.getLastRange();
          return e2 ? e2.end.clone() : null;
        }
        setTo(e2, t2, i2) {
          if (e2 === null)
            this._setRanges([]);
          else if (e2 instanceof ha)
            this._setRanges(e2.getRanges(), e2.isBackward);
          else if (e2 && typeof e2.getRanges == "function")
            this._setRanges(e2.getRanges(), e2.isBackward);
          else if (e2 instanceof na)
            this._setRanges([e2], !!t2 && !!t2.backward);
          else if (e2 instanceof Xs)
            this._setRanges([new na(e2)]);
          else if (e2 instanceof $s) {
            const n2 = !!i2 && !!i2.backward;
            let o2;
            if (t2 == "in")
              o2 = na._createIn(e2);
            else if (t2 == "on")
              o2 = na._createOn(e2);
            else {
              if (t2 === void 0)
                throw new c.a("model-selection-setto-required-second-parameter", [this, e2]);
              o2 = new na(Xs._createAt(e2, t2));
            }
            this._setRanges([o2], n2);
          } else {
            if (!Ji(e2))
              throw new c.a("model-selection-setto-not-selectable", [this, e2]);
            this._setRanges(e2, t2 && !!t2.backward);
          }
        }
        _setRanges(e2, t2 = false) {
          const i2 = (e2 = Array.from(e2)).some((t3) => {
            if (!(t3 instanceof na))
              throw new c.a("model-selection-set-ranges-not-range", [this, e2]);
            return this._ranges.every((e3) => !e3.isEqual(t3));
          });
          if (e2.length !== this._ranges.length || i2) {
            this._removeAllRanges();
            for (const t3 of e2)
              this._pushRange(t3);
            this._lastRangeBackward = !!t2, this.fire("change:range", { directChange: true });
          }
        }
        setFocus(e2, t2) {
          if (this.anchor === null)
            throw new c.a("model-selection-setfocus-no-ranges", [this, e2]);
          const i2 = Xs._createAt(e2, t2);
          if (i2.compareWith(this.focus) == "same")
            return;
          const n2 = this.anchor;
          this._ranges.length && this._popRange(), i2.compareWith(n2) == "before" ? (this._pushRange(new na(i2, n2)), this._lastRangeBackward = true) : (this._pushRange(new na(n2, i2)), this._lastRangeBackward = false), this.fire("change:range", { directChange: true });
        }
        getAttribute(e2) {
          return this._attrs.get(e2);
        }
        getAttributes() {
          return this._attrs.entries();
        }
        getAttributeKeys() {
          return this._attrs.keys();
        }
        hasAttribute(e2) {
          return this._attrs.has(e2);
        }
        removeAttribute(e2) {
          this.hasAttribute(e2) && (this._attrs.delete(e2), this.fire("change:attribute", { attributeKeys: [e2], directChange: true }));
        }
        setAttribute(e2, t2) {
          this.getAttribute(e2) !== t2 && (this._attrs.set(e2, t2), this.fire("change:attribute", { attributeKeys: [e2], directChange: true }));
        }
        getSelectedElement() {
          return this.rangeCount !== 1 ? null : this.getFirstRange().getContainedElement();
        }
        is(e2) {
          return e2 === "selection" || e2 === "model:selection";
        }
        *getSelectedBlocks() {
          const e2 = new WeakSet();
          for (const t2 of this.getRanges()) {
            const i2 = ma(t2.start, e2);
            i2 && fa(i2, t2) && (yield i2);
            for (const i3 of t2.getWalker()) {
              const n3 = i3.item;
              i3.type == "elementEnd" && ga(n3, e2, t2) && (yield n3);
            }
            const n2 = ma(t2.end, e2);
            n2 && !t2.end.isTouching(Xs._createAt(n2, 0)) && fa(n2, t2) && (yield n2);
          }
        }
        containsEntireContent(e2 = this.anchor.root) {
          const t2 = Xs._createAt(e2, 0), i2 = Xs._createAt(e2, "end");
          return t2.isTouching(this.getFirstPosition()) && i2.isTouching(this.getLastPosition());
        }
        _pushRange(e2) {
          this._checkRange(e2), this._ranges.push(new na(e2.start, e2.end));
        }
        _checkRange(e2) {
          for (let t2 = 0; t2 < this._ranges.length; t2++)
            if (e2.isIntersecting(this._ranges[t2]))
              throw new c.a("model-selection-range-intersects", [this, e2], { addedRange: e2, intersectingRange: this._ranges[t2] });
        }
        _removeAllRanges() {
          for (; this._ranges.length > 0; )
            this._popRange();
        }
        _popRange() {
          this._ranges.pop();
        }
      }
      function ua(e2, t2) {
        return !t2.has(e2) && (t2.add(e2), e2.root.document.model.schema.isBlock(e2) && e2.parent);
      }
      function ga(e2, t2, i2) {
        return ua(e2, t2) && fa(e2, i2);
      }
      function ma(e2, t2) {
        const i2 = e2.parent.root.document.model.schema, n2 = e2.parent.getAncestors({ parentFirst: true, includeSelf: true });
        let o2 = false;
        const r2 = n2.find((e3) => !o2 && (o2 = i2.isLimit(e3), !o2 && ua(e3, t2)));
        return n2.forEach((e3) => t2.add(e3)), r2;
      }
      function fa(e2, t2) {
        const i2 = function(e3) {
          const t3 = e3.root.document.model.schema;
          let i3 = e3.parent;
          for (; i3; ) {
            if (t3.isBlock(i3))
              return i3;
            i3 = i3.parent;
          }
        }(e2);
        if (!i2)
          return true;
        return !t2.containsRange(na._createOn(i2), true);
      }
      Ke(ha, h);
      class pa extends na {
        constructor(e2, t2) {
          super(e2, t2), ba.call(this);
        }
        detach() {
          this.stopListening();
        }
        is(e2) {
          return e2 === "liveRange" || e2 === "model:liveRange" || e2 == "range" || e2 === "model:range";
        }
        toRange() {
          return new na(this.start, this.end);
        }
        static fromRange(e2) {
          return new pa(e2.start, e2.end);
        }
      }
      function ba() {
        this.listenTo(this.root.document.model, "applyOperation", (e2, t2) => {
          const i2 = t2[0];
          i2.isDocumentOperation && wa.call(this, i2);
        }, { priority: "low" });
      }
      function wa(e2) {
        const t2 = this.getTransformedByOperation(e2), i2 = na._createFromRanges(t2), n2 = !i2.isEqual(this), o2 = function(e3, t3) {
          switch (t3.type) {
            case "insert":
              return e3.containsPosition(t3.position);
            case "move":
            case "remove":
            case "reinsert":
            case "merge":
              return e3.containsPosition(t3.sourcePosition) || e3.start.isEqual(t3.sourcePosition) || e3.containsPosition(t3.targetPosition);
            case "split":
              return e3.containsPosition(t3.splitPosition) || e3.containsPosition(t3.insertionPosition);
          }
          return false;
        }(this, e2);
        let r2 = null;
        if (n2) {
          i2.root.rootName == "$graveyard" && (r2 = e2.type == "remove" ? e2.sourcePosition : e2.deletionPosition);
          const t3 = this.toRange();
          this.start = i2.start, this.end = i2.end, this.fire("change:range", t3, { deletionPosition: r2 });
        } else
          o2 && this.fire("change:content", this.toRange(), { deletionPosition: r2 });
      }
      Ke(pa, h);
      class ka {
        constructor(e2) {
          this._selection = new _a(e2), this._selection.delegate("change:range").to(this), this._selection.delegate("change:attribute").to(this), this._selection.delegate("change:marker").to(this);
        }
        get isCollapsed() {
          return this._selection.isCollapsed;
        }
        get anchor() {
          return this._selection.anchor;
        }
        get focus() {
          return this._selection.focus;
        }
        get rangeCount() {
          return this._selection.rangeCount;
        }
        get hasOwnRange() {
          return this._selection.hasOwnRange;
        }
        get isBackward() {
          return this._selection.isBackward;
        }
        get isGravityOverridden() {
          return this._selection.isGravityOverridden;
        }
        get markers() {
          return this._selection.markers;
        }
        get _ranges() {
          return this._selection._ranges;
        }
        getRanges() {
          return this._selection.getRanges();
        }
        getFirstPosition() {
          return this._selection.getFirstPosition();
        }
        getLastPosition() {
          return this._selection.getLastPosition();
        }
        getFirstRange() {
          return this._selection.getFirstRange();
        }
        getLastRange() {
          return this._selection.getLastRange();
        }
        getSelectedBlocks() {
          return this._selection.getSelectedBlocks();
        }
        getSelectedElement() {
          return this._selection.getSelectedElement();
        }
        containsEntireContent(e2) {
          return this._selection.containsEntireContent(e2);
        }
        destroy() {
          this._selection.destroy();
        }
        getAttributeKeys() {
          return this._selection.getAttributeKeys();
        }
        getAttributes() {
          return this._selection.getAttributes();
        }
        getAttribute(e2) {
          return this._selection.getAttribute(e2);
        }
        hasAttribute(e2) {
          return this._selection.hasAttribute(e2);
        }
        refresh() {
          this._selection._updateMarkers(), this._selection._updateAttributes(false);
        }
        observeMarkers(e2) {
          this._selection.observeMarkers(e2);
        }
        is(e2) {
          return e2 === "selection" || e2 == "model:selection" || e2 == "documentSelection" || e2 == "model:documentSelection";
        }
        _setFocus(e2, t2) {
          this._selection.setFocus(e2, t2);
        }
        _setTo(e2, t2, i2) {
          this._selection.setTo(e2, t2, i2);
        }
        _setAttribute(e2, t2) {
          this._selection.setAttribute(e2, t2);
        }
        _removeAttribute(e2) {
          this._selection.removeAttribute(e2);
        }
        _getStoredAttributes() {
          return this._selection._getStoredAttributes();
        }
        _overrideGravity() {
          return this._selection.overrideGravity();
        }
        _restoreGravity(e2) {
          this._selection.restoreGravity(e2);
        }
        static _getStoreAttributeKey(e2) {
          return "selection:" + e2;
        }
        static _isStoreAttributeKey(e2) {
          return e2.startsWith("selection:");
        }
      }
      Ke(ka, h);
      class _a extends ha {
        constructor(e2) {
          super(), this.markers = new Zi({ idProperty: "name" }), this._model = e2.model, this._document = e2, this._attributePriority = new Map(), this._selectionRestorePosition = null, this._hasChangedRange = false, this._overriddenGravityRegister = new Set(), this._observedMarkers = new Set(), this.listenTo(this._model, "applyOperation", (e3, t2) => {
            const i2 = t2[0];
            i2.isDocumentOperation && i2.type != "marker" && i2.type != "rename" && i2.type != "noop" && (this._ranges.length == 0 && this._selectionRestorePosition && this._fixGraveyardSelection(this._selectionRestorePosition), this._selectionRestorePosition = null, this._hasChangedRange && (this._hasChangedRange = false, this.fire("change:range", { directChange: false })));
          }, { priority: "lowest" }), this.on("change:range", () => {
            for (const e3 of this.getRanges())
              if (!this._document._validateSelectionRange(e3))
                throw new c.a("document-selection-wrong-position", this, { range: e3 });
          }), this.listenTo(this._model.markers, "update", (e3, t2, i2, n2) => {
            this._updateMarker(t2, n2);
          }), this.listenTo(this._document, "change", (e3, t2) => {
            !function(e4, t3) {
              const i2 = e4.document.differ;
              for (const n2 of i2.getChanges()) {
                if (n2.type != "insert")
                  continue;
                const i3 = n2.position.parent;
                n2.length === i3.maxOffset && e4.enqueueChange(t3, (e5) => {
                  const t4 = Array.from(i3.getAttributeKeys()).filter((e6) => e6.startsWith("selection:"));
                  for (const n3 of t4)
                    e5.removeAttribute(n3, i3);
                });
              }
            }(this._model, t2);
          });
        }
        get isCollapsed() {
          return this._ranges.length === 0 ? this._document._getDefaultRange().isCollapsed : super.isCollapsed;
        }
        get anchor() {
          return super.anchor || this._document._getDefaultRange().start;
        }
        get focus() {
          return super.focus || this._document._getDefaultRange().end;
        }
        get rangeCount() {
          return this._ranges.length ? this._ranges.length : 1;
        }
        get hasOwnRange() {
          return this._ranges.length > 0;
        }
        get isGravityOverridden() {
          return !!this._overriddenGravityRegister.size;
        }
        destroy() {
          for (let e2 = 0; e2 < this._ranges.length; e2++)
            this._ranges[e2].detach();
          this.stopListening();
        }
        *getRanges() {
          this._ranges.length ? yield* super.getRanges() : yield this._document._getDefaultRange();
        }
        getFirstRange() {
          return super.getFirstRange() || this._document._getDefaultRange();
        }
        getLastRange() {
          return super.getLastRange() || this._document._getDefaultRange();
        }
        setTo(e2, t2, i2) {
          super.setTo(e2, t2, i2), this._updateAttributes(true), this._updateMarkers();
        }
        setFocus(e2, t2) {
          super.setFocus(e2, t2), this._updateAttributes(true), this._updateMarkers();
        }
        setAttribute(e2, t2) {
          if (this._setAttribute(e2, t2)) {
            const t3 = [e2];
            this.fire("change:attribute", { attributeKeys: t3, directChange: true });
          }
        }
        removeAttribute(e2) {
          if (this._removeAttribute(e2)) {
            const t2 = [e2];
            this.fire("change:attribute", { attributeKeys: t2, directChange: true });
          }
        }
        overrideGravity() {
          const e2 = s();
          return this._overriddenGravityRegister.add(e2), this._overriddenGravityRegister.size === 1 && this._updateAttributes(true), e2;
        }
        restoreGravity(e2) {
          if (!this._overriddenGravityRegister.has(e2))
            throw new c.a("document-selection-gravity-wrong-restore", this, { uid: e2 });
          this._overriddenGravityRegister.delete(e2), this.isGravityOverridden || this._updateAttributes(true);
        }
        observeMarkers(e2) {
          this._observedMarkers.add(e2), this._updateMarkers();
        }
        _popRange() {
          this._ranges.pop().detach();
        }
        _pushRange(e2) {
          const t2 = this._prepareRange(e2);
          t2 && this._ranges.push(t2);
        }
        _prepareRange(e2) {
          if (this._checkRange(e2), e2.root == this._document.graveyard)
            return;
          const t2 = pa.fromRange(e2);
          return t2.on("change:range", (e3, i2, n2) => {
            if (this._hasChangedRange = true, t2.root == this._document.graveyard) {
              this._selectionRestorePosition = n2.deletionPosition;
              const e4 = this._ranges.indexOf(t2);
              this._ranges.splice(e4, 1), t2.detach();
            }
          }), t2;
        }
        _updateMarkers() {
          if (!this._observedMarkers.size)
            return;
          const e2 = [];
          let t2 = false;
          for (const t3 of this._model.markers) {
            const i3 = t3.name.split(":", 1)[0];
            if (!this._observedMarkers.has(i3))
              continue;
            const n2 = t3.getRange();
            for (const i4 of this.getRanges())
              n2.containsRange(i4, !i4.isCollapsed) && e2.push(t3);
          }
          const i2 = Array.from(this.markers);
          for (const i3 of e2)
            this.markers.has(i3) || (this.markers.add(i3), t2 = true);
          for (const i3 of Array.from(this.markers))
            e2.includes(i3) || (this.markers.remove(i3), t2 = true);
          t2 && this.fire("change:marker", { oldMarkers: i2, directChange: false });
        }
        _updateMarker(e2, t2) {
          const i2 = e2.name.split(":", 1)[0];
          if (!this._observedMarkers.has(i2))
            return;
          let n2 = false;
          const o2 = Array.from(this.markers), r2 = this.markers.has(e2);
          if (t2) {
            let i3 = false;
            for (const e3 of this.getRanges())
              if (t2.containsRange(e3, !e3.isCollapsed)) {
                i3 = true;
                break;
              }
            i3 && !r2 ? (this.markers.add(e2), n2 = true) : !i3 && r2 && (this.markers.remove(e2), n2 = true);
          } else
            r2 && (this.markers.remove(e2), n2 = true);
          n2 && this.fire("change:marker", { oldMarkers: o2, directChange: false });
        }
        _updateAttributes(e2) {
          const t2 = gn(this._getSurroundingAttributes()), i2 = gn(this.getAttributes());
          if (e2)
            this._attributePriority = new Map(), this._attrs = new Map();
          else
            for (const [e3, t3] of this._attributePriority)
              t3 == "low" && (this._attrs.delete(e3), this._attributePriority.delete(e3));
          this._setAttributesTo(t2);
          const n2 = [];
          for (const [e3, t3] of this.getAttributes())
            i2.has(e3) && i2.get(e3) === t3 || n2.push(e3);
          for (const [e3] of i2)
            this.hasAttribute(e3) || n2.push(e3);
          n2.length > 0 && this.fire("change:attribute", { attributeKeys: n2, directChange: false });
        }
        _setAttribute(e2, t2, i2 = true) {
          const n2 = i2 ? "normal" : "low";
          if (n2 == "low" && this._attributePriority.get(e2) == "normal")
            return false;
          return super.getAttribute(e2) !== t2 && (this._attrs.set(e2, t2), this._attributePriority.set(e2, n2), true);
        }
        _removeAttribute(e2, t2 = true) {
          const i2 = t2 ? "normal" : "low";
          return (i2 != "low" || this._attributePriority.get(e2) != "normal") && (this._attributePriority.set(e2, i2), !!super.hasAttribute(e2) && (this._attrs.delete(e2), true));
        }
        _setAttributesTo(e2) {
          const t2 = new Set();
          for (const [t3, i2] of this.getAttributes())
            e2.get(t3) !== i2 && this._removeAttribute(t3, false);
          for (const [i2, n2] of e2) {
            this._setAttribute(i2, n2, false) && t2.add(i2);
          }
          return t2;
        }
        *_getStoredAttributes() {
          const e2 = this.getFirstPosition().parent;
          if (this.isCollapsed && e2.isEmpty) {
            for (const t2 of e2.getAttributeKeys())
              if (t2.startsWith("selection:")) {
                const i2 = t2.substr("selection:".length);
                yield [i2, e2.getAttribute(t2)];
              }
          }
        }
        _getSurroundingAttributes() {
          const e2 = this.getFirstPosition(), t2 = this._model.schema;
          let i2 = null;
          if (this.isCollapsed) {
            const n2 = e2.textNode ? e2.textNode : e2.nodeBefore, o2 = e2.textNode ? e2.textNode : e2.nodeAfter;
            if (this.isGravityOverridden || (i2 = va(n2)), i2 || (i2 = va(o2)), !this.isGravityOverridden && !i2) {
              let e3 = n2;
              for (; e3 && !t2.isInline(e3) && !i2; )
                e3 = e3.previousSibling, i2 = va(e3);
            }
            if (!i2) {
              let e3 = o2;
              for (; e3 && !t2.isInline(e3) && !i2; )
                e3 = e3.nextSibling, i2 = va(e3);
            }
            i2 || (i2 = this._getStoredAttributes());
          } else {
            const e3 = this.getFirstRange();
            for (const n2 of e3) {
              if (n2.item.is("element") && t2.isObject(n2.item))
                break;
              if (n2.type == "text") {
                i2 = n2.item.getAttributes();
                break;
              }
            }
          }
          return i2;
        }
        _fixGraveyardSelection(e2) {
          const t2 = this._model.schema.getNearestSelectionRange(e2);
          t2 && this._pushRange(t2);
        }
      }
      function va(e2) {
        return e2 instanceof Gs || e2 instanceof Ys ? e2.getAttributes() : null;
      }
      class ya {
        constructor(e2) {
          this._dispatchers = e2;
        }
        add(e2) {
          for (const t2 of this._dispatchers)
            e2(t2);
          return this;
        }
      }
      var xa = function(e2) {
        return qi(e2, 5);
      };
      class Aa extends ya {
        elementToElement(e2) {
          return this.add(function(e3) {
            return (e3 = xa(e3)).view = Ea(e3.view, "container"), (t2) => {
              var i2;
              if (t2.on("insert:" + e3.model, (i2 = e3.view, (e4, t3, n2) => {
                const o2 = i2(t3.item, n2);
                if (!o2)
                  return;
                if (!n2.consumable.consume(t3.item, "insert"))
                  return;
                const r2 = n2.mapper.toViewPosition(t3.range.start);
                n2.mapper.bindElements(t3.item, o2), n2.writer.insert(r2, o2);
              }), { priority: e3.converterPriority || "normal" }), e3.triggerBy) {
                if (e3.triggerBy.attributes)
                  for (const i3 of e3.triggerBy.attributes)
                    t2._mapReconversionTriggerEvent(e3.model, `attribute:${i3}:${e3.model}`);
                if (e3.triggerBy.children)
                  for (const i3 of e3.triggerBy.children)
                    t2._mapReconversionTriggerEvent(e3.model, "insert:" + i3), t2._mapReconversionTriggerEvent(e3.model, "remove:" + i3);
              }
            };
          }(e2));
        }
        attributeToElement(e2) {
          return this.add(function(e3) {
            e3 = xa(e3);
            let t2 = "attribute:" + (e3.model.key ? e3.model.key : e3.model);
            e3.model.name && (t2 += ":" + e3.model.name);
            if (e3.model.values)
              for (const t3 of e3.model.values)
                e3.view[t3] = Ea(e3.view[t3], "attribute");
            else
              e3.view = Ea(e3.view, "attribute");
            const i2 = Ia(e3);
            return (n2) => {
              n2.on(t2, function(e4) {
                return (t3, i3, n3) => {
                  const o2 = e4(i3.attributeOldValue, n3), r2 = e4(i3.attributeNewValue, n3);
                  if (!o2 && !r2)
                    return;
                  if (!n3.consumable.consume(i3.item, t3.name))
                    return;
                  const s2 = n3.writer, a2 = s2.document.selection;
                  if (i3.item instanceof ha || i3.item instanceof ka)
                    s2.wrap(a2.getFirstRange(), r2);
                  else {
                    let e5 = n3.mapper.toViewRange(i3.range);
                    i3.attributeOldValue !== null && o2 && (e5 = s2.unwrap(e5, o2)), i3.attributeNewValue !== null && r2 && s2.wrap(e5, r2);
                  }
                };
              }(i2), { priority: e3.converterPriority || "normal" });
            };
          }(e2));
        }
        attributeToAttribute(e2) {
          return this.add(function(e3) {
            e3 = xa(e3);
            let t2 = "attribute:" + (e3.model.key ? e3.model.key : e3.model);
            e3.model.name && (t2 += ":" + e3.model.name);
            if (e3.model.values)
              for (const t3 of e3.model.values)
                e3.view[t3] = Sa(e3.view[t3]);
            else
              e3.view = Sa(e3.view);
            const i2 = Ia(e3);
            return (n2) => {
              var o2;
              n2.on(t2, (o2 = i2, (e4, t3, i3) => {
                const n3 = o2(t3.attributeOldValue, i3), r2 = o2(t3.attributeNewValue, i3);
                if (!n3 && !r2)
                  return;
                if (!i3.consumable.consume(t3.item, e4.name))
                  return;
                const s2 = i3.mapper.toViewElement(t3.item), a2 = i3.writer;
                if (!s2)
                  throw new c.a("conversion-attribute-to-attribute-on-text", [t3, i3]);
                if (t3.attributeOldValue !== null && n3)
                  if (n3.key == "class") {
                    const e5 = en(n3.value);
                    for (const t4 of e5)
                      a2.removeClass(t4, s2);
                  } else if (n3.key == "style") {
                    const e5 = Object.keys(n3.value);
                    for (const t4 of e5)
                      a2.removeStyle(t4, s2);
                  } else
                    a2.removeAttribute(n3.key, s2);
                if (t3.attributeNewValue !== null && r2)
                  if (r2.key == "class") {
                    const e5 = en(r2.value);
                    for (const t4 of e5)
                      a2.addClass(t4, s2);
                  } else if (r2.key == "style") {
                    const e5 = Object.keys(r2.value);
                    for (const t4 of e5)
                      a2.setStyle(t4, r2.value[t4], s2);
                  } else
                    a2.setAttribute(r2.key, r2.value, s2);
              }), { priority: e3.converterPriority || "normal" });
            };
          }(e2));
        }
        markerToElement(e2) {
          return this.add(function(e3) {
            return (e3 = xa(e3)).view = Ea(e3.view, "ui"), (t2) => {
              var i2;
              t2.on("addMarker:" + e3.model, (i2 = e3.view, (e4, t3, n2) => {
                t3.isOpening = true;
                const o2 = i2(t3, n2);
                t3.isOpening = false;
                const r2 = i2(t3, n2);
                if (!o2 || !r2)
                  return;
                const s2 = t3.markerRange;
                if (s2.isCollapsed && !n2.consumable.consume(s2, e4.name))
                  return;
                for (const t4 of s2)
                  if (!n2.consumable.consume(t4.item, e4.name))
                    return;
                const a2 = n2.mapper, c2 = n2.writer;
                c2.insert(a2.toViewPosition(s2.start), o2), n2.mapper.bindElementToMarker(o2, t3.markerName), s2.isCollapsed || (c2.insert(a2.toViewPosition(s2.end), r2), n2.mapper.bindElementToMarker(r2, t3.markerName)), e4.stop();
              }), { priority: e3.converterPriority || "normal" }), t2.on("removeMarker:" + e3.model, (e3.view, (e4, t3, i3) => {
                const n2 = i3.mapper.markerNameToElements(t3.markerName);
                if (n2) {
                  for (const e5 of n2)
                    i3.mapper.unbindElementFromMarkerName(e5, t3.markerName), i3.writer.clear(i3.writer.createRangeOn(e5), e5);
                  i3.writer.clearClonedElementsGroup(t3.markerName), e4.stop();
                }
              }), { priority: e3.converterPriority || "normal" });
            };
          }(e2));
        }
        markerToHighlight(e2) {
          return this.add(function(e3) {
            return (t2) => {
              var i2;
              t2.on("addMarker:" + e3.model, (i2 = e3.view, (e4, t3, n2) => {
                if (!t3.item)
                  return;
                if (!(t3.item instanceof ha || t3.item instanceof ka || t3.item.is("$textProxy")))
                  return;
                const o2 = Pa(i2, t3, n2);
                if (!o2)
                  return;
                if (!n2.consumable.consume(t3.item, e4.name))
                  return;
                const r2 = n2.writer, s2 = Ca(r2, o2), a2 = r2.document.selection;
                if (t3.item instanceof ha || t3.item instanceof ka)
                  r2.wrap(a2.getFirstRange(), s2, a2);
                else {
                  const e5 = n2.mapper.toViewRange(t3.range), i3 = r2.wrap(e5, s2);
                  for (const e6 of i3.getItems())
                    if (e6.is("attributeElement") && e6.isSimilar(s2)) {
                      n2.mapper.bindElementToMarker(e6, t3.markerName);
                      break;
                    }
                }
              }), { priority: e3.converterPriority || "normal" }), t2.on("addMarker:" + e3.model, function(e4) {
                return (t3, i3, n2) => {
                  if (!i3.item)
                    return;
                  if (!(i3.item instanceof Qs))
                    return;
                  const o2 = Pa(e4, i3, n2);
                  if (!o2)
                    return;
                  if (!n2.consumable.test(i3.item, t3.name))
                    return;
                  const r2 = n2.mapper.toViewElement(i3.item);
                  if (r2 && r2.getCustomProperty("addHighlight")) {
                    n2.consumable.consume(i3.item, t3.name);
                    for (const e5 of na._createIn(i3.item))
                      n2.consumable.consume(e5.item, t3.name);
                    r2.getCustomProperty("addHighlight")(r2, o2, n2.writer), n2.mapper.bindElementToMarker(r2, i3.markerName);
                  }
                };
              }(e3.view), { priority: e3.converterPriority || "normal" }), t2.on("removeMarker:" + e3.model, function(e4) {
                return (t3, i3, n2) => {
                  if (i3.markerRange.isCollapsed)
                    return;
                  const o2 = Pa(e4, i3, n2);
                  if (!o2)
                    return;
                  const r2 = Ca(n2.writer, o2), s2 = n2.mapper.markerNameToElements(i3.markerName);
                  if (s2) {
                    for (const e5 of s2)
                      n2.mapper.unbindElementFromMarkerName(e5, i3.markerName), e5.is("attributeElement") ? n2.writer.unwrap(n2.writer.createRangeOn(e5), r2) : e5.getCustomProperty("removeHighlight")(e5, o2.id, n2.writer);
                    n2.writer.clearClonedElementsGroup(i3.markerName), t3.stop();
                  }
                };
              }(e3.view), { priority: e3.converterPriority || "normal" });
            };
          }(e2));
        }
        markerToData(e2) {
          return this.add(function(e3) {
            const t2 = (e3 = xa(e3)).model;
            e3.view || (e3.view = (i2) => ({ group: t2, name: i2.substr(e3.model.length + 1) }));
            return (i2) => {
              var n2;
              i2.on("addMarker:" + t2, (n2 = e3.view, (e4, t3, i3) => {
                const o2 = n2(t3.markerName, i3);
                if (!o2)
                  return;
                const r2 = t3.markerRange;
                i3.consumable.consume(r2, e4.name) && (Ta(r2, false, i3, t3, o2), Ta(r2, true, i3, t3, o2), e4.stop());
              }), { priority: e3.converterPriority || "normal" }), i2.on("removeMarker:" + t2, function(e4) {
                return (t3, i3, n3) => {
                  const o2 = e4(i3.markerName, n3);
                  if (!o2)
                    return;
                  const r2 = n3.mapper.markerNameToElements(i3.markerName);
                  if (r2) {
                    for (const e5 of r2)
                      n3.mapper.unbindElementFromMarkerName(e5, i3.markerName), e5.is("containerElement") ? (s2(`data-${o2.group}-start-before`, e5), s2(`data-${o2.group}-start-after`, e5), s2(`data-${o2.group}-end-before`, e5), s2(`data-${o2.group}-end-after`, e5)) : n3.writer.clear(n3.writer.createRangeOn(e5), e5);
                    n3.writer.clearClonedElementsGroup(i3.markerName), t3.stop();
                  }
                  function s2(e5, t4) {
                    if (t4.hasAttribute(e5)) {
                      const i4 = new Set(t4.getAttribute(e5).split(","));
                      i4.delete(o2.name), i4.size == 0 ? n3.writer.removeAttribute(e5, t4) : n3.writer.setAttribute(e5, Array.from(i4).join(","), t4);
                    }
                  }
                };
              }(e3.view), { priority: e3.converterPriority || "normal" });
            };
          }(e2));
        }
      }
      function Ca(e2, t2) {
        const i2 = e2.createAttributeElement("span", t2.attributes);
        return t2.classes && i2._addClass(t2.classes), typeof t2.priority == "number" && (i2._priority = t2.priority), i2._id = t2.id, i2;
      }
      function Ta(e2, t2, i2, n2, o2) {
        const r2 = t2 ? e2.start : e2.end, s2 = r2.nodeAfter && r2.nodeAfter.is("element") ? r2.nodeAfter : null, a2 = r2.nodeBefore && r2.nodeBefore.is("element") ? r2.nodeBefore : null;
        if (s2 || a2) {
          let e3, r3;
          t2 && s2 || !t2 && !a2 ? (e3 = s2, r3 = true) : (e3 = a2, r3 = false);
          const c2 = i2.mapper.toViewElement(e3);
          if (c2)
            return void function(e4, t3, i3, n3, o3, r4) {
              const s3 = `data-${r4.group}-${t3 ? "start" : "end"}-${i3 ? "before" : "after"}`, a3 = e4.hasAttribute(s3) ? e4.getAttribute(s3).split(",") : [];
              a3.unshift(r4.name), n3.writer.setAttribute(s3, a3.join(","), e4), n3.mapper.bindElementToMarker(e4, o3.markerName);
            }(c2, t2, r3, i2, n2, o2);
        }
        !function(e3, t3, i3, n3, o3) {
          const r3 = `${o3.group}-${t3 ? "start" : "end"}`, s3 = o3.name ? { name: o3.name } : null, a3 = i3.writer.createUIElement(r3, s3);
          i3.writer.insert(e3, a3), i3.mapper.bindElementToMarker(a3, n3.markerName);
        }(i2.mapper.toViewPosition(r2), t2, i2, n2, o2);
      }
      function Ea(e2, t2) {
        return typeof e2 == "function" ? e2 : (i2, n2) => function(e3, t3, i3) {
          typeof e3 == "string" && (e3 = { name: e3 });
          let n3;
          const o2 = t3.writer, r2 = Object.assign({}, e3.attributes);
          if (i3 == "container")
            n3 = o2.createContainerElement(e3.name, r2);
          else if (i3 == "attribute") {
            const t4 = { priority: e3.priority || xo.DEFAULT_PRIORITY };
            n3 = o2.createAttributeElement(e3.name, r2, t4);
          } else
            n3 = o2.createUIElement(e3.name, r2);
          if (e3.styles) {
            const t4 = Object.keys(e3.styles);
            for (const i4 of t4)
              o2.setStyle(i4, e3.styles[i4], n3);
          }
          if (e3.classes) {
            const t4 = e3.classes;
            if (typeof t4 == "string")
              o2.addClass(t4, n3);
            else
              for (const e4 of t4)
                o2.addClass(e4, n3);
          }
          return n3;
        }(e2, n2, t2);
      }
      function Ia(e2) {
        return e2.model.values ? (t2, i2) => {
          const n2 = e2.view[t2];
          return n2 ? n2(t2, i2) : null;
        } : e2.view;
      }
      function Sa(e2) {
        return typeof e2 == "string" ? (t2) => ({ key: e2, value: t2 }) : typeof e2 == "object" ? e2.value ? () => e2 : (t2) => ({ key: e2.key, value: t2 }) : e2;
      }
      function Pa(e2, t2, i2) {
        const n2 = typeof e2 == "function" ? e2(t2, i2) : e2;
        return n2 ? (n2.priority || (n2.priority = 10), n2.id || (n2.id = t2.markerName), n2) : null;
      }
      function Ma(e2) {
        const { schema: t2, document: i2 } = e2.model;
        for (const n2 of i2.getRootNames()) {
          const o2 = i2.getRoot(n2);
          if (o2.isEmpty && !t2.checkChild(o2, "$text") && t2.checkChild(o2, "paragraph"))
            return e2.insertElement("paragraph", o2), true;
        }
        return false;
      }
      function Na(e2, t2, i2) {
        const n2 = i2.createContext(e2);
        return !!i2.checkChild(n2, "paragraph") && !!i2.checkChild(n2.push("paragraph"), t2);
      }
      function Ra(e2, t2) {
        const i2 = t2.createElement("paragraph");
        return t2.insert(i2, e2), t2.createPositionAt(i2, 0);
      }
      class Oa extends ya {
        elementToElement(e2) {
          return this.add(za(e2));
        }
        elementToAttribute(e2) {
          return this.add(function(e3) {
            Va(e3 = xa(e3));
            const t2 = ja(e3, false), i2 = Da(e3.view), n2 = i2 ? "element:" + i2 : "element";
            return (i3) => {
              i3.on(n2, t2, { priority: e3.converterPriority || "low" });
            };
          }(e2));
        }
        attributeToAttribute(e2) {
          return this.add(function(e3) {
            e3 = xa(e3);
            let t2 = null;
            (typeof e3.view == "string" || e3.view.key) && (t2 = function(e4) {
              typeof e4.view == "string" && (e4.view = { key: e4.view });
              const t3 = e4.view.key;
              let i3;
              if (t3 == "class" || t3 == "style") {
                i3 = { [t3 == "class" ? "classes" : "styles"]: e4.view.value };
              } else {
                const n2 = e4.view.value === void 0 ? /[\s\S]*/ : e4.view.value;
                i3 = { attributes: { [t3]: n2 } };
              }
              e4.view.name && (i3.name = e4.view.name);
              return e4.view = i3, t3;
            }(e3));
            Va(e3, t2);
            const i2 = ja(e3, true);
            return (t3) => {
              t3.on("element", i2, { priority: e3.converterPriority || "low" });
            };
          }(e2));
        }
        elementToMarker(e2) {
          return this.add(function(e3) {
            return function(e4) {
              const t2 = e4.model;
              e4.model = (e5, i2) => {
                const n2 = typeof t2 == "string" ? t2 : t2(e5, i2);
                return i2.writer.createElement("$marker", { "data-name": n2 });
              };
            }(e3 = xa(e3)), za(e3);
          }(e2));
        }
        dataToMarker(e2) {
          return this.add(function(e3) {
            (e3 = xa(e3)).model || (e3.model = (t3) => t3 ? e3.view + ":" + t3 : e3.view);
            const t2 = La(Ba(e3, "start")), i2 = La(Ba(e3, "end"));
            return (n2) => {
              n2.on("element:" + e3.view + "-start", t2, { priority: e3.converterPriority || "normal" }), n2.on("element:" + e3.view + "-end", i2, { priority: e3.converterPriority || "normal" });
              const o2 = a.get("low"), r2 = a.get("highest"), s2 = a.get(e3.converterPriority) / r2;
              n2.on("element", function(e4) {
                return (t3, i3, n3) => {
                  const o3 = "data-" + e4.view;
                  function r3(t4, o4) {
                    for (const r4 of o4) {
                      const o5 = e4.model(r4, n3), s3 = n3.writer.createElement("$marker", { "data-name": o5 });
                      n3.writer.insert(s3, t4), i3.modelCursor.isEqual(t4) ? i3.modelCursor = i3.modelCursor.getShiftedBy(1) : i3.modelCursor = i3.modelCursor._getTransformedByInsertion(t4, 1), i3.modelRange = i3.modelRange._getTransformedByInsertion(t4, 1)[0];
                    }
                  }
                  (n3.consumable.test(i3.viewItem, { attributes: o3 + "-end-after" }) || n3.consumable.test(i3.viewItem, { attributes: o3 + "-start-after" }) || n3.consumable.test(i3.viewItem, { attributes: o3 + "-end-before" }) || n3.consumable.test(i3.viewItem, { attributes: o3 + "-start-before" })) && (i3.modelRange || Object.assign(i3, n3.convertChildren(i3.viewItem, i3.modelCursor)), n3.consumable.consume(i3.viewItem, { attributes: o3 + "-end-after" }) && r3(i3.modelRange.end, i3.viewItem.getAttribute(o3 + "-end-after").split(",")), n3.consumable.consume(i3.viewItem, { attributes: o3 + "-start-after" }) && r3(i3.modelRange.end, i3.viewItem.getAttribute(o3 + "-start-after").split(",")), n3.consumable.consume(i3.viewItem, { attributes: o3 + "-end-before" }) && r3(i3.modelRange.start, i3.viewItem.getAttribute(o3 + "-end-before").split(",")), n3.consumable.consume(i3.viewItem, { attributes: o3 + "-start-before" }) && r3(i3.modelRange.start, i3.viewItem.getAttribute(o3 + "-start-before").split(",")));
                };
              }(e3), { priority: o2 + s2 });
            };
          }(e2));
        }
      }
      function za(e2) {
        const t2 = La(e2 = xa(e2)), i2 = Da(e2.view), n2 = i2 ? "element:" + i2 : "element";
        return (i3) => {
          i3.on(n2, t2, { priority: e2.converterPriority || "normal" });
        };
      }
      function Da(e2) {
        return typeof e2 == "string" ? e2 : typeof e2 == "object" && typeof e2.name == "string" ? e2.name : null;
      }
      function La(e2) {
        const t2 = new mn(e2.view);
        return (i2, n2, o2) => {
          const r2 = t2.match(n2.viewItem);
          if (!r2)
            return;
          const s2 = r2.match;
          if (s2.name = true, !o2.consumable.test(n2.viewItem, s2))
            return;
          const a2 = function(e3, t3, i3) {
            return e3 instanceof Function ? e3(t3, i3) : i3.writer.createElement(e3);
          }(e2.model, n2.viewItem, o2);
          a2 && o2.safeInsert(a2, n2.modelCursor) && (o2.consumable.consume(n2.viewItem, s2), o2.convertChildren(n2.viewItem, a2), o2.updateConversionResult(a2, n2));
        };
      }
      function Va(e2, t2 = null) {
        const i2 = t2 === null || ((e3) => e3.getAttribute(t2)), n2 = typeof e2.model != "object" ? e2.model : e2.model.key, o2 = typeof e2.model != "object" || e2.model.value === void 0 ? i2 : e2.model.value;
        e2.model = { key: n2, value: o2 };
      }
      function ja(e2, t2) {
        const i2 = new mn(e2.view);
        return (n2, o2, r2) => {
          const s2 = i2.match(o2.viewItem);
          if (!s2)
            return;
          if (!function(e3, t3) {
            const i3 = typeof e3 == "function" ? e3(t3) : e3;
            if (typeof i3 == "object" && !Da(i3))
              return false;
            return !i3.classes && !i3.attributes && !i3.styles;
          }(e2.view, o2.viewItem) ? delete s2.match.name : s2.match.name = true, !r2.consumable.test(o2.viewItem, s2.match))
            return;
          const a2 = e2.model.key, c2 = typeof e2.model.value == "function" ? e2.model.value(o2.viewItem, r2) : e2.model.value;
          if (c2 === null)
            return;
          o2.modelRange || Object.assign(o2, r2.convertChildren(o2.viewItem, o2.modelCursor));
          (function(e3, t3, i3, n3) {
            let o3 = false;
            for (const r3 of Array.from(e3.getItems({ shallow: i3 })))
              n3.schema.checkAttribute(r3, t3.key) && (o3 = true, r3.hasAttribute(t3.key) || n3.writer.setAttribute(t3.key, t3.value, r3));
            return o3;
          })(o2.modelRange, { key: a2, value: c2 }, t2, r2) && r2.consumable.consume(o2.viewItem, s2.match);
        };
      }
      function Ba(e2, t2) {
        const i2 = {};
        return i2.view = e2.view + "-" + t2, i2.model = (t3, i3) => {
          const n2 = t3.getAttribute("name"), o2 = e2.model(n2, i3);
          return i3.writer.createElement("$marker", { "data-name": o2 });
        }, i2;
      }
      class Fa {
        constructor(e2, t2) {
          this.model = e2, this.view = new qs(t2), this.mapper = new oa(), this.downcastDispatcher = new aa({ mapper: this.mapper, schema: e2.schema });
          const i2 = this.model.document, n2 = i2.selection, o2 = this.model.markers;
          this.listenTo(this.model, "_beforeChanges", () => {
            this.view._disableRendering(true);
          }, { priority: "highest" }), this.listenTo(this.model, "_afterChanges", () => {
            this.view._disableRendering(false);
          }, { priority: "lowest" }), this.listenTo(i2, "change", () => {
            this.view.change((e3) => {
              this.downcastDispatcher.convertChanges(i2.differ, o2, e3), this.downcastDispatcher.convertSelection(n2, o2, e3);
            });
          }, { priority: "low" }), this.listenTo(this.view.document, "selectionChange", function(e3, t3) {
            return (i3, n3) => {
              const o3 = n3.newSelection, r2 = [];
              for (const e4 of o3.getRanges())
                r2.push(t3.toModelRange(e4));
              const s2 = e3.createSelection(r2, { backward: o3.isBackward });
              s2.isEqual(e3.document.selection) || e3.change((e4) => {
                e4.setSelection(s2);
              });
            };
          }(this.model, this.mapper)), this.downcastDispatcher.on("insert:$text", (e3, t3, i3) => {
            if (!i3.consumable.consume(t3.item, "insert"))
              return;
            const n3 = i3.writer, o3 = i3.mapper.toViewPosition(t3.range.start), r2 = n3.createText(t3.item.data);
            n3.insert(o3, r2);
          }, { priority: "lowest" }), this.downcastDispatcher.on("remove", (e3, t3, i3) => {
            const n3 = i3.mapper.toViewPosition(t3.position), o3 = t3.position.getShiftedBy(t3.length), r2 = i3.mapper.toViewPosition(o3, { isPhantom: true }), s2 = i3.writer.createRange(n3, r2), a2 = i3.writer.remove(s2.getTrimmed());
            for (const e4 of i3.writer.createRangeIn(a2).getItems())
              i3.mapper.unbindViewElement(e4);
          }, { priority: "low" }), this.downcastDispatcher.on("selection", (e3, t3, i3) => {
            const n3 = i3.writer, o3 = n3.document.selection;
            for (const e4 of o3.getRanges())
              e4.isCollapsed && e4.end.parent.isAttached() && i3.writer.mergeAttributes(e4.start);
            n3.setSelection(null);
          }, { priority: "high" }), this.downcastDispatcher.on("selection", (e3, t3, i3) => {
            const n3 = t3.selection;
            if (n3.isCollapsed)
              return;
            if (!i3.consumable.consume(n3, "selection"))
              return;
            const o3 = [];
            for (const e4 of n3.getRanges()) {
              const t4 = i3.mapper.toViewRange(e4);
              o3.push(t4);
            }
            i3.writer.setSelection(o3, { backward: n3.isBackward });
          }, { priority: "low" }), this.downcastDispatcher.on("selection", (e3, t3, i3) => {
            const n3 = t3.selection;
            if (!n3.isCollapsed)
              return;
            if (!i3.consumable.consume(n3, "selection"))
              return;
            const o3 = i3.writer, r2 = n3.getFirstPosition(), s2 = i3.mapper.toViewPosition(r2), a2 = o3.breakAttributes(s2);
            o3.setSelection(a2);
          }, { priority: "low" }), this.view.document.roots.bindTo(this.model.document.roots).using((e3) => {
            if (e3.rootName == "$graveyard")
              return null;
            const t3 = new so(this.view.document, e3.name);
            return t3.rootName = e3.rootName, this.mapper.bindElements(e3, t3), t3;
          });
        }
        destroy() {
          this.view.destroy(), this.stopListening();
        }
      }
      Ke(Fa, Ue);
      class Ha {
        constructor() {
          this._commands = new Map();
        }
        add(e2, t2) {
          this._commands.set(e2, t2);
        }
        get(e2) {
          return this._commands.get(e2);
        }
        execute(e2, ...t2) {
          const i2 = this.get(e2);
          if (!i2)
            throw new c.a("commandcollection-command-not-found", this, { commandName: e2 });
          return i2.execute(...t2);
        }
        *names() {
          yield* this._commands.keys();
        }
        *commands() {
          yield* this._commands.values();
        }
        [Symbol.iterator]() {
          return this._commands[Symbol.iterator]();
        }
        destroy() {
          for (const e2 of this.commands())
            e2.destroy();
        }
      }
      class Ua {
        constructor() {
          this._consumables = new Map();
        }
        add(e2, t2) {
          let i2;
          e2.is("$text") || e2.is("documentFragment") ? this._consumables.set(e2, true) : (this._consumables.has(e2) ? i2 = this._consumables.get(e2) : (i2 = new Wa(e2), this._consumables.set(e2, i2)), i2.add(t2));
        }
        test(e2, t2) {
          const i2 = this._consumables.get(e2);
          return i2 === void 0 ? null : e2.is("$text") || e2.is("documentFragment") ? i2 : i2.test(t2);
        }
        consume(e2, t2) {
          return !!this.test(e2, t2) && (e2.is("$text") || e2.is("documentFragment") ? this._consumables.set(e2, false) : this._consumables.get(e2).consume(t2), true);
        }
        revert(e2, t2) {
          const i2 = this._consumables.get(e2);
          i2 !== void 0 && (e2.is("$text") || e2.is("documentFragment") ? this._consumables.set(e2, true) : i2.revert(t2));
        }
        static consumablesFromElement(e2) {
          const t2 = { element: e2, name: true, attributes: [], classes: [], styles: [] }, i2 = e2.getAttributeKeys();
          for (const e3 of i2)
            e3 != "style" && e3 != "class" && t2.attributes.push(e3);
          const n2 = e2.getClassNames();
          for (const e3 of n2)
            t2.classes.push(e3);
          const o2 = e2.getStyleNames();
          for (const e3 of o2)
            t2.styles.push(e3);
          return t2;
        }
        static createFrom(e2, t2) {
          if (t2 || (t2 = new Ua(e2)), e2.is("$text"))
            return t2.add(e2), t2;
          e2.is("element") && t2.add(e2, Ua.consumablesFromElement(e2)), e2.is("documentFragment") && t2.add(e2);
          for (const i2 of e2.getChildren())
            t2 = Ua.createFrom(i2, t2);
          return t2;
        }
      }
      class Wa {
        constructor(e2) {
          this.element = e2, this._canConsumeName = null, this._consumables = { attributes: new Map(), styles: new Map(), classes: new Map() };
        }
        add(e2) {
          e2.name && (this._canConsumeName = true);
          for (const t2 in this._consumables)
            t2 in e2 && this._add(t2, e2[t2]);
        }
        test(e2) {
          if (e2.name && !this._canConsumeName)
            return this._canConsumeName;
          for (const t2 in this._consumables)
            if (t2 in e2) {
              const i2 = this._test(t2, e2[t2]);
              if (i2 !== true)
                return i2;
            }
          return true;
        }
        consume(e2) {
          e2.name && (this._canConsumeName = false);
          for (const t2 in this._consumables)
            t2 in e2 && this._consume(t2, e2[t2]);
        }
        revert(e2) {
          e2.name && (this._canConsumeName = true);
          for (const t2 in this._consumables)
            t2 in e2 && this._revert(t2, e2[t2]);
        }
        _add(e2, t2) {
          const i2 = _e(t2) ? t2 : [t2], n2 = this._consumables[e2];
          for (const t3 of i2) {
            if (e2 === "attributes" && (t3 === "class" || t3 === "style"))
              throw new c.a("viewconsumable-invalid-attribute", this);
            if (n2.set(t3, true), e2 === "styles")
              for (const e3 of this.element.document.stylesProcessor.getRelatedStyles(t3))
                n2.set(e3, true);
          }
        }
        _test(e2, t2) {
          const i2 = _e(t2) ? t2 : [t2], n2 = this._consumables[e2];
          for (const t3 of i2)
            if (e2 !== "attributes" || t3 !== "class" && t3 !== "style") {
              const e3 = n2.get(t3);
              if (e3 === void 0)
                return null;
              if (!e3)
                return false;
            } else {
              const e3 = t3 == "class" ? "classes" : "styles", i3 = this._test(e3, [...this._consumables[e3].keys()]);
              if (i3 !== true)
                return i3;
            }
          return true;
        }
        _consume(e2, t2) {
          const i2 = _e(t2) ? t2 : [t2], n2 = this._consumables[e2];
          for (const t3 of i2)
            if (e2 !== "attributes" || t3 !== "class" && t3 !== "style") {
              if (n2.set(t3, false), e2 == "styles")
                for (const e3 of this.element.document.stylesProcessor.getRelatedStyles(t3))
                  n2.set(e3, false);
            } else {
              const e3 = t3 == "class" ? "classes" : "styles";
              this._consume(e3, [...this._consumables[e3].keys()]);
            }
        }
        _revert(e2, t2) {
          const i2 = _e(t2) ? t2 : [t2], n2 = this._consumables[e2];
          for (const t3 of i2)
            if (e2 !== "attributes" || t3 !== "class" && t3 !== "style") {
              n2.get(t3) === false && n2.set(t3, true);
            } else {
              const e3 = t3 == "class" ? "classes" : "styles";
              this._revert(e3, [...this._consumables[e3].keys()]);
            }
        }
      }
      class qa {
        constructor() {
          this._sourceDefinitions = {}, this._attributeProperties = {}, this.decorate("checkChild"), this.decorate("checkAttribute"), this.on("checkAttribute", (e2, t2) => {
            t2[0] = new $a(t2[0]);
          }, { priority: "highest" }), this.on("checkChild", (e2, t2) => {
            t2[0] = new $a(t2[0]), t2[1] = this.getDefinition(t2[1]);
          }, { priority: "highest" });
        }
        register(e2, t2) {
          if (this._sourceDefinitions[e2])
            throw new c.a("schema-cannot-register-item-twice", this, { itemName: e2 });
          this._sourceDefinitions[e2] = [Object.assign({}, t2)], this._clearCache();
        }
        extend(e2, t2) {
          if (!this._sourceDefinitions[e2])
            throw new c.a("schema-cannot-extend-missing-item", this, { itemName: e2 });
          this._sourceDefinitions[e2].push(Object.assign({}, t2)), this._clearCache();
        }
        getDefinitions() {
          return this._compiledDefinitions || this._compile(), this._compiledDefinitions;
        }
        getDefinition(e2) {
          let t2;
          return t2 = typeof e2 == "string" ? e2 : e2.is && (e2.is("$text") || e2.is("$textProxy")) ? "$text" : e2.name, this.getDefinitions()[t2];
        }
        isRegistered(e2) {
          return !!this.getDefinition(e2);
        }
        isBlock(e2) {
          const t2 = this.getDefinition(e2);
          return !(!t2 || !t2.isBlock);
        }
        isLimit(e2) {
          const t2 = this.getDefinition(e2);
          return !!t2 && !(!t2.isLimit && !t2.isObject);
        }
        isObject(e2) {
          const t2 = this.getDefinition(e2);
          return !!t2 && !!(t2.isObject || t2.isLimit && t2.isSelectable && t2.isContent);
        }
        isInline(e2) {
          const t2 = this.getDefinition(e2);
          return !(!t2 || !t2.isInline);
        }
        isSelectable(e2) {
          const t2 = this.getDefinition(e2);
          return !!t2 && !(!t2.isSelectable && !t2.isObject);
        }
        isContent(e2) {
          const t2 = this.getDefinition(e2);
          return !!t2 && !(!t2.isContent && !t2.isObject);
        }
        checkChild(e2, t2) {
          return !!t2 && this._checkContextMatch(t2, e2);
        }
        checkAttribute(e2, t2) {
          const i2 = this.getDefinition(e2.last);
          return !!i2 && i2.allowAttributes.includes(t2);
        }
        checkMerge(e2, t2 = null) {
          if (e2 instanceof Xs) {
            const t3 = e2.nodeBefore, i2 = e2.nodeAfter;
            if (!(t3 instanceof Qs))
              throw new c.a("schema-check-merge-no-element-before", this);
            if (!(i2 instanceof Qs))
              throw new c.a("schema-check-merge-no-element-after", this);
            return this.checkMerge(t3, i2);
          }
          for (const i2 of t2.getChildren())
            if (!this.checkChild(e2, i2))
              return false;
          return true;
        }
        addChildCheck(e2) {
          this.on("checkChild", (t2, [i2, n2]) => {
            if (!n2)
              return;
            const o2 = e2(i2, n2);
            typeof o2 == "boolean" && (t2.stop(), t2.return = o2);
          }, { priority: "high" });
        }
        addAttributeCheck(e2) {
          this.on("checkAttribute", (t2, [i2, n2]) => {
            const o2 = e2(i2, n2);
            typeof o2 == "boolean" && (t2.stop(), t2.return = o2);
          }, { priority: "high" });
        }
        setAttributeProperties(e2, t2) {
          this._attributeProperties[e2] = Object.assign(this.getAttributeProperties(e2), t2);
        }
        getAttributeProperties(e2) {
          return this._attributeProperties[e2] || {};
        }
        getLimitElement(e2) {
          let t2;
          if (e2 instanceof Xs)
            t2 = e2.parent;
          else {
            t2 = (e2 instanceof na ? [e2] : Array.from(e2.getRanges())).reduce((e3, t3) => {
              const i2 = t3.getCommonAncestor();
              return e3 ? e3.getCommonAncestor(i2, { includeSelf: true }) : i2;
            }, null);
          }
          for (; !this.isLimit(t2) && t2.parent; )
            t2 = t2.parent;
          return t2;
        }
        checkAttributeInSelection(e2, t2) {
          if (e2.isCollapsed) {
            const i2 = [...e2.getFirstPosition().getAncestors(), new Ys("", e2.getAttributes())];
            return this.checkAttribute(i2, t2);
          }
          {
            const i2 = e2.getRanges();
            for (const e3 of i2)
              for (const i3 of e3)
                if (this.checkAttribute(i3.item, t2))
                  return true;
          }
          return false;
        }
        *getValidRanges(e2, t2) {
          e2 = function* (e3) {
            for (const t3 of e3)
              yield* t3.getMinimalFlatRanges();
          }(e2);
          for (const i2 of e2)
            yield* this._getValidRangesForRange(i2, t2);
        }
        getNearestSelectionRange(e2, t2 = "both") {
          if (this.checkChild(e2, "$text"))
            return new na(e2);
          let i2, n2;
          const o2 = e2.getAncestors().reverse().find((e3) => this.isLimit(e3)) || e2.root;
          t2 != "both" && t2 != "backward" || (i2 = new Js({ boundaries: na._createIn(o2), startPosition: e2, direction: "backward" })), t2 != "both" && t2 != "forward" || (n2 = new Js({ boundaries: na._createIn(o2), startPosition: e2 }));
          for (const e3 of function* (e4, t3) {
            let i3 = false;
            for (; !i3; ) {
              if (i3 = true, e4) {
                const t4 = e4.next();
                t4.done || (i3 = false, yield { walker: e4, value: t4.value });
              }
              if (t3) {
                const e5 = t3.next();
                e5.done || (i3 = false, yield { walker: t3, value: e5.value });
              }
            }
          }(i2, n2)) {
            const t3 = e3.walker == i2 ? "elementEnd" : "elementStart", n3 = e3.value;
            if (n3.type == t3 && this.isObject(n3.item))
              return na._createOn(n3.item);
            if (this.checkChild(n3.nextPosition, "$text"))
              return new na(n3.nextPosition);
          }
          return null;
        }
        findAllowedParent(e2, t2) {
          let i2 = e2.parent;
          for (; i2; ) {
            if (this.checkChild(i2, t2))
              return i2;
            if (this.isLimit(i2))
              return null;
            i2 = i2.parent;
          }
          return null;
        }
        removeDisallowedAttributes(e2, t2) {
          for (const i2 of e2)
            if (i2.is("$text"))
              rc(this, i2, t2);
            else {
              const e3 = na._createIn(i2).getPositions();
              for (const i3 of e3) {
                rc(this, i3.nodeBefore || i3.parent, t2);
              }
            }
        }
        createContext(e2) {
          return new $a(e2);
        }
        _clearCache() {
          this._compiledDefinitions = null;
        }
        _compile() {
          const e2 = {}, t2 = this._sourceDefinitions, i2 = Object.keys(t2);
          for (const n2 of i2)
            e2[n2] = Ya(t2[n2], n2);
          for (const t3 of i2)
            Ga(e2, t3);
          for (const t3 of i2)
            Ka(e2, t3);
          for (const t3 of i2)
            Qa(e2, t3);
          for (const t3 of i2)
            Ja(e2, t3), Za(e2, t3);
          for (const t3 of i2)
            Xa(e2, t3), ec(e2, t3), tc(e2, t3);
          this._compiledDefinitions = e2;
        }
        _checkContextMatch(e2, t2, i2 = t2.length - 1) {
          const n2 = t2.getItem(i2);
          if (e2.allowIn.includes(n2.name)) {
            if (i2 == 0)
              return true;
            {
              const e3 = this.getDefinition(n2);
              return this._checkContextMatch(e3, t2, i2 - 1);
            }
          }
          return false;
        }
        *_getValidRangesForRange(e2, t2) {
          let i2 = e2.start, n2 = e2.start;
          for (const o2 of e2.getItems({ shallow: true }))
            o2.is("element") && (yield* this._getValidRangesForRange(na._createIn(o2), t2)), this.checkAttribute(o2, t2) || (i2.isEqual(n2) || (yield new na(i2, n2)), i2 = Xs._createAfter(o2)), n2 = Xs._createAfter(o2);
          i2.isEqual(n2) || (yield new na(i2, n2));
        }
      }
      Ke(qa, Ue);
      class $a {
        constructor(e2) {
          if (e2 instanceof $a)
            return e2;
          typeof e2 == "string" ? e2 = [e2] : Array.isArray(e2) || (e2 = e2.getAncestors({ includeSelf: true })), this._items = e2.map(oc);
        }
        get length() {
          return this._items.length;
        }
        get last() {
          return this._items[this._items.length - 1];
        }
        [Symbol.iterator]() {
          return this._items[Symbol.iterator]();
        }
        push(e2) {
          const t2 = new $a([e2]);
          return t2._items = [...this._items, ...t2._items], t2;
        }
        getItem(e2) {
          return this._items[e2];
        }
        *getNames() {
          yield* this._items.map((e2) => e2.name);
        }
        endsWith(e2) {
          return Array.from(this.getNames()).join(" ").endsWith(e2);
        }
        startsWith(e2) {
          return Array.from(this.getNames()).join(" ").startsWith(e2);
        }
      }
      function Ya(e2, t2) {
        const i2 = { name: t2, allowIn: [], allowContentOf: [], allowWhere: [], allowAttributes: [], allowAttributesOf: [], allowChildren: [], inheritTypesFrom: [] };
        return function(e3, t3) {
          for (const i3 of e3) {
            const e4 = Object.keys(i3).filter((e5) => e5.startsWith("is"));
            for (const n2 of e4)
              t3[n2] = i3[n2];
          }
        }(e2, i2), ic(e2, i2, "allowIn"), ic(e2, i2, "allowContentOf"), ic(e2, i2, "allowWhere"), ic(e2, i2, "allowAttributes"), ic(e2, i2, "allowAttributesOf"), ic(e2, i2, "allowChildren"), ic(e2, i2, "inheritTypesFrom"), function(e3, t3) {
          for (const i3 of e3) {
            const e4 = i3.inheritAllFrom;
            e4 && (t3.allowContentOf.push(e4), t3.allowWhere.push(e4), t3.allowAttributesOf.push(e4), t3.inheritTypesFrom.push(e4));
          }
        }(e2, i2), i2;
      }
      function Ga(e2, t2) {
        const i2 = e2[t2];
        for (const n2 of i2.allowChildren) {
          const i3 = e2[n2];
          i3 && i3.allowIn.push(t2);
        }
        i2.allowChildren.length = 0;
      }
      function Ka(e2, t2) {
        for (const i2 of e2[t2].allowContentOf)
          if (e2[i2]) {
            nc(e2, i2).forEach((e3) => {
              e3.allowIn.push(t2);
            });
          }
        delete e2[t2].allowContentOf;
      }
      function Qa(e2, t2) {
        for (const i2 of e2[t2].allowWhere) {
          const n2 = e2[i2];
          if (n2) {
            const i3 = n2.allowIn;
            e2[t2].allowIn.push(...i3);
          }
        }
        delete e2[t2].allowWhere;
      }
      function Ja(e2, t2) {
        for (const i2 of e2[t2].allowAttributesOf) {
          const n2 = e2[i2];
          if (n2) {
            const i3 = n2.allowAttributes;
            e2[t2].allowAttributes.push(...i3);
          }
        }
        delete e2[t2].allowAttributesOf;
      }
      function Za(e2, t2) {
        const i2 = e2[t2];
        for (const t3 of i2.inheritTypesFrom) {
          const n2 = e2[t3];
          if (n2) {
            const e3 = Object.keys(n2).filter((e4) => e4.startsWith("is"));
            for (const t4 of e3)
              t4 in i2 || (i2[t4] = n2[t4]);
          }
        }
        delete i2.inheritTypesFrom;
      }
      function Xa(e2, t2) {
        const i2 = e2[t2], n2 = i2.allowIn.filter((t3) => e2[t3]);
        i2.allowIn = Array.from(new Set(n2));
      }
      function ec(e2, t2) {
        const i2 = e2[t2];
        for (const n2 of i2.allowIn) {
          e2[n2].allowChildren.push(t2);
        }
      }
      function tc(e2, t2) {
        const i2 = e2[t2];
        i2.allowAttributes = Array.from(new Set(i2.allowAttributes));
      }
      function ic(e2, t2, i2) {
        for (const n2 of e2)
          typeof n2[i2] == "string" ? t2[i2].push(n2[i2]) : Array.isArray(n2[i2]) && t2[i2].push(...n2[i2]);
      }
      function nc(e2, t2) {
        const i2 = e2[t2];
        return (n2 = e2, Object.keys(n2).map((e3) => n2[e3])).filter((e3) => e3.allowIn.includes(i2.name));
        var n2;
      }
      function oc(e2) {
        return typeof e2 == "string" || e2.is("documentFragment") ? { name: typeof e2 == "string" ? e2 : "$documentFragment", *getAttributeKeys() {
        }, getAttribute() {
        } } : { name: e2.is("element") ? e2.name : "$text", *getAttributeKeys() {
          yield* e2.getAttributeKeys();
        }, getAttribute: (t2) => e2.getAttribute(t2) };
      }
      function rc(e2, t2, i2) {
        for (const n2 of t2.getAttributeKeys())
          e2.checkAttribute(t2, n2) || i2.removeAttribute(n2, t2);
      }
      class sc {
        constructor(e2 = {}) {
          this._splitParts = new Map(), this._cursorParents = new Map(), this._modelCursor = null, this.conversionApi = Object.assign({}, e2), this.conversionApi.convertItem = this._convertItem.bind(this), this.conversionApi.convertChildren = this._convertChildren.bind(this), this.conversionApi.safeInsert = this._safeInsert.bind(this), this.conversionApi.updateConversionResult = this._updateConversionResult.bind(this), this.conversionApi.splitToAllowedParent = this._splitToAllowedParent.bind(this), this.conversionApi.getSplitParts = this._getSplitParts.bind(this);
        }
        convert(e2, t2, i2 = ["$root"]) {
          this.fire("viewCleanup", e2), this._modelCursor = function(e3, t3) {
            let i3;
            for (const n3 of new $a(e3)) {
              const e4 = {};
              for (const t4 of n3.getAttributeKeys())
                e4[t4] = n3.getAttribute(t4);
              const o3 = t3.createElement(n3.name, e4);
              i3 && t3.append(o3, i3), i3 = Xs._createAt(o3, 0);
            }
            return i3;
          }(i2, t2), this.conversionApi.writer = t2, this.conversionApi.consumable = Ua.createFrom(e2), this.conversionApi.store = {};
          const { modelRange: n2 } = this._convertItem(e2, this._modelCursor), o2 = t2.createDocumentFragment();
          if (n2) {
            this._removeEmptyElements();
            for (const e3 of Array.from(this._modelCursor.parent.getChildren()))
              t2.append(e3, o2);
            o2.markers = function(e3, t3) {
              const i3 = new Set(), n3 = new Map(), o3 = na._createIn(e3).getItems();
              for (const e4 of o3)
                e4.name == "$marker" && i3.add(e4);
              for (const e4 of i3) {
                const i4 = e4.getAttribute("data-name"), o4 = t3.createPositionBefore(e4);
                n3.has(i4) ? n3.get(i4).end = o4.clone() : n3.set(i4, new na(o4.clone())), t3.remove(e4);
              }
              return n3;
            }(o2, t2);
          }
          return this._modelCursor = null, this._splitParts.clear(), this._cursorParents.clear(), this.conversionApi.writer = null, this.conversionApi.store = null, o2;
        }
        _convertItem(e2, t2) {
          const i2 = Object.assign({ viewItem: e2, modelCursor: t2, modelRange: null });
          if (e2.is("element") ? this.fire("element:" + e2.name, i2, this.conversionApi) : e2.is("$text") ? this.fire("text", i2, this.conversionApi) : this.fire("documentFragment", i2, this.conversionApi), i2.modelRange && !(i2.modelRange instanceof na))
            throw new c.a("view-conversion-dispatcher-incorrect-result", this);
          return { modelRange: i2.modelRange, modelCursor: i2.modelCursor };
        }
        _convertChildren(e2, t2) {
          let i2 = t2.is("position") ? t2 : Xs._createAt(t2, 0);
          const n2 = new na(i2);
          for (const t3 of Array.from(e2.getChildren())) {
            const e3 = this._convertItem(t3, i2);
            e3.modelRange instanceof na && (n2.end = e3.modelRange.end, i2 = e3.modelCursor);
          }
          return { modelRange: n2, modelCursor: i2 };
        }
        _safeInsert(e2, t2) {
          const i2 = this._splitToAllowedParent(e2, t2);
          return !!i2 && (this.conversionApi.writer.insert(e2, i2.position), true);
        }
        _updateConversionResult(e2, t2) {
          const i2 = this._getSplitParts(e2), n2 = this.conversionApi.writer;
          t2.modelRange || (t2.modelRange = n2.createRange(n2.createPositionBefore(e2), n2.createPositionAfter(i2[i2.length - 1])));
          const o2 = this._cursorParents.get(e2);
          t2.modelCursor = o2 ? n2.createPositionAt(o2, 0) : t2.modelRange.end;
        }
        _splitToAllowedParent(e2, t2) {
          const { schema: i2, writer: n2 } = this.conversionApi;
          let o2 = i2.findAllowedParent(t2, e2);
          if (o2) {
            if (o2 === t2.parent)
              return { position: t2 };
            this._modelCursor.parent.getAncestors().includes(o2) && (o2 = null);
          }
          if (!o2)
            return Na(t2, e2, i2) ? { position: Ra(t2, n2) } : null;
          const r2 = this.conversionApi.writer.split(t2, o2), s2 = [];
          for (const e3 of r2.range.getWalker())
            if (e3.type == "elementEnd")
              s2.push(e3.item);
            else {
              const t3 = s2.pop(), i3 = e3.item;
              this._registerSplitPair(t3, i3);
            }
          const a2 = r2.range.end.parent;
          return this._cursorParents.set(e2, a2), { position: r2.position, cursorParent: a2 };
        }
        _registerSplitPair(e2, t2) {
          this._splitParts.has(e2) || this._splitParts.set(e2, [e2]);
          const i2 = this._splitParts.get(e2);
          this._splitParts.set(t2, i2), i2.push(t2);
        }
        _getSplitParts(e2) {
          let t2;
          return t2 = this._splitParts.has(e2) ? this._splitParts.get(e2) : [e2], t2;
        }
        _removeEmptyElements() {
          let e2 = false;
          for (const t2 of this._splitParts.keys())
            t2.isEmpty && (this.conversionApi.writer.remove(t2), this._splitParts.delete(t2), e2 = true);
          e2 && this._removeEmptyElements();
        }
      }
      Ke(sc, h);
      class ac {
        getHtml(e2) {
          const t2 = document.implementation.createHTMLDocument("").createElement("div");
          return t2.appendChild(e2), t2.innerHTML;
        }
      }
      class cc {
        constructor(e2) {
          this._domParser = new DOMParser(), this._domConverter = new Tr(e2, { blockFillerMode: "nbsp" }), this._htmlWriter = new ac();
        }
        toData(e2) {
          const t2 = this._domConverter.viewToDom(e2, document);
          return this._htmlWriter.getHtml(t2);
        }
        toView(e2) {
          const t2 = this._toDom(e2);
          return this._domConverter.domToView(t2);
        }
        registerRawContentMatcher(e2) {
          this._domConverter.registerRawContentMatcher(e2);
        }
        useFillerType(e2) {
          this._domConverter.blockFillerMode = e2 == "marked" ? "markedNbsp" : "nbsp";
        }
        _toDom(e2) {
          const t2 = this._domParser.parseFromString(e2, "text/html"), i2 = t2.createDocumentFragment();
          let n2 = t2.firstChild;
          for (; !n2.isSameNode(t2.documentElement); ) {
            const e3 = n2;
            n2 = n2.nextSibling, e3.nodeType == Node.COMMENT_NODE && i2.appendChild(e3);
          }
          const o2 = t2.body.childNodes;
          for (; o2.length > 0; )
            i2.appendChild(o2[0]);
          return i2;
        }
      }
      class lc {
        constructor(e2, t2) {
          this.model = e2, this.mapper = new oa(), this.downcastDispatcher = new aa({ mapper: this.mapper, schema: e2.schema }), this.downcastDispatcher.on("insert:$text", (e3, t3, i2) => {
            if (!i2.consumable.consume(t3.item, "insert"))
              return;
            const n2 = i2.writer, o2 = i2.mapper.toViewPosition(t3.range.start), r2 = n2.createText(t3.item.data);
            n2.insert(o2, r2);
          }, { priority: "lowest" }), this.upcastDispatcher = new sc({ schema: e2.schema }), this.viewDocument = new yo(t2), this.stylesProcessor = t2, this.htmlProcessor = new cc(this.viewDocument), this.processor = this.htmlProcessor, this._viewWriter = new Wo(this.viewDocument), this.upcastDispatcher.on("text", (e3, t3, { schema: i2, consumable: n2, writer: o2 }) => {
            let r2 = t3.modelCursor;
            if (!n2.test(t3.viewItem))
              return;
            if (!i2.checkChild(r2, "$text")) {
              if (!Na(r2, "$text", i2))
                return;
              r2 = Ra(r2, o2);
            }
            n2.consume(t3.viewItem);
            const s2 = o2.createText(t3.viewItem.data);
            o2.insert(s2, r2), t3.modelRange = o2.createRange(r2, r2.getShiftedBy(s2.offsetSize)), t3.modelCursor = t3.modelRange.end;
          }, { priority: "lowest" }), this.upcastDispatcher.on("element", (e3, t3, i2) => {
            if (!t3.modelRange && i2.consumable.consume(t3.viewItem, { name: true })) {
              const { modelRange: e4, modelCursor: n2 } = i2.convertChildren(t3.viewItem, t3.modelCursor);
              t3.modelRange = e4, t3.modelCursor = n2;
            }
          }, { priority: "lowest" }), this.upcastDispatcher.on("documentFragment", (e3, t3, i2) => {
            if (!t3.modelRange && i2.consumable.consume(t3.viewItem, { name: true })) {
              const { modelRange: e4, modelCursor: n2 } = i2.convertChildren(t3.viewItem, t3.modelCursor);
              t3.modelRange = e4, t3.modelCursor = n2;
            }
          }, { priority: "lowest" }), this.decorate("init"), this.decorate("set"), this.on("init", () => {
            this.fire("ready");
          }, { priority: "lowest" }), this.on("ready", () => {
            this.model.enqueueChange("transparent", Ma);
          }, { priority: "lowest" });
        }
        get(e2 = {}) {
          const { rootName: t2 = "main", trim: i2 = "empty" } = e2;
          if (!this._checkIfRootsExists([t2]))
            throw new c.a("datacontroller-get-non-existent-root", this);
          const n2 = this.model.document.getRoot(t2);
          return i2 !== "empty" || this.model.hasContent(n2, { ignoreWhitespaces: true }) ? this.stringify(n2, e2) : "";
        }
        stringify(e2, t2 = {}) {
          const i2 = this.toView(e2, t2);
          return this.processor.toData(i2);
        }
        toView(e2, t2 = {}) {
          const i2 = this.viewDocument, n2 = this._viewWriter;
          this.mapper.clearBindings();
          const o2 = na._createIn(e2), r2 = new Uo(i2);
          this.mapper.bindElements(e2, r2), this.downcastDispatcher.conversionApi.options = t2, this.downcastDispatcher.convertInsert(o2, n2);
          const s2 = e2.is("documentFragment") ? Array.from(e2.markers) : function(e3) {
            const t3 = [], i3 = e3.root.document;
            if (!i3)
              return [];
            const n3 = na._createIn(e3);
            for (const e4 of i3.model.markers) {
              const i4 = e4.getRange(), o3 = i4.isCollapsed, r3 = i4.start.isEqual(n3.start) || i4.end.isEqual(n3.end);
              if (o3 && r3)
                t3.push([e4.name, i4]);
              else {
                const o4 = n3.getIntersection(i4);
                o4 && t3.push([e4.name, o4]);
              }
            }
            return t3;
          }(e2);
          for (const [e3, t3] of s2)
            this.downcastDispatcher.convertMarkerAdd(e3, t3, n2);
          return delete this.downcastDispatcher.conversionApi.options, r2;
        }
        init(e2) {
          if (this.model.document.version)
            throw new c.a("datacontroller-init-document-not-empty", this);
          let t2 = {};
          if (typeof e2 == "string" ? t2.main = e2 : t2 = e2, !this._checkIfRootsExists(Object.keys(t2)))
            throw new c.a("datacontroller-init-non-existent-root", this);
          return this.model.enqueueChange("transparent", (e3) => {
            for (const i2 of Object.keys(t2)) {
              const n2 = this.model.document.getRoot(i2);
              e3.insert(this.parse(t2[i2], n2), n2, 0);
            }
          }), Promise.resolve();
        }
        set(e2, t2 = {}) {
          let i2 = {};
          if (typeof e2 == "string" ? i2.main = e2 : i2 = e2, !this._checkIfRootsExists(Object.keys(i2)))
            throw new c.a("datacontroller-set-non-existent-root", this);
          const n2 = t2.batchType || "default";
          this.model.enqueueChange(n2, (e3) => {
            e3.setSelection(null), e3.removeSelectionAttribute(this.model.document.selection.getAttributeKeys());
            for (const t3 of Object.keys(i2)) {
              const n3 = this.model.document.getRoot(t3);
              e3.remove(e3.createRangeIn(n3)), e3.insert(this.parse(i2[t3], n3), n3, 0);
            }
          });
        }
        parse(e2, t2 = "$root") {
          const i2 = this.processor.toView(e2);
          return this.toModel(i2, t2);
        }
        toModel(e2, t2 = "$root") {
          return this.model.change((i2) => this.upcastDispatcher.convert(e2, i2, t2));
        }
        addStyleProcessorRules(e2) {
          e2(this.stylesProcessor);
        }
        registerRawContentMatcher(e2) {
          this.processor && this.processor !== this.htmlProcessor && this.processor.registerRawContentMatcher(e2), this.htmlProcessor.registerRawContentMatcher(e2);
        }
        destroy() {
          this.stopListening();
        }
        _checkIfRootsExists(e2) {
          for (const t2 of e2)
            if (!this.model.document.getRootNames().includes(t2))
              return false;
          return true;
        }
      }
      Ke(lc, Ue);
      class dc {
        constructor(e2, t2) {
          this._helpers = new Map(), this._downcast = en(e2), this._createConversionHelpers({ name: "downcast", dispatchers: this._downcast, isDowncast: true }), this._upcast = en(t2), this._createConversionHelpers({ name: "upcast", dispatchers: this._upcast, isDowncast: false });
        }
        addAlias(e2, t2) {
          const i2 = this._downcast.includes(t2);
          if (!this._upcast.includes(t2) && !i2)
            throw new c.a("conversion-add-alias-dispatcher-not-registered", this);
          this._createConversionHelpers({ name: e2, dispatchers: [t2], isDowncast: i2 });
        }
        for(e2) {
          if (!this._helpers.has(e2))
            throw new c.a("conversion-for-unknown-group", this);
          return this._helpers.get(e2);
        }
        elementToElement(e2) {
          this.for("downcast").elementToElement(e2);
          for (const { model: t2, view: i2 } of hc(e2))
            this.for("upcast").elementToElement({ model: t2, view: i2, converterPriority: e2.converterPriority });
        }
        attributeToElement(e2) {
          this.for("downcast").attributeToElement(e2);
          for (const { model: t2, view: i2 } of hc(e2))
            this.for("upcast").elementToAttribute({ view: i2, model: t2, converterPriority: e2.converterPriority });
        }
        attributeToAttribute(e2) {
          this.for("downcast").attributeToAttribute(e2);
          for (const { model: t2, view: i2 } of hc(e2))
            this.for("upcast").attributeToAttribute({ view: i2, model: t2 });
        }
        _createConversionHelpers({ name: e2, dispatchers: t2, isDowncast: i2 }) {
          if (this._helpers.has(e2))
            throw new c.a("conversion-group-exists", this);
          const n2 = i2 ? new Aa(t2) : new Oa(t2);
          this._helpers.set(e2, n2);
        }
      }
      function* hc(e2) {
        if (e2.model.values)
          for (const t2 of e2.model.values) {
            const i2 = { key: e2.model.key, value: t2 }, n2 = e2.view[t2], o2 = e2.upcastAlso ? e2.upcastAlso[t2] : void 0;
            yield* uc(i2, n2, o2);
          }
        else
          yield* uc(e2.model, e2.view, e2.upcastAlso);
      }
      function* uc(e2, t2, i2) {
        if (yield { model: e2, view: t2 }, i2)
          for (const t3 of en(i2))
            yield { model: e2, view: t3 };
      }
      class gc {
        constructor(e2 = "default") {
          this.operations = [], this.type = e2;
        }
        get baseVersion() {
          for (const e2 of this.operations)
            if (e2.baseVersion !== null)
              return e2.baseVersion;
          return null;
        }
        addOperation(e2) {
          return e2.batch = this, this.operations.push(e2), e2;
        }
      }
      class mc {
        constructor(e2) {
          this.baseVersion = e2, this.isDocumentOperation = this.baseVersion !== null, this.batch = null;
        }
        _validate() {
        }
        toJSON() {
          const e2 = Object.assign({}, this);
          return e2.__className = this.constructor.className, delete e2.batch, delete e2.isDocumentOperation, e2;
        }
        static get className() {
          return "Operation";
        }
        static fromJSON(e2) {
          return new this(e2.baseVersion);
        }
      }
      class fc {
        constructor(e2) {
          this.markers = new Map(), this._children = new Ks(), e2 && this._insertChild(0, e2);
        }
        [Symbol.iterator]() {
          return this.getChildren();
        }
        get childCount() {
          return this._children.length;
        }
        get maxOffset() {
          return this._children.maxOffset;
        }
        get isEmpty() {
          return this.childCount === 0;
        }
        get root() {
          return this;
        }
        get parent() {
          return null;
        }
        is(e2) {
          return e2 === "documentFragment" || e2 === "model:documentFragment";
        }
        getChild(e2) {
          return this._children.getNode(e2);
        }
        getChildren() {
          return this._children[Symbol.iterator]();
        }
        getChildIndex(e2) {
          return this._children.getNodeIndex(e2);
        }
        getChildStartOffset(e2) {
          return this._children.getNodeStartOffset(e2);
        }
        getPath() {
          return [];
        }
        getNodeByPath(e2) {
          let t2 = this;
          for (const i2 of e2)
            t2 = t2.getChild(t2.offsetToIndex(i2));
          return t2;
        }
        offsetToIndex(e2) {
          return this._children.offsetToIndex(e2);
        }
        toJSON() {
          const e2 = [];
          for (const t2 of this._children)
            e2.push(t2.toJSON());
          return e2;
        }
        static fromJSON(e2) {
          const t2 = [];
          for (const i2 of e2)
            i2.name ? t2.push(Qs.fromJSON(i2)) : t2.push(Ys.fromJSON(i2));
          return new fc(t2);
        }
        _appendChild(e2) {
          this._insertChild(this.childCount, e2);
        }
        _insertChild(e2, t2) {
          const i2 = function(e3) {
            if (typeof e3 == "string")
              return [new Ys(e3)];
            Ji(e3) || (e3 = [e3]);
            return Array.from(e3).map((e4) => typeof e4 == "string" ? new Ys(e4) : e4 instanceof Gs ? new Ys(e4.data, e4.getAttributes()) : e4);
          }(t2);
          for (const e3 of i2)
            e3.parent !== null && e3._remove(), e3.parent = this;
          this._children._insertNodes(e2, i2);
        }
        _removeChildren(e2, t2 = 1) {
          const i2 = this._children._removeNodes(e2, t2);
          for (const e3 of i2)
            e3.parent = null;
          return i2;
        }
      }
      function pc(e2, t2) {
        const i2 = (t2 = kc(t2)).reduce((e3, t3) => e3 + t3.offsetSize, 0), n2 = e2.parent;
        vc(e2);
        const o2 = e2.index;
        return n2._insertChild(o2, t2), _c(n2, o2 + t2.length), _c(n2, o2), new na(e2, e2.getShiftedBy(i2));
      }
      function bc(e2) {
        if (!e2.isFlat)
          throw new c.a("operation-utils-remove-range-not-flat", this);
        const t2 = e2.start.parent;
        vc(e2.start), vc(e2.end);
        const i2 = t2._removeChildren(e2.start.index, e2.end.index - e2.start.index);
        return _c(t2, e2.start.index), i2;
      }
      function wc(e2, t2) {
        if (!e2.isFlat)
          throw new c.a("operation-utils-move-range-not-flat", this);
        const i2 = bc(e2);
        return pc(t2 = t2._getTransformedByDeletion(e2.start, e2.end.offset - e2.start.offset), i2);
      }
      function kc(e2) {
        const t2 = [];
        e2 instanceof Array || (e2 = [e2]);
        for (let i2 = 0; i2 < e2.length; i2++)
          if (typeof e2[i2] == "string")
            t2.push(new Ys(e2[i2]));
          else if (e2[i2] instanceof Gs)
            t2.push(new Ys(e2[i2].data, e2[i2].getAttributes()));
          else if (e2[i2] instanceof fc || e2[i2] instanceof Ks)
            for (const n2 of e2[i2])
              t2.push(n2);
          else
            e2[i2] instanceof $s && t2.push(e2[i2]);
        for (let e3 = 1; e3 < t2.length; e3++) {
          const i2 = t2[e3], n2 = t2[e3 - 1];
          i2 instanceof Ys && n2 instanceof Ys && yc(i2, n2) && (t2.splice(e3 - 1, 2, new Ys(n2.data + i2.data, n2.getAttributes())), e3--);
        }
        return t2;
      }
      function _c(e2, t2) {
        const i2 = e2.getChild(t2 - 1), n2 = e2.getChild(t2);
        if (i2 && n2 && i2.is("$text") && n2.is("$text") && yc(i2, n2)) {
          const o2 = new Ys(i2.data + n2.data, i2.getAttributes());
          e2._removeChildren(t2 - 1, 2), e2._insertChild(t2 - 1, o2);
        }
      }
      function vc(e2) {
        const t2 = e2.textNode, i2 = e2.parent;
        if (t2) {
          const n2 = e2.offset - t2.startOffset, o2 = t2.index;
          i2._removeChildren(o2, 1);
          const r2 = new Ys(t2.data.substr(0, n2), t2.getAttributes()), s2 = new Ys(t2.data.substr(n2), t2.getAttributes());
          i2._insertChild(o2, [r2, s2]);
        }
      }
      function yc(e2, t2) {
        const i2 = e2.getAttributes(), n2 = t2.getAttributes();
        for (const e3 of i2) {
          if (e3[1] !== t2.getAttribute(e3[0]))
            return false;
          n2.next();
        }
        return n2.next().done;
      }
      var xc = function(e2, t2) {
        return Qr(e2, t2);
      };
      class Ac extends mc {
        constructor(e2, t2, i2, n2, o2) {
          super(o2), this.range = e2.clone(), this.key = t2, this.oldValue = i2 === void 0 ? null : i2, this.newValue = n2 === void 0 ? null : n2;
        }
        get type() {
          return this.oldValue === null ? "addAttribute" : this.newValue === null ? "removeAttribute" : "changeAttribute";
        }
        clone() {
          return new Ac(this.range, this.key, this.oldValue, this.newValue, this.baseVersion);
        }
        getReversed() {
          return new Ac(this.range, this.key, this.newValue, this.oldValue, this.baseVersion + 1);
        }
        toJSON() {
          const e2 = super.toJSON();
          return e2.range = this.range.toJSON(), e2;
        }
        _validate() {
          if (!this.range.isFlat)
            throw new c.a("attribute-operation-range-not-flat", this);
          for (const e2 of this.range.getItems({ shallow: true })) {
            if (this.oldValue !== null && !xc(e2.getAttribute(this.key), this.oldValue))
              throw new c.a("attribute-operation-wrong-old-value", this, { item: e2, key: this.key, value: this.oldValue });
            if (this.oldValue === null && this.newValue !== null && e2.hasAttribute(this.key))
              throw new c.a("attribute-operation-attribute-exists", this, { node: e2, key: this.key });
          }
        }
        _execute() {
          xc(this.oldValue, this.newValue) || function(e2, t2, i2) {
            vc(e2.start), vc(e2.end);
            for (const n2 of e2.getItems({ shallow: true })) {
              const e3 = n2.is("$textProxy") ? n2.textNode : n2;
              i2 !== null ? e3._setAttribute(t2, i2) : e3._removeAttribute(t2), _c(e3.parent, e3.index);
            }
            _c(e2.end.parent, e2.end.index);
          }(this.range, this.key, this.newValue);
        }
        static get className() {
          return "AttributeOperation";
        }
        static fromJSON(e2, t2) {
          return new Ac(na.fromJSON(e2.range, t2), e2.key, e2.oldValue, e2.newValue, e2.baseVersion);
        }
      }
      class Cc extends mc {
        constructor(e2, t2) {
          super(null), this.sourcePosition = e2.clone(), this.howMany = t2;
        }
        get type() {
          return "detach";
        }
        toJSON() {
          const e2 = super.toJSON();
          return e2.sourcePosition = this.sourcePosition.toJSON(), e2;
        }
        _validate() {
          if (this.sourcePosition.root.document)
            throw new c.a("detach-operation-on-document-node", this);
        }
        _execute() {
          bc(na._createFromPositionAndShift(this.sourcePosition, this.howMany));
        }
        static get className() {
          return "DetachOperation";
        }
      }
      class Tc extends mc {
        constructor(e2, t2, i2, n2) {
          super(n2), this.sourcePosition = e2.clone(), this.sourcePosition.stickiness = "toNext", this.howMany = t2, this.targetPosition = i2.clone(), this.targetPosition.stickiness = "toNone";
        }
        get type() {
          return this.targetPosition.root.rootName == "$graveyard" ? "remove" : this.sourcePosition.root.rootName == "$graveyard" ? "reinsert" : "move";
        }
        clone() {
          return new this.constructor(this.sourcePosition, this.howMany, this.targetPosition, this.baseVersion);
        }
        getMovedRangeStart() {
          return this.targetPosition._getTransformedByDeletion(this.sourcePosition, this.howMany);
        }
        getReversed() {
          const e2 = this.sourcePosition._getTransformedByInsertion(this.targetPosition, this.howMany);
          return new this.constructor(this.getMovedRangeStart(), this.howMany, e2, this.baseVersion + 1);
        }
        _validate() {
          const e2 = this.sourcePosition.parent, t2 = this.targetPosition.parent, i2 = this.sourcePosition.offset, n2 = this.targetPosition.offset;
          if (i2 + this.howMany > e2.maxOffset)
            throw new c.a("move-operation-nodes-do-not-exist", this);
          if (e2 === t2 && i2 < n2 && n2 < i2 + this.howMany)
            throw new c.a("move-operation-range-into-itself", this);
          if (this.sourcePosition.root == this.targetPosition.root && cn(this.sourcePosition.getParentPath(), this.targetPosition.getParentPath()) == "prefix") {
            const e3 = this.sourcePosition.path.length - 1;
            if (this.targetPosition.path[e3] >= i2 && this.targetPosition.path[e3] < i2 + this.howMany)
              throw new c.a("move-operation-node-into-itself", this);
          }
        }
        _execute() {
          wc(na._createFromPositionAndShift(this.sourcePosition, this.howMany), this.targetPosition);
        }
        toJSON() {
          const e2 = super.toJSON();
          return e2.sourcePosition = this.sourcePosition.toJSON(), e2.targetPosition = this.targetPosition.toJSON(), e2;
        }
        static get className() {
          return "MoveOperation";
        }
        static fromJSON(e2, t2) {
          const i2 = Xs.fromJSON(e2.sourcePosition, t2), n2 = Xs.fromJSON(e2.targetPosition, t2);
          return new this(i2, e2.howMany, n2, e2.baseVersion);
        }
      }
      class Ec extends mc {
        constructor(e2, t2, i2) {
          super(i2), this.position = e2.clone(), this.position.stickiness = "toNone", this.nodes = new Ks(kc(t2)), this.shouldReceiveAttributes = false;
        }
        get type() {
          return "insert";
        }
        get howMany() {
          return this.nodes.maxOffset;
        }
        clone() {
          const e2 = new Ks([...this.nodes].map((e3) => e3._clone(true))), t2 = new Ec(this.position, e2, this.baseVersion);
          return t2.shouldReceiveAttributes = this.shouldReceiveAttributes, t2;
        }
        getReversed() {
          const e2 = this.position.root.document.graveyard, t2 = new Xs(e2, [0]);
          return new Tc(this.position, this.nodes.maxOffset, t2, this.baseVersion + 1);
        }
        _validate() {
          const e2 = this.position.parent;
          if (!e2 || e2.maxOffset < this.position.offset)
            throw new c.a("insert-operation-position-invalid", this);
        }
        _execute() {
          const e2 = this.nodes;
          this.nodes = new Ks([...e2].map((e3) => e3._clone(true))), pc(this.position, e2);
        }
        toJSON() {
          const e2 = super.toJSON();
          return e2.position = this.position.toJSON(), e2.nodes = this.nodes.toJSON(), e2;
        }
        static get className() {
          return "InsertOperation";
        }
        static fromJSON(e2, t2) {
          const i2 = [];
          for (const t3 of e2.nodes)
            t3.name ? i2.push(Qs.fromJSON(t3)) : i2.push(Ys.fromJSON(t3));
          const n2 = new Ec(Xs.fromJSON(e2.position, t2), i2, e2.baseVersion);
          return n2.shouldReceiveAttributes = e2.shouldReceiveAttributes, n2;
        }
      }
      class Ic extends mc {
        constructor(e2, t2, i2, n2, o2, r2) {
          super(r2), this.name = e2, this.oldRange = t2 ? t2.clone() : null, this.newRange = i2 ? i2.clone() : null, this.affectsData = o2, this._markers = n2;
        }
        get type() {
          return "marker";
        }
        clone() {
          return new Ic(this.name, this.oldRange, this.newRange, this._markers, this.affectsData, this.baseVersion);
        }
        getReversed() {
          return new Ic(this.name, this.newRange, this.oldRange, this._markers, this.affectsData, this.baseVersion + 1);
        }
        _execute() {
          const e2 = this.newRange ? "_set" : "_remove";
          this._markers[e2](this.name, this.newRange, true, this.affectsData);
        }
        toJSON() {
          const e2 = super.toJSON();
          return this.oldRange && (e2.oldRange = this.oldRange.toJSON()), this.newRange && (e2.newRange = this.newRange.toJSON()), delete e2._markers, e2;
        }
        static get className() {
          return "MarkerOperation";
        }
        static fromJSON(e2, t2) {
          return new Ic(e2.name, e2.oldRange ? na.fromJSON(e2.oldRange, t2) : null, e2.newRange ? na.fromJSON(e2.newRange, t2) : null, t2.model.markers, e2.affectsData, e2.baseVersion);
        }
      }
      class Sc extends mc {
        constructor(e2, t2, i2, n2) {
          super(n2), this.position = e2, this.position.stickiness = "toNext", this.oldName = t2, this.newName = i2;
        }
        get type() {
          return "rename";
        }
        clone() {
          return new Sc(this.position.clone(), this.oldName, this.newName, this.baseVersion);
        }
        getReversed() {
          return new Sc(this.position.clone(), this.newName, this.oldName, this.baseVersion + 1);
        }
        _validate() {
          const e2 = this.position.nodeAfter;
          if (!(e2 instanceof Qs))
            throw new c.a("rename-operation-wrong-position", this);
          if (e2.name !== this.oldName)
            throw new c.a("rename-operation-wrong-name", this);
        }
        _execute() {
          this.position.nodeAfter.name = this.newName;
        }
        toJSON() {
          const e2 = super.toJSON();
          return e2.position = this.position.toJSON(), e2;
        }
        static get className() {
          return "RenameOperation";
        }
        static fromJSON(e2, t2) {
          return new Sc(Xs.fromJSON(e2.position, t2), e2.oldName, e2.newName, e2.baseVersion);
        }
      }
      class Pc extends mc {
        constructor(e2, t2, i2, n2, o2) {
          super(o2), this.root = e2, this.key = t2, this.oldValue = i2, this.newValue = n2;
        }
        get type() {
          return this.oldValue === null ? "addRootAttribute" : this.newValue === null ? "removeRootAttribute" : "changeRootAttribute";
        }
        clone() {
          return new Pc(this.root, this.key, this.oldValue, this.newValue, this.baseVersion);
        }
        getReversed() {
          return new Pc(this.root, this.key, this.newValue, this.oldValue, this.baseVersion + 1);
        }
        _validate() {
          if (this.root != this.root.root || this.root.is("documentFragment"))
            throw new c.a("rootattribute-operation-not-a-root", this, { root: this.root, key: this.key });
          if (this.oldValue !== null && this.root.getAttribute(this.key) !== this.oldValue)
            throw new c.a("rootattribute-operation-wrong-old-value", this, { root: this.root, key: this.key });
          if (this.oldValue === null && this.newValue !== null && this.root.hasAttribute(this.key))
            throw new c.a("rootattribute-operation-attribute-exists", this, { root: this.root, key: this.key });
        }
        _execute() {
          this.newValue !== null ? this.root._setAttribute(this.key, this.newValue) : this.root._removeAttribute(this.key);
        }
        toJSON() {
          const e2 = super.toJSON();
          return e2.root = this.root.toJSON(), e2;
        }
        static get className() {
          return "RootAttributeOperation";
        }
        static fromJSON(e2, t2) {
          if (!t2.getRoot(e2.root))
            throw new c.a("rootattribute-operation-fromjson-no-root", this, { rootName: e2.root });
          return new Pc(t2.getRoot(e2.root), e2.key, e2.oldValue, e2.newValue, e2.baseVersion);
        }
      }
      class Mc extends mc {
        constructor(e2, t2, i2, n2, o2) {
          super(o2), this.sourcePosition = e2.clone(), this.sourcePosition.stickiness = "toPrevious", this.howMany = t2, this.targetPosition = i2.clone(), this.targetPosition.stickiness = "toNext", this.graveyardPosition = n2.clone();
        }
        get type() {
          return "merge";
        }
        get deletionPosition() {
          return new Xs(this.sourcePosition.root, this.sourcePosition.path.slice(0, -1));
        }
        get movedRange() {
          const e2 = this.sourcePosition.getShiftedBy(Number.POSITIVE_INFINITY);
          return new na(this.sourcePosition, e2);
        }
        clone() {
          return new this.constructor(this.sourcePosition, this.howMany, this.targetPosition, this.graveyardPosition, this.baseVersion);
        }
        getReversed() {
          const e2 = this.targetPosition._getTransformedByMergeOperation(this), t2 = this.sourcePosition.path.slice(0, -1), i2 = new Xs(this.sourcePosition.root, t2)._getTransformedByMergeOperation(this);
          return new Nc(e2, this.howMany, i2, this.graveyardPosition, this.baseVersion + 1);
        }
        _validate() {
          const e2 = this.sourcePosition.parent, t2 = this.targetPosition.parent;
          if (!e2.parent)
            throw new c.a("merge-operation-source-position-invalid", this);
          if (!t2.parent)
            throw new c.a("merge-operation-target-position-invalid", this);
          if (this.howMany != e2.maxOffset)
            throw new c.a("merge-operation-how-many-invalid", this);
        }
        _execute() {
          const e2 = this.sourcePosition.parent;
          wc(na._createIn(e2), this.targetPosition), wc(na._createOn(e2), this.graveyardPosition);
        }
        toJSON() {
          const e2 = super.toJSON();
          return e2.sourcePosition = e2.sourcePosition.toJSON(), e2.targetPosition = e2.targetPosition.toJSON(), e2.graveyardPosition = e2.graveyardPosition.toJSON(), e2;
        }
        static get className() {
          return "MergeOperation";
        }
        static fromJSON(e2, t2) {
          const i2 = Xs.fromJSON(e2.sourcePosition, t2), n2 = Xs.fromJSON(e2.targetPosition, t2), o2 = Xs.fromJSON(e2.graveyardPosition, t2);
          return new this(i2, e2.howMany, n2, o2, e2.baseVersion);
        }
      }
      class Nc extends mc {
        constructor(e2, t2, i2, n2, o2) {
          super(o2), this.splitPosition = e2.clone(), this.splitPosition.stickiness = "toNext", this.howMany = t2, this.insertionPosition = i2, this.graveyardPosition = n2 ? n2.clone() : null, this.graveyardPosition && (this.graveyardPosition.stickiness = "toNext");
        }
        get type() {
          return "split";
        }
        get moveTargetPosition() {
          const e2 = this.insertionPosition.path.slice();
          return e2.push(0), new Xs(this.insertionPosition.root, e2);
        }
        get movedRange() {
          const e2 = this.splitPosition.getShiftedBy(Number.POSITIVE_INFINITY);
          return new na(this.splitPosition, e2);
        }
        clone() {
          return new this.constructor(this.splitPosition, this.howMany, this.insertionPosition, this.graveyardPosition, this.baseVersion);
        }
        getReversed() {
          const e2 = this.splitPosition.root.document.graveyard, t2 = new Xs(e2, [0]);
          return new Mc(this.moveTargetPosition, this.howMany, this.splitPosition, t2, this.baseVersion + 1);
        }
        _validate() {
          const e2 = this.splitPosition.parent, t2 = this.splitPosition.offset;
          if (!e2 || e2.maxOffset < t2)
            throw new c.a("split-operation-position-invalid", this);
          if (!e2.parent)
            throw new c.a("split-operation-split-in-root", this);
          if (this.howMany != e2.maxOffset - this.splitPosition.offset)
            throw new c.a("split-operation-how-many-invalid", this);
          if (this.graveyardPosition && !this.graveyardPosition.nodeAfter)
            throw new c.a("split-operation-graveyard-position-invalid", this);
        }
        _execute() {
          const e2 = this.splitPosition.parent;
          if (this.graveyardPosition)
            wc(na._createFromPositionAndShift(this.graveyardPosition, 1), this.insertionPosition);
          else {
            const t2 = e2._clone();
            pc(this.insertionPosition, t2);
          }
          wc(new na(Xs._createAt(e2, this.splitPosition.offset), Xs._createAt(e2, e2.maxOffset)), this.moveTargetPosition);
        }
        toJSON() {
          const e2 = super.toJSON();
          return e2.splitPosition = this.splitPosition.toJSON(), e2.insertionPosition = this.insertionPosition.toJSON(), this.graveyardPosition && (e2.graveyardPosition = this.graveyardPosition.toJSON()), e2;
        }
        static get className() {
          return "SplitOperation";
        }
        static getInsertionPosition(e2) {
          const t2 = e2.path.slice(0, -1);
          return t2[t2.length - 1]++, new Xs(e2.root, t2, "toPrevious");
        }
        static fromJSON(e2, t2) {
          const i2 = Xs.fromJSON(e2.splitPosition, t2), n2 = Xs.fromJSON(e2.insertionPosition, t2), o2 = e2.graveyardPosition ? Xs.fromJSON(e2.graveyardPosition, t2) : null;
          return new this(i2, e2.howMany, n2, o2, e2.baseVersion);
        }
      }
      class Rc extends Qs {
        constructor(e2, t2, i2 = "main") {
          super(t2), this._document = e2, this.rootName = i2;
        }
        get document() {
          return this._document;
        }
        is(e2, t2) {
          return t2 ? t2 === this.name && (e2 === "rootElement" || e2 === "model:rootElement" || e2 === "element" || e2 === "model:element") : e2 === "rootElement" || e2 === "model:rootElement" || e2 === "element" || e2 === "model:element" || e2 === "node" || e2 === "model:node";
        }
        toJSON() {
          return this.rootName;
        }
      }
      class Oc {
        constructor(e2, t2) {
          this.model = e2, this.batch = t2;
        }
        createText(e2, t2) {
          return new Ys(e2, t2);
        }
        createElement(e2, t2) {
          return new Qs(e2, t2);
        }
        createDocumentFragment() {
          return new fc();
        }
        cloneElement(e2, t2 = true) {
          return e2._clone(t2);
        }
        insert(e2, t2, i2 = 0) {
          if (this._assertWriterUsedCorrectly(), e2 instanceof Ys && e2.data == "")
            return;
          const n2 = Xs._createAt(t2, i2);
          if (e2.parent) {
            if (jc(e2.root, n2.root))
              return void this.move(na._createOn(e2), n2);
            if (e2.root.document)
              throw new c.a("model-writer-insert-forbidden-move", this);
            this.remove(e2);
          }
          const o2 = n2.root.document ? n2.root.document.version : null, r2 = new Ec(n2, e2, o2);
          if (e2 instanceof Ys && (r2.shouldReceiveAttributes = true), this.batch.addOperation(r2), this.model.applyOperation(r2), e2 instanceof fc)
            for (const [t3, i3] of e2.markers) {
              const e3 = Xs._createAt(i3.root, 0), o3 = { range: new na(i3.start._getCombined(e3, n2), i3.end._getCombined(e3, n2)), usingOperation: true, affectsData: true };
              this.model.markers.has(t3) ? this.updateMarker(t3, o3) : this.addMarker(t3, o3);
            }
        }
        insertText(e2, t2, i2, n2) {
          t2 instanceof fc || t2 instanceof Qs || t2 instanceof Xs ? this.insert(this.createText(e2), t2, i2) : this.insert(this.createText(e2, t2), i2, n2);
        }
        insertElement(e2, t2, i2, n2) {
          t2 instanceof fc || t2 instanceof Qs || t2 instanceof Xs ? this.insert(this.createElement(e2), t2, i2) : this.insert(this.createElement(e2, t2), i2, n2);
        }
        append(e2, t2) {
          this.insert(e2, t2, "end");
        }
        appendText(e2, t2, i2) {
          t2 instanceof fc || t2 instanceof Qs ? this.insert(this.createText(e2), t2, "end") : this.insert(this.createText(e2, t2), i2, "end");
        }
        appendElement(e2, t2, i2) {
          t2 instanceof fc || t2 instanceof Qs ? this.insert(this.createElement(e2), t2, "end") : this.insert(this.createElement(e2, t2), i2, "end");
        }
        setAttribute(e2, t2, i2) {
          if (this._assertWriterUsedCorrectly(), i2 instanceof na) {
            const n2 = i2.getMinimalFlatRanges();
            for (const i3 of n2)
              zc(this, e2, t2, i3);
          } else
            Dc(this, e2, t2, i2);
        }
        setAttributes(e2, t2) {
          for (const [i2, n2] of gn(e2))
            this.setAttribute(i2, n2, t2);
        }
        removeAttribute(e2, t2) {
          if (this._assertWriterUsedCorrectly(), t2 instanceof na) {
            const i2 = t2.getMinimalFlatRanges();
            for (const t3 of i2)
              zc(this, e2, null, t3);
          } else
            Dc(this, e2, null, t2);
        }
        clearAttributes(e2) {
          this._assertWriterUsedCorrectly();
          const t2 = (e3) => {
            for (const t3 of e3.getAttributeKeys())
              this.removeAttribute(t3, e3);
          };
          if (e2 instanceof na)
            for (const i2 of e2.getItems())
              t2(i2);
          else
            t2(e2);
        }
        move(e2, t2, i2) {
          if (this._assertWriterUsedCorrectly(), !(e2 instanceof na))
            throw new c.a("writer-move-invalid-range", this);
          if (!e2.isFlat)
            throw new c.a("writer-move-range-not-flat", this);
          const n2 = Xs._createAt(t2, i2);
          if (n2.isEqual(e2.start))
            return;
          if (this._addOperationForAffectedMarkers("move", e2), !jc(e2.root, n2.root))
            throw new c.a("writer-move-different-document", this);
          const o2 = e2.root.document ? e2.root.document.version : null, r2 = new Tc(e2.start, e2.end.offset - e2.start.offset, n2, o2);
          this.batch.addOperation(r2), this.model.applyOperation(r2);
        }
        remove(e2) {
          this._assertWriterUsedCorrectly();
          const t2 = (e2 instanceof na ? e2 : na._createOn(e2)).getMinimalFlatRanges().reverse();
          for (const e3 of t2)
            this._addOperationForAffectedMarkers("move", e3), Vc(e3.start, e3.end.offset - e3.start.offset, this.batch, this.model);
        }
        merge(e2) {
          this._assertWriterUsedCorrectly();
          const t2 = e2.nodeBefore, i2 = e2.nodeAfter;
          if (this._addOperationForAffectedMarkers("merge", e2), !(t2 instanceof Qs))
            throw new c.a("writer-merge-no-element-before", this);
          if (!(i2 instanceof Qs))
            throw new c.a("writer-merge-no-element-after", this);
          e2.root.document ? this._merge(e2) : this._mergeDetached(e2);
        }
        createPositionFromPath(e2, t2, i2) {
          return this.model.createPositionFromPath(e2, t2, i2);
        }
        createPositionAt(e2, t2) {
          return this.model.createPositionAt(e2, t2);
        }
        createPositionAfter(e2) {
          return this.model.createPositionAfter(e2);
        }
        createPositionBefore(e2) {
          return this.model.createPositionBefore(e2);
        }
        createRange(e2, t2) {
          return this.model.createRange(e2, t2);
        }
        createRangeIn(e2) {
          return this.model.createRangeIn(e2);
        }
        createRangeOn(e2) {
          return this.model.createRangeOn(e2);
        }
        createSelection(e2, t2, i2) {
          return this.model.createSelection(e2, t2, i2);
        }
        _mergeDetached(e2) {
          const t2 = e2.nodeBefore, i2 = e2.nodeAfter;
          this.move(na._createIn(i2), Xs._createAt(t2, "end")), this.remove(i2);
        }
        _merge(e2) {
          const t2 = Xs._createAt(e2.nodeBefore, "end"), i2 = Xs._createAt(e2.nodeAfter, 0), n2 = e2.root.document.graveyard, o2 = new Xs(n2, [0]), r2 = e2.root.document.version, s2 = new Mc(i2, e2.nodeAfter.maxOffset, t2, o2, r2);
          this.batch.addOperation(s2), this.model.applyOperation(s2);
        }
        rename(e2, t2) {
          if (this._assertWriterUsedCorrectly(), !(e2 instanceof Qs))
            throw new c.a("writer-rename-not-element-instance", this);
          const i2 = e2.root.document ? e2.root.document.version : null, n2 = new Sc(Xs._createBefore(e2), e2.name, t2, i2);
          this.batch.addOperation(n2), this.model.applyOperation(n2);
        }
        split(e2, t2) {
          this._assertWriterUsedCorrectly();
          let i2, n2, o2 = e2.parent;
          if (!o2.parent)
            throw new c.a("writer-split-element-no-parent", this);
          if (t2 || (t2 = o2.parent), !e2.parent.getAncestors({ includeSelf: true }).includes(t2))
            throw new c.a("writer-split-invalid-limit-element", this);
          do {
            const t3 = o2.root.document ? o2.root.document.version : null, r2 = o2.maxOffset - e2.offset, s2 = Nc.getInsertionPosition(e2), a2 = new Nc(e2, r2, s2, null, t3);
            this.batch.addOperation(a2), this.model.applyOperation(a2), i2 || n2 || (i2 = o2, n2 = e2.parent.nextSibling), o2 = (e2 = this.createPositionAfter(e2.parent)).parent;
          } while (o2 !== t2);
          return { position: e2, range: new na(Xs._createAt(i2, "end"), Xs._createAt(n2, 0)) };
        }
        wrap(e2, t2) {
          if (this._assertWriterUsedCorrectly(), !e2.isFlat)
            throw new c.a("writer-wrap-range-not-flat", this);
          const i2 = t2 instanceof Qs ? t2 : new Qs(t2);
          if (i2.childCount > 0)
            throw new c.a("writer-wrap-element-not-empty", this);
          if (i2.parent !== null)
            throw new c.a("writer-wrap-element-attached", this);
          this.insert(i2, e2.start);
          const n2 = new na(e2.start.getShiftedBy(1), e2.end.getShiftedBy(1));
          this.move(n2, Xs._createAt(i2, 0));
        }
        unwrap(e2) {
          if (this._assertWriterUsedCorrectly(), e2.parent === null)
            throw new c.a("writer-unwrap-element-no-parent", this);
          this.move(na._createIn(e2), this.createPositionAfter(e2)), this.remove(e2);
        }
        addMarker(e2, t2) {
          if (this._assertWriterUsedCorrectly(), !t2 || typeof t2.usingOperation != "boolean")
            throw new c.a("writer-addmarker-no-usingoperation", this);
          const i2 = t2.usingOperation, n2 = t2.range, o2 = t2.affectsData !== void 0 && t2.affectsData;
          if (this.model.markers.has(e2))
            throw new c.a("writer-addmarker-marker-exists", this);
          if (!n2)
            throw new c.a("writer-addmarker-no-range", this);
          return i2 ? (Lc(this, e2, null, n2, o2), this.model.markers.get(e2)) : this.model.markers._set(e2, n2, i2, o2);
        }
        updateMarker(e2, t2) {
          this._assertWriterUsedCorrectly();
          const i2 = typeof e2 == "string" ? e2 : e2.name, n2 = this.model.markers.get(i2);
          if (!n2)
            throw new c.a("writer-updatemarker-marker-not-exists", this);
          if (!t2)
            return void this.model.markers._refresh(n2);
          const o2 = typeof t2.usingOperation == "boolean", r2 = typeof t2.affectsData == "boolean", s2 = r2 ? t2.affectsData : n2.affectsData;
          if (!o2 && !t2.range && !r2)
            throw new c.a("writer-updatemarker-wrong-options", this);
          const a2 = n2.getRange(), l2 = t2.range ? t2.range : a2;
          o2 && t2.usingOperation !== n2.managedUsingOperations ? t2.usingOperation ? Lc(this, i2, null, l2, s2) : (Lc(this, i2, a2, null, s2), this.model.markers._set(i2, l2, void 0, s2)) : n2.managedUsingOperations ? Lc(this, i2, a2, l2, s2) : this.model.markers._set(i2, l2, void 0, s2);
        }
        removeMarker(e2) {
          this._assertWriterUsedCorrectly();
          const t2 = typeof e2 == "string" ? e2 : e2.name;
          if (!this.model.markers.has(t2))
            throw new c.a("writer-removemarker-no-marker", this);
          const i2 = this.model.markers.get(t2);
          if (!i2.managedUsingOperations)
            return void this.model.markers._remove(t2);
          Lc(this, t2, i2.getRange(), null, i2.affectsData);
        }
        setSelection(e2, t2, i2) {
          this._assertWriterUsedCorrectly(), this.model.document.selection._setTo(e2, t2, i2);
        }
        setSelectionFocus(e2, t2) {
          this._assertWriterUsedCorrectly(), this.model.document.selection._setFocus(e2, t2);
        }
        setSelectionAttribute(e2, t2) {
          if (this._assertWriterUsedCorrectly(), typeof e2 == "string")
            this._setSelectionAttribute(e2, t2);
          else
            for (const [t3, i2] of gn(e2))
              this._setSelectionAttribute(t3, i2);
        }
        removeSelectionAttribute(e2) {
          if (this._assertWriterUsedCorrectly(), typeof e2 == "string")
            this._removeSelectionAttribute(e2);
          else
            for (const t2 of e2)
              this._removeSelectionAttribute(t2);
        }
        overrideSelectionGravity() {
          return this.model.document.selection._overrideGravity();
        }
        restoreSelectionGravity(e2) {
          this.model.document.selection._restoreGravity(e2);
        }
        _setSelectionAttribute(e2, t2) {
          const i2 = this.model.document.selection;
          if (i2.isCollapsed && i2.anchor.parent.isEmpty) {
            const n2 = ka._getStoreAttributeKey(e2);
            this.setAttribute(n2, t2, i2.anchor.parent);
          }
          i2._setAttribute(e2, t2);
        }
        _removeSelectionAttribute(e2) {
          const t2 = this.model.document.selection;
          if (t2.isCollapsed && t2.anchor.parent.isEmpty) {
            const i2 = ka._getStoreAttributeKey(e2);
            this.removeAttribute(i2, t2.anchor.parent);
          }
          t2._removeAttribute(e2);
        }
        _assertWriterUsedCorrectly() {
          if (this.model._currentWriter !== this)
            throw new c.a("writer-incorrect-use", this);
        }
        _addOperationForAffectedMarkers(e2, t2) {
          for (const i2 of this.model.markers) {
            if (!i2.managedUsingOperations)
              continue;
            const n2 = i2.getRange();
            let o2 = false;
            if (e2 === "move")
              o2 = t2.containsPosition(n2.start) || t2.start.isEqual(n2.start) || t2.containsPosition(n2.end) || t2.end.isEqual(n2.end);
            else {
              const e3 = t2.nodeBefore, i3 = t2.nodeAfter, r2 = n2.start.parent == e3 && n2.start.isAtEnd, s2 = n2.end.parent == i3 && n2.end.offset == 0, a2 = n2.end.nodeAfter == i3, c2 = n2.start.nodeAfter == i3;
              o2 = r2 || s2 || a2 || c2;
            }
            o2 && this.updateMarker(i2.name, { range: n2 });
          }
        }
      }
      function zc(e2, t2, i2, n2) {
        const o2 = e2.model, r2 = o2.document;
        let s2, a2, c2, l2 = n2.start;
        for (const e3 of n2.getWalker({ shallow: true }))
          c2 = e3.item.getAttribute(t2), s2 && a2 != c2 && (a2 != i2 && d2(), l2 = s2), s2 = e3.nextPosition, a2 = c2;
        function d2() {
          const n3 = new na(l2, s2), c3 = n3.root.document ? r2.version : null, d3 = new Ac(n3, t2, a2, i2, c3);
          e2.batch.addOperation(d3), o2.applyOperation(d3);
        }
        s2 instanceof Xs && s2 != l2 && a2 != i2 && d2();
      }
      function Dc(e2, t2, i2, n2) {
        const o2 = e2.model, r2 = o2.document, s2 = n2.getAttribute(t2);
        let a2, c2;
        if (s2 != i2) {
          if (n2.root === n2) {
            const e3 = n2.document ? r2.version : null;
            c2 = new Pc(n2, t2, s2, i2, e3);
          } else {
            a2 = new na(Xs._createBefore(n2), e2.createPositionAfter(n2));
            const o3 = a2.root.document ? r2.version : null;
            c2 = new Ac(a2, t2, s2, i2, o3);
          }
          e2.batch.addOperation(c2), o2.applyOperation(c2);
        }
      }
      function Lc(e2, t2, i2, n2, o2) {
        const r2 = e2.model, s2 = r2.document, a2 = new Ic(t2, i2, n2, r2.markers, o2, s2.version);
        e2.batch.addOperation(a2), r2.applyOperation(a2);
      }
      function Vc(e2, t2, i2, n2) {
        let o2;
        if (e2.root.document) {
          const i3 = n2.document, r2 = new Xs(i3.graveyard, [0]);
          o2 = new Tc(e2, t2, r2, i3.version);
        } else
          o2 = new Cc(e2, t2);
        i2.addOperation(o2), n2.applyOperation(o2);
      }
      function jc(e2, t2) {
        return e2 === t2 || e2 instanceof Rc && t2 instanceof Rc;
      }
      class Bc {
        constructor(e2) {
          this._markerCollection = e2, this._changesInElement = new Map(), this._elementSnapshots = new Map(), this._changedMarkers = new Map(), this._changeCount = 0, this._cachedChanges = null, this._cachedChangesWithGraveyard = null;
        }
        get isEmpty() {
          return this._changesInElement.size == 0 && this._changedMarkers.size == 0;
        }
        refreshItem(e2) {
          if (this._isInInsertedElement(e2.parent))
            return;
          this._markRemove(e2.parent, e2.startOffset, e2.offsetSize), this._markInsert(e2.parent, e2.startOffset, e2.offsetSize);
          const t2 = na._createOn(e2);
          for (const e3 of this._markerCollection.getMarkersIntersectingRange(t2)) {
            const t3 = e3.getRange();
            this.bufferMarkerChange(e3.name, t3, t3, e3.affectsData);
          }
          this._cachedChanges = null;
        }
        bufferOperation(e2) {
          switch (e2.type) {
            case "insert":
              if (this._isInInsertedElement(e2.position.parent))
                return;
              this._markInsert(e2.position.parent, e2.position.offset, e2.nodes.maxOffset);
              break;
            case "addAttribute":
            case "removeAttribute":
            case "changeAttribute":
              for (const t2 of e2.range.getItems({ shallow: true }))
                this._isInInsertedElement(t2.parent) || this._markAttribute(t2);
              break;
            case "remove":
            case "move":
            case "reinsert": {
              if (e2.sourcePosition.isEqual(e2.targetPosition) || e2.sourcePosition.getShiftedBy(e2.howMany).isEqual(e2.targetPosition))
                return;
              const t2 = this._isInInsertedElement(e2.sourcePosition.parent), i2 = this._isInInsertedElement(e2.targetPosition.parent);
              t2 || this._markRemove(e2.sourcePosition.parent, e2.sourcePosition.offset, e2.howMany), i2 || this._markInsert(e2.targetPosition.parent, e2.getMovedRangeStart().offset, e2.howMany);
              break;
            }
            case "rename": {
              if (this._isInInsertedElement(e2.position.parent))
                return;
              this._markRemove(e2.position.parent, e2.position.offset, 1), this._markInsert(e2.position.parent, e2.position.offset, 1);
              const t2 = na._createFromPositionAndShift(e2.position, 1);
              for (const e3 of this._markerCollection.getMarkersIntersectingRange(t2)) {
                const t3 = e3.getRange();
                this.bufferMarkerChange(e3.name, t3, t3, e3.affectsData);
              }
              break;
            }
            case "split": {
              const t2 = e2.splitPosition.parent;
              this._isInInsertedElement(t2) || this._markRemove(t2, e2.splitPosition.offset, e2.howMany), this._isInInsertedElement(e2.insertionPosition.parent) || this._markInsert(e2.insertionPosition.parent, e2.insertionPosition.offset, 1), e2.graveyardPosition && this._markRemove(e2.graveyardPosition.parent, e2.graveyardPosition.offset, 1);
              break;
            }
            case "merge": {
              const t2 = e2.sourcePosition.parent;
              this._isInInsertedElement(t2.parent) || this._markRemove(t2.parent, t2.startOffset, 1);
              const i2 = e2.graveyardPosition.parent;
              this._markInsert(i2, e2.graveyardPosition.offset, 1);
              const n2 = e2.targetPosition.parent;
              this._isInInsertedElement(n2) || this._markInsert(n2, e2.targetPosition.offset, t2.maxOffset);
              break;
            }
          }
          this._cachedChanges = null;
        }
        bufferMarkerChange(e2, t2, i2, n2) {
          const o2 = this._changedMarkers.get(e2);
          o2 ? (o2.newRange = i2, o2.affectsData = n2, o2.oldRange == null && o2.newRange == null && this._changedMarkers.delete(e2)) : this._changedMarkers.set(e2, { oldRange: t2, newRange: i2, affectsData: n2 });
        }
        getMarkersToRemove() {
          const e2 = [];
          for (const [t2, i2] of this._changedMarkers)
            i2.oldRange != null && e2.push({ name: t2, range: i2.oldRange });
          return e2;
        }
        getMarkersToAdd() {
          const e2 = [];
          for (const [t2, i2] of this._changedMarkers)
            i2.newRange != null && e2.push({ name: t2, range: i2.newRange });
          return e2;
        }
        getChangedMarkers() {
          return Array.from(this._changedMarkers).map((e2) => ({ name: e2[0], data: { oldRange: e2[1].oldRange, newRange: e2[1].newRange } }));
        }
        hasDataChanges() {
          for (const [, e2] of this._changedMarkers)
            if (e2.affectsData)
              return true;
          return this._changesInElement.size > 0;
        }
        getChanges(e2 = { includeChangesInGraveyard: false }) {
          if (this._cachedChanges)
            return e2.includeChangesInGraveyard ? this._cachedChangesWithGraveyard.slice() : this._cachedChanges.slice();
          let t2 = [];
          for (const e3 of this._changesInElement.keys()) {
            const i2 = this._changesInElement.get(e3).sort((e4, t3) => e4.offset === t3.offset ? e4.type != t3.type ? e4.type == "remove" ? -1 : 1 : 0 : e4.offset < t3.offset ? -1 : 1), n2 = this._elementSnapshots.get(e3), o2 = Fc(e3.getChildren()), r2 = Hc(n2.length, i2);
            let s2 = 0, a2 = 0;
            for (const i3 of r2)
              if (i3 === "i")
                t2.push(this._getInsertDiff(e3, s2, o2[s2].name)), s2++;
              else if (i3 === "r")
                t2.push(this._getRemoveDiff(e3, s2, n2[a2].name)), a2++;
              else if (i3 === "a") {
                const i4 = o2[s2].attributes, r3 = n2[a2].attributes;
                let c2;
                if (o2[s2].name == "$text")
                  c2 = new na(Xs._createAt(e3, s2), Xs._createAt(e3, s2 + 1));
                else {
                  const t3 = e3.offsetToIndex(s2);
                  c2 = new na(Xs._createAt(e3, s2), Xs._createAt(e3.getChild(t3), 0));
                }
                t2.push(...this._getAttributesDiff(c2, r3, i4)), s2++, a2++;
              } else
                s2++, a2++;
          }
          t2.sort((e3, t3) => e3.position.root != t3.position.root ? e3.position.root.rootName < t3.position.root.rootName ? -1 : 1 : e3.position.isEqual(t3.position) ? e3.changeCount - t3.changeCount : e3.position.isBefore(t3.position) ? -1 : 1);
          for (let e3 = 1, i2 = 0; e3 < t2.length; e3++) {
            const n2 = t2[i2], o2 = t2[e3], r2 = n2.type == "remove" && o2.type == "remove" && n2.name == "$text" && o2.name == "$text" && n2.position.isEqual(o2.position), s2 = n2.type == "insert" && o2.type == "insert" && n2.name == "$text" && o2.name == "$text" && n2.position.parent == o2.position.parent && n2.position.offset + n2.length == o2.position.offset, a2 = n2.type == "attribute" && o2.type == "attribute" && n2.position.parent == o2.position.parent && n2.range.isFlat && o2.range.isFlat && n2.position.offset + n2.length == o2.position.offset && n2.attributeKey == o2.attributeKey && n2.attributeOldValue == o2.attributeOldValue && n2.attributeNewValue == o2.attributeNewValue;
            r2 || s2 || a2 ? (n2.length++, a2 && (n2.range.end = n2.range.end.getShiftedBy(1)), t2[e3] = null) : i2 = e3;
          }
          t2 = t2.filter((e3) => e3);
          for (const e3 of t2)
            delete e3.changeCount, e3.type == "attribute" && (delete e3.position, delete e3.length);
          return this._changeCount = 0, this._cachedChangesWithGraveyard = t2.slice(), this._cachedChanges = t2.filter(Uc), e2.includeChangesInGraveyard ? this._cachedChangesWithGraveyard : this._cachedChanges;
        }
        reset() {
          this._changesInElement.clear(), this._elementSnapshots.clear(), this._changedMarkers.clear(), this._cachedChanges = null;
        }
        _markInsert(e2, t2, i2) {
          const n2 = { type: "insert", offset: t2, howMany: i2, count: this._changeCount++ };
          this._markChange(e2, n2);
        }
        _markRemove(e2, t2, i2) {
          const n2 = { type: "remove", offset: t2, howMany: i2, count: this._changeCount++ };
          this._markChange(e2, n2), this._removeAllNestedChanges(e2, t2, i2);
        }
        _markAttribute(e2) {
          const t2 = { type: "attribute", offset: e2.startOffset, howMany: e2.offsetSize, count: this._changeCount++ };
          this._markChange(e2.parent, t2);
        }
        _markChange(e2, t2) {
          this._makeSnapshot(e2);
          const i2 = this._getChangesForElement(e2);
          this._handleChange(t2, i2), i2.push(t2);
          for (let e3 = 0; e3 < i2.length; e3++)
            i2[e3].howMany < 1 && (i2.splice(e3, 1), e3--);
        }
        _getChangesForElement(e2) {
          let t2;
          return this._changesInElement.has(e2) ? t2 = this._changesInElement.get(e2) : (t2 = [], this._changesInElement.set(e2, t2)), t2;
        }
        _makeSnapshot(e2) {
          this._elementSnapshots.has(e2) || this._elementSnapshots.set(e2, Fc(e2.getChildren()));
        }
        _handleChange(e2, t2) {
          e2.nodesToHandle = e2.howMany;
          for (const i2 of t2) {
            const n2 = e2.offset + e2.howMany, o2 = i2.offset + i2.howMany;
            if (e2.type == "insert" && (i2.type == "insert" && (e2.offset <= i2.offset ? i2.offset += e2.howMany : e2.offset < o2 && (i2.howMany += e2.nodesToHandle, e2.nodesToHandle = 0)), i2.type == "remove" && e2.offset < i2.offset && (i2.offset += e2.howMany), i2.type == "attribute")) {
              if (e2.offset <= i2.offset)
                i2.offset += e2.howMany;
              else if (e2.offset < o2) {
                const o3 = i2.howMany;
                i2.howMany = e2.offset - i2.offset, t2.unshift({ type: "attribute", offset: n2, howMany: o3 - i2.howMany, count: this._changeCount++ });
              }
            }
            if (e2.type == "remove") {
              if (i2.type == "insert") {
                if (n2 <= i2.offset)
                  i2.offset -= e2.howMany;
                else if (n2 <= o2)
                  if (e2.offset < i2.offset) {
                    const t3 = n2 - i2.offset;
                    i2.offset = e2.offset, i2.howMany -= t3, e2.nodesToHandle -= t3;
                  } else
                    i2.howMany -= e2.nodesToHandle, e2.nodesToHandle = 0;
                else if (e2.offset <= i2.offset)
                  e2.nodesToHandle -= i2.howMany, i2.howMany = 0;
                else if (e2.offset < o2) {
                  const t3 = o2 - e2.offset;
                  i2.howMany -= t3, e2.nodesToHandle -= t3;
                }
              }
              if (i2.type == "remove" && (n2 <= i2.offset ? i2.offset -= e2.howMany : e2.offset < i2.offset && (e2.nodesToHandle += i2.howMany, i2.howMany = 0)), i2.type == "attribute") {
                if (n2 <= i2.offset)
                  i2.offset -= e2.howMany;
                else if (e2.offset < i2.offset) {
                  const t3 = n2 - i2.offset;
                  i2.offset = e2.offset, i2.howMany -= t3;
                } else if (e2.offset < o2)
                  if (n2 <= o2) {
                    const n3 = i2.howMany;
                    i2.howMany = e2.offset - i2.offset;
                    const o3 = n3 - i2.howMany - e2.nodesToHandle;
                    t2.unshift({ type: "attribute", offset: e2.offset, howMany: o3, count: this._changeCount++ });
                  } else
                    i2.howMany -= o2 - e2.offset;
              }
            }
            if (e2.type == "attribute") {
              if (i2.type == "insert")
                if (e2.offset < i2.offset && n2 > i2.offset) {
                  if (n2 > o2) {
                    const e3 = { type: "attribute", offset: o2, howMany: n2 - o2, count: this._changeCount++ };
                    this._handleChange(e3, t2), t2.push(e3);
                  }
                  e2.nodesToHandle = i2.offset - e2.offset, e2.howMany = e2.nodesToHandle;
                } else
                  e2.offset >= i2.offset && e2.offset < o2 && (n2 > o2 ? (e2.nodesToHandle = n2 - o2, e2.offset = o2) : e2.nodesToHandle = 0);
              if (i2.type == "remove" && e2.offset < i2.offset && n2 > i2.offset) {
                const o3 = { type: "attribute", offset: i2.offset, howMany: n2 - i2.offset, count: this._changeCount++ };
                this._handleChange(o3, t2), t2.push(o3), e2.nodesToHandle = i2.offset - e2.offset, e2.howMany = e2.nodesToHandle;
              }
              i2.type == "attribute" && (e2.offset >= i2.offset && n2 <= o2 ? (e2.nodesToHandle = 0, e2.howMany = 0, e2.offset = 0) : e2.offset <= i2.offset && n2 >= o2 && (i2.howMany = 0));
            }
          }
          e2.howMany = e2.nodesToHandle, delete e2.nodesToHandle;
        }
        _getInsertDiff(e2, t2, i2) {
          return { type: "insert", position: Xs._createAt(e2, t2), name: i2, length: 1, changeCount: this._changeCount++ };
        }
        _getRemoveDiff(e2, t2, i2) {
          return { type: "remove", position: Xs._createAt(e2, t2), name: i2, length: 1, changeCount: this._changeCount++ };
        }
        _getAttributesDiff(e2, t2, i2) {
          const n2 = [];
          i2 = new Map(i2);
          for (const [o2, r2] of t2) {
            const t3 = i2.has(o2) ? i2.get(o2) : null;
            t3 !== r2 && n2.push({ type: "attribute", position: e2.start, range: e2.clone(), length: 1, attributeKey: o2, attributeOldValue: r2, attributeNewValue: t3, changeCount: this._changeCount++ }), i2.delete(o2);
          }
          for (const [t3, o2] of i2)
            n2.push({ type: "attribute", position: e2.start, range: e2.clone(), length: 1, attributeKey: t3, attributeOldValue: null, attributeNewValue: o2, changeCount: this._changeCount++ });
          return n2;
        }
        _isInInsertedElement(e2) {
          const t2 = e2.parent;
          if (!t2)
            return false;
          const i2 = this._changesInElement.get(t2), n2 = e2.startOffset;
          if (i2) {
            for (const e3 of i2)
              if (e3.type == "insert" && n2 >= e3.offset && n2 < e3.offset + e3.howMany)
                return true;
          }
          return this._isInInsertedElement(t2);
        }
        _removeAllNestedChanges(e2, t2, i2) {
          const n2 = new na(Xs._createAt(e2, t2), Xs._createAt(e2, t2 + i2));
          for (const e3 of n2.getItems({ shallow: true }))
            e3.is("element") && (this._elementSnapshots.delete(e3), this._changesInElement.delete(e3), this._removeAllNestedChanges(e3, 0, e3.maxOffset));
        }
      }
      function Fc(e2) {
        const t2 = [];
        for (const i2 of e2)
          if (i2.is("$text"))
            for (let e3 = 0; e3 < i2.data.length; e3++)
              t2.push({ name: "$text", attributes: new Map(i2.getAttributes()) });
          else
            t2.push({ name: i2.name, attributes: new Map(i2.getAttributes()) });
        return t2;
      }
      function Hc(e2, t2) {
        const i2 = [];
        let n2 = 0, o2 = 0;
        for (const e3 of t2) {
          if (e3.offset > n2) {
            for (let t3 = 0; t3 < e3.offset - n2; t3++)
              i2.push("e");
            o2 += e3.offset - n2;
          }
          if (e3.type == "insert") {
            for (let t3 = 0; t3 < e3.howMany; t3++)
              i2.push("i");
            n2 = e3.offset + e3.howMany;
          } else if (e3.type == "remove") {
            for (let t3 = 0; t3 < e3.howMany; t3++)
              i2.push("r");
            n2 = e3.offset, o2 += e3.howMany;
          } else
            i2.push(..."a".repeat(e3.howMany).split("")), n2 = e3.offset + e3.howMany, o2 += e3.howMany;
        }
        if (o2 < e2)
          for (let t3 = 0; t3 < e2 - o2 - n2; t3++)
            i2.push("e");
        return i2;
      }
      function Uc(e2) {
        const t2 = e2.position && e2.position.root.rootName == "$graveyard", i2 = e2.range && e2.range.root.rootName == "$graveyard";
        return !t2 && !i2;
      }
      class Wc {
        constructor() {
          this._operations = [], this._undoPairs = new Map(), this._undoneOperations = new Set();
        }
        addOperation(e2) {
          this._operations.includes(e2) || this._operations.push(e2);
        }
        getOperations(e2 = Number.NEGATIVE_INFINITY, t2 = Number.POSITIVE_INFINITY) {
          const i2 = [];
          for (const n2 of this._operations)
            n2.baseVersion >= e2 && n2.baseVersion < t2 && i2.push(n2);
          return i2;
        }
        getOperation(e2) {
          for (const t2 of this._operations)
            if (t2.baseVersion == e2)
              return t2;
        }
        setOperationAsUndone(e2, t2) {
          this._undoPairs.set(t2, e2), this._undoneOperations.add(e2);
        }
        isUndoingOperation(e2) {
          return this._undoPairs.has(e2);
        }
        isUndoneOperation(e2) {
          return this._undoneOperations.has(e2);
        }
        getUndoneOperation(e2) {
          return this._undoPairs.get(e2);
        }
      }
      function qc(e2, t2) {
        return !!(i2 = e2.charAt(t2 - 1)) && i2.length == 1 && /[\ud800-\udbff]/.test(i2) && function(e3) {
          return !!e3 && e3.length == 1 && /[\udc00-\udfff]/.test(e3);
        }(e2.charAt(t2));
        var i2;
      }
      function $c(e2, t2) {
        return !!(i2 = e2.charAt(t2)) && i2.length == 1 && /[\u0300-\u036f\u1ab0-\u1aff\u1dc0-\u1dff\u20d0-\u20ff\ufe20-\ufe2f]/.test(i2);
        var i2;
      }
      class Yc {
        constructor(e2) {
          this.model = e2, this.version = 0, this.history = new Wc(this), this.selection = new ka(this), this.roots = new Zi({ idProperty: "rootName" }), this.differ = new Bc(e2.markers), this._postFixers = new Set(), this._hasSelectionChangedFromTheLastChangeBlock = false, this.createRoot("$root", "$graveyard"), this.listenTo(e2, "applyOperation", (e3, t2) => {
            const i2 = t2[0];
            if (i2.isDocumentOperation && i2.baseVersion !== this.version)
              throw new c.a("model-document-applyoperation-wrong-version", this, { operation: i2 });
          }, { priority: "highest" }), this.listenTo(e2, "applyOperation", (e3, t2) => {
            const i2 = t2[0];
            i2.isDocumentOperation && this.differ.bufferOperation(i2);
          }, { priority: "high" }), this.listenTo(e2, "applyOperation", (e3, t2) => {
            const i2 = t2[0];
            i2.isDocumentOperation && (this.version++, this.history.addOperation(i2));
          }, { priority: "low" }), this.listenTo(this.selection, "change", () => {
            this._hasSelectionChangedFromTheLastChangeBlock = true;
          }), this.listenTo(e2.markers, "update", (e3, t2, i2, n2) => {
            this.differ.bufferMarkerChange(t2.name, i2, n2, t2.affectsData), i2 === null && t2.on("change", (e4, i3) => {
              this.differ.bufferMarkerChange(t2.name, i3, t2.getRange(), t2.affectsData);
            });
          });
        }
        get graveyard() {
          return this.getRoot("$graveyard");
        }
        createRoot(e2 = "$root", t2 = "main") {
          if (this.roots.get(t2))
            throw new c.a("model-document-createroot-name-exists", this, { name: t2 });
          const i2 = new Rc(this, e2, t2);
          return this.roots.add(i2), i2;
        }
        destroy() {
          this.selection.destroy(), this.stopListening();
        }
        getRoot(e2 = "main") {
          return this.roots.get(e2);
        }
        getRootNames() {
          return Array.from(this.roots, (e2) => e2.rootName).filter((e2) => e2 != "$graveyard");
        }
        registerPostFixer(e2) {
          this._postFixers.add(e2);
        }
        toJSON() {
          const e2 = ln(this);
          return e2.selection = "[engine.model.DocumentSelection]", e2.model = "[engine.model.Model]", e2;
        }
        _handleChangeBlock(e2) {
          this._hasDocumentChangedFromTheLastChangeBlock() && (this._callPostFixers(e2), this.selection.refresh(), this.differ.hasDataChanges() ? this.fire("change:data", e2.batch) : this.fire("change", e2.batch), this.selection.refresh(), this.differ.reset()), this._hasSelectionChangedFromTheLastChangeBlock = false;
        }
        _hasDocumentChangedFromTheLastChangeBlock() {
          return !this.differ.isEmpty || this._hasSelectionChangedFromTheLastChangeBlock;
        }
        _getDefaultRoot() {
          for (const e2 of this.roots)
            if (e2 !== this.graveyard)
              return e2;
          return this.graveyard;
        }
        _getDefaultRange() {
          const e2 = this._getDefaultRoot(), t2 = this.model, i2 = t2.schema, n2 = t2.createPositionFromPath(e2, [0]);
          return i2.getNearestSelectionRange(n2) || t2.createRange(n2);
        }
        _validateSelectionRange(e2) {
          return Gc(e2.start) && Gc(e2.end);
        }
        _callPostFixers(e2) {
          let t2 = false;
          do {
            for (const i2 of this._postFixers)
              if (this.selection.refresh(), t2 = i2(e2), t2)
                break;
          } while (t2);
        }
      }
      function Gc(e2) {
        const t2 = e2.textNode;
        if (t2) {
          const i2 = t2.data, n2 = e2.offset - t2.startOffset;
          return !qc(i2, n2) && !$c(i2, n2);
        }
        return true;
      }
      Ke(Yc, h);
      class Kc {
        constructor() {
          this._markers = new Map();
        }
        [Symbol.iterator]() {
          return this._markers.values();
        }
        has(e2) {
          const t2 = e2 instanceof Qc ? e2.name : e2;
          return this._markers.has(t2);
        }
        get(e2) {
          return this._markers.get(e2) || null;
        }
        _set(e2, t2, i2 = false, n2 = false) {
          const o2 = e2 instanceof Qc ? e2.name : e2;
          if (o2.includes(","))
            throw new c.a("markercollection-incorrect-marker-name", this);
          const r2 = this._markers.get(o2);
          if (r2) {
            const e3 = r2.getRange();
            let s3 = false;
            return e3.isEqual(t2) || (r2._attachLiveRange(pa.fromRange(t2)), s3 = true), i2 != r2.managedUsingOperations && (r2._managedUsingOperations = i2, s3 = true), typeof n2 == "boolean" && n2 != r2.affectsData && (r2._affectsData = n2, s3 = true), s3 && this.fire("update:" + o2, r2, e3, t2), r2;
          }
          const s2 = pa.fromRange(t2), a2 = new Qc(o2, s2, i2, n2);
          return this._markers.set(o2, a2), this.fire("update:" + o2, a2, null, t2), a2;
        }
        _remove(e2) {
          const t2 = e2 instanceof Qc ? e2.name : e2, i2 = this._markers.get(t2);
          return !!i2 && (this._markers.delete(t2), this.fire("update:" + t2, i2, i2.getRange(), null), this._destroyMarker(i2), true);
        }
        _refresh(e2) {
          const t2 = e2 instanceof Qc ? e2.name : e2, i2 = this._markers.get(t2);
          if (!i2)
            throw new c.a("markercollection-refresh-marker-not-exists", this);
          const n2 = i2.getRange();
          this.fire("update:" + t2, i2, n2, n2, i2.managedUsingOperations, i2.affectsData);
        }
        *getMarkersAtPosition(e2) {
          for (const t2 of this)
            t2.getRange().containsPosition(e2) && (yield t2);
        }
        *getMarkersIntersectingRange(e2) {
          for (const t2 of this)
            t2.getRange().getIntersection(e2) !== null && (yield t2);
        }
        destroy() {
          for (const e2 of this._markers.values())
            this._destroyMarker(e2);
          this._markers = null, this.stopListening();
        }
        *getMarkersGroup(e2) {
          for (const t2 of this._markers.values())
            t2.name.startsWith(e2 + ":") && (yield t2);
        }
        _destroyMarker(e2) {
          e2.stopListening(), e2._detachLiveRange();
        }
      }
      Ke(Kc, h);
      class Qc {
        constructor(e2, t2, i2, n2) {
          this.name = e2, this._liveRange = this._attachLiveRange(t2), this._managedUsingOperations = i2, this._affectsData = n2;
        }
        get managedUsingOperations() {
          if (!this._liveRange)
            throw new c.a("marker-destroyed", this);
          return this._managedUsingOperations;
        }
        get affectsData() {
          if (!this._liveRange)
            throw new c.a("marker-destroyed", this);
          return this._affectsData;
        }
        getStart() {
          if (!this._liveRange)
            throw new c.a("marker-destroyed", this);
          return this._liveRange.start.clone();
        }
        getEnd() {
          if (!this._liveRange)
            throw new c.a("marker-destroyed", this);
          return this._liveRange.end.clone();
        }
        getRange() {
          if (!this._liveRange)
            throw new c.a("marker-destroyed", this);
          return this._liveRange.toRange();
        }
        is(e2) {
          return e2 === "marker" || e2 === "model:marker";
        }
        _attachLiveRange(e2) {
          return this._liveRange && this._detachLiveRange(), e2.delegate("change:range").to(this), e2.delegate("change:content").to(this), this._liveRange = e2, e2;
        }
        _detachLiveRange() {
          this._liveRange.stopDelegating("change:range", this), this._liveRange.stopDelegating("change:content", this), this._liveRange.detach(), this._liveRange = null;
        }
      }
      Ke(Qc, h);
      class Jc extends mc {
        get type() {
          return "noop";
        }
        clone() {
          return new Jc(this.baseVersion);
        }
        getReversed() {
          return new Jc(this.baseVersion + 1);
        }
        _execute() {
        }
        static get className() {
          return "NoOperation";
        }
      }
      const Zc = {};
      Zc[Ac.className] = Ac, Zc[Ec.className] = Ec, Zc[Ic.className] = Ic, Zc[Tc.className] = Tc, Zc[Jc.className] = Jc, Zc[mc.className] = mc, Zc[Sc.className] = Sc, Zc[Pc.className] = Pc, Zc[Nc.className] = Nc, Zc[Mc.className] = Mc;
      class Xc extends Xs {
        constructor(e2, t2, i2 = "toNone") {
          if (super(e2, t2, i2), !this.root.is("rootElement"))
            throw new c.a("model-liveposition-root-not-rootelement", e2);
          el.call(this);
        }
        detach() {
          this.stopListening();
        }
        is(e2) {
          return e2 === "livePosition" || e2 === "model:livePosition" || e2 == "position" || e2 === "model:position";
        }
        toPosition() {
          return new Xs(this.root, this.path.slice(), this.stickiness);
        }
        static fromPosition(e2, t2) {
          return new this(e2.root, e2.path.slice(), t2 || e2.stickiness);
        }
      }
      function el() {
        this.listenTo(this.root.document.model, "applyOperation", (e2, t2) => {
          const i2 = t2[0];
          i2.isDocumentOperation && tl.call(this, i2);
        }, { priority: "low" });
      }
      function tl(e2) {
        const t2 = this.getTransformedByOperation(e2);
        if (!this.isEqual(t2)) {
          const e3 = this.toPosition();
          this.path = t2.path, this.root = t2.root, this.fire("change", e3);
        }
      }
      Ke(Xc, h);
      class il {
        constructor(e2, t2, i2) {
          this.model = e2, this.writer = t2, this.position = i2, this.canMergeWith = new Set([this.position.parent]), this.schema = e2.schema, this._documentFragment = t2.createDocumentFragment(), this._documentFragmentPosition = t2.createPositionAt(this._documentFragment, 0), this._firstNode = null, this._lastNode = null, this._lastAutoParagraph = null, this._filterAttributesOf = [], this._affectedStart = null, this._affectedEnd = null;
        }
        handleNodes(e2) {
          for (const t2 of Array.from(e2))
            this._handleNode(t2);
          this._insertPartialFragment(), this._lastAutoParagraph && this._updateLastNodeFromAutoParagraph(this._lastAutoParagraph), this._mergeOnRight(), this.schema.removeDisallowedAttributes(this._filterAttributesOf, this.writer), this._filterAttributesOf = [];
        }
        _updateLastNodeFromAutoParagraph(e2) {
          const t2 = this.writer.createPositionAfter(this._lastNode), i2 = this.writer.createPositionAfter(e2);
          if (i2.isAfter(t2)) {
            if (this._lastNode = e2, this.position.parent != e2 || !this.position.isAtEnd)
              throw new c.a("insertcontent-invalid-insertion-position", this);
            this.position = i2, this._setAffectedBoundaries(this.position);
          }
        }
        getSelectionRange() {
          return this.nodeToSelect ? na._createOn(this.nodeToSelect) : this.model.schema.getNearestSelectionRange(this.position);
        }
        getAffectedRange() {
          return this._affectedStart ? new na(this._affectedStart, this._affectedEnd) : null;
        }
        destroy() {
          this._affectedStart && this._affectedStart.detach(), this._affectedEnd && this._affectedEnd.detach();
        }
        _handleNode(e2) {
          if (this.schema.isObject(e2))
            return void this._handleObject(e2);
          let t2 = this._checkAndAutoParagraphToAllowedPosition(e2);
          t2 || (t2 = this._checkAndSplitToAllowedPosition(e2), t2) ? (this._appendToFragment(e2), this._firstNode || (this._firstNode = e2), this._lastNode = e2) : this._handleDisallowedNode(e2);
        }
        _insertPartialFragment() {
          if (this._documentFragment.isEmpty)
            return;
          const e2 = Xc.fromPosition(this.position, "toNext");
          this._setAffectedBoundaries(this.position), this._documentFragment.getChild(0) == this._firstNode && (this.writer.insert(this._firstNode, this.position), this._mergeOnLeft(), this.position = e2.toPosition()), this._documentFragment.isEmpty || this.writer.insert(this._documentFragment, this.position), this._documentFragmentPosition = this.writer.createPositionAt(this._documentFragment, 0), this.position = e2.toPosition(), e2.detach();
        }
        _handleObject(e2) {
          this._checkAndSplitToAllowedPosition(e2) ? this._appendToFragment(e2) : this._tryAutoparagraphing(e2);
        }
        _handleDisallowedNode(e2) {
          e2.is("element") ? this.handleNodes(e2.getChildren()) : this._tryAutoparagraphing(e2);
        }
        _appendToFragment(e2) {
          if (!this.schema.checkChild(this.position, e2))
            throw new c.a("insertcontent-wrong-position", this, { node: e2, position: this.position });
          this.writer.insert(e2, this._documentFragmentPosition), this._documentFragmentPosition = this._documentFragmentPosition.getShiftedBy(e2.offsetSize), this.schema.isObject(e2) && !this.schema.checkChild(this.position, "$text") ? this.nodeToSelect = e2 : this.nodeToSelect = null, this._filterAttributesOf.push(e2);
        }
        _setAffectedBoundaries(e2) {
          this._affectedStart || (this._affectedStart = Xc.fromPosition(e2, "toPrevious")), this._affectedEnd && !this._affectedEnd.isBefore(e2) || (this._affectedEnd && this._affectedEnd.detach(), this._affectedEnd = Xc.fromPosition(e2, "toNext"));
        }
        _mergeOnLeft() {
          const e2 = this._firstNode;
          if (!(e2 instanceof Qs))
            return;
          if (!this._canMergeLeft(e2))
            return;
          const t2 = Xc._createBefore(e2);
          t2.stickiness = "toNext";
          const i2 = Xc.fromPosition(this.position, "toNext");
          this._affectedStart.isEqual(t2) && (this._affectedStart.detach(), this._affectedStart = Xc._createAt(t2.nodeBefore, "end", "toPrevious")), this._firstNode === this._lastNode && (this._firstNode = t2.nodeBefore, this._lastNode = t2.nodeBefore), this.writer.merge(t2), t2.isEqual(this._affectedEnd) && this._firstNode === this._lastNode && (this._affectedEnd.detach(), this._affectedEnd = Xc._createAt(t2.nodeBefore, "end", "toNext")), this.position = i2.toPosition(), i2.detach(), this._filterAttributesOf.push(this.position.parent), t2.detach();
        }
        _mergeOnRight() {
          const e2 = this._lastNode;
          if (!(e2 instanceof Qs))
            return;
          if (!this._canMergeRight(e2))
            return;
          const t2 = Xc._createAfter(e2);
          if (t2.stickiness = "toNext", !this.position.isEqual(t2))
            throw new c.a("insertcontent-invalid-insertion-position", this);
          this.position = Xs._createAt(t2.nodeBefore, "end");
          const i2 = Xc.fromPosition(this.position, "toPrevious");
          this._affectedEnd.isEqual(t2) && (this._affectedEnd.detach(), this._affectedEnd = Xc._createAt(t2.nodeBefore, "end", "toNext")), this._firstNode === this._lastNode && (this._firstNode = t2.nodeBefore, this._lastNode = t2.nodeBefore), this.writer.merge(t2), t2.getShiftedBy(-1).isEqual(this._affectedStart) && this._firstNode === this._lastNode && (this._affectedStart.detach(), this._affectedStart = Xc._createAt(t2.nodeBefore, 0, "toPrevious")), this.position = i2.toPosition(), i2.detach(), this._filterAttributesOf.push(this.position.parent), t2.detach();
        }
        _canMergeLeft(e2) {
          const t2 = e2.previousSibling;
          return t2 instanceof Qs && this.canMergeWith.has(t2) && this.model.schema.checkMerge(t2, e2);
        }
        _canMergeRight(e2) {
          const t2 = e2.nextSibling;
          return t2 instanceof Qs && this.canMergeWith.has(t2) && this.model.schema.checkMerge(e2, t2);
        }
        _tryAutoparagraphing(e2) {
          const t2 = this.writer.createElement("paragraph");
          this._getAllowedIn(this.position.parent, t2) && this.schema.checkChild(t2, e2) && (t2._appendChild(e2), this._handleNode(t2));
        }
        _checkAndAutoParagraphToAllowedPosition(e2) {
          if (this.schema.checkChild(this.position.parent, e2))
            return true;
          if (!this.schema.checkChild(this.position.parent, "paragraph") || !this.schema.checkChild("paragraph", e2))
            return false;
          this._insertPartialFragment();
          const t2 = this.writer.createElement("paragraph");
          return this.writer.insert(t2, this.position), this._setAffectedBoundaries(this.position), this._lastAutoParagraph = t2, this.position = this.writer.createPositionAt(t2, 0), true;
        }
        _checkAndSplitToAllowedPosition(e2) {
          const t2 = this._getAllowedIn(this.position.parent, e2);
          if (!t2)
            return false;
          for (t2 != this.position.parent && this._insertPartialFragment(); t2 != this.position.parent; )
            if (this.position.isAtStart) {
              const e3 = this.position.parent;
              this.position = this.writer.createPositionBefore(e3), e3.isEmpty && e3.parent === t2 && this.writer.remove(e3);
            } else if (this.position.isAtEnd)
              this.position = this.writer.createPositionAfter(this.position.parent);
            else {
              const e3 = this.writer.createPositionAfter(this.position.parent);
              this._setAffectedBoundaries(this.position), this.writer.split(this.position), this.position = e3, this.canMergeWith.add(this.position.nodeAfter);
            }
          return true;
        }
        _getAllowedIn(e2, t2) {
          return this.schema.checkChild(e2, t2) ? e2 : this.schema.isLimit(e2) ? null : this._getAllowedIn(e2.parent, t2);
        }
      }
      function nl(e2, t2, i2 = {}) {
        if (t2.isCollapsed)
          return;
        const n2 = t2.getFirstRange();
        if (n2.root.rootName == "$graveyard")
          return;
        const o2 = e2.schema;
        e2.change((e3) => {
          if (!i2.doNotResetEntireContent && function(e4, t3) {
            const i3 = e4.getLimitElement(t3);
            if (!t3.containsEntireContent(i3))
              return false;
            const n3 = t3.getFirstRange();
            if (n3.start.parent == n3.end.parent)
              return false;
            return e4.checkChild(i3, "paragraph");
          }(o2, t2))
            return void function(e4, t3) {
              const i3 = e4.model.schema.getLimitElement(t3);
              e4.remove(e4.createRangeIn(i3)), rl(e4, e4.createPositionAt(i3, 0), t3);
            }(e3, t2);
          const [r2, s2] = function(e4) {
            const t3 = e4.root.document.model, i3 = e4.start;
            let n3 = e4.end;
            if (t3.hasContent(e4, { ignoreMarkers: true })) {
              const i4 = function(e5) {
                const t4 = e5.parent, i5 = t4.root.document.model.schema, n4 = t4.getAncestors({ parentFirst: true, includeSelf: true });
                for (const e6 of n4) {
                  if (i5.isLimit(e6))
                    return null;
                  if (i5.isBlock(e6))
                    return e6;
                }
              }(n3);
              if (i4 && n3.isTouching(t3.createPositionAt(i4, 0))) {
                const i5 = t3.createSelection(e4);
                t3.modifySelection(i5, { direction: "backward" });
                const o3 = i5.getLastPosition(), r3 = t3.createRange(o3, n3);
                t3.hasContent(r3, { ignoreMarkers: true }) || (n3 = o3);
              }
            }
            return [Xc.fromPosition(i3, "toPrevious"), Xc.fromPosition(n3, "toNext")];
          }(n2);
          r2.isTouching(s2) || e3.remove(e3.createRange(r2, s2)), i2.leaveUnmerged || (!function(e4, t3, i3) {
            const n3 = e4.model;
            if (!ol(e4.model.schema, t3, i3))
              return;
            const [o3, r3] = function(e5, t4) {
              const i4 = e5.getAncestors(), n4 = t4.getAncestors();
              let o4 = 0;
              for (; i4[o4] && i4[o4] == n4[o4]; )
                o4++;
              return [i4[o4], n4[o4]];
            }(t3, i3);
            if (!o3 || !r3)
              return;
            !n3.hasContent(o3, { ignoreMarkers: true }) && n3.hasContent(r3, { ignoreMarkers: true }) ? function e5(t4, i4, n4, o4) {
              const r4 = i4.parent, s3 = n4.parent;
              if (r4 == o4 || s3 == o4)
                return;
              i4 = t4.createPositionAfter(r4), (n4 = t4.createPositionBefore(s3)).isEqual(i4) || t4.insert(r4, n4);
              for (; i4.parent.isEmpty; ) {
                const e6 = i4.parent;
                i4 = t4.createPositionBefore(e6), t4.remove(e6);
              }
              if (n4 = t4.createPositionBefore(s3), function(e6, t5) {
                const i5 = t5.nodeBefore, n5 = t5.nodeAfter;
                i5.name != n5.name && e6.rename(i5, n5.name);
                e6.clearAttributes(i5), e6.setAttributes(Object.fromEntries(n5.getAttributes()), i5), e6.merge(t5);
              }(t4, n4), !ol(t4.model.schema, i4, n4))
                return;
              e5(t4, i4, n4, o4);
            }(e4, t3, i3, o3.parent) : function e5(t4, i4, n4, o4) {
              const r4 = i4.parent, s3 = n4.parent;
              if (r4 == o4 || s3 == o4)
                return;
              i4 = t4.createPositionAfter(r4), (n4 = t4.createPositionBefore(s3)).isEqual(i4) || t4.insert(s3, i4);
              t4.merge(i4);
              for (; n4.parent.isEmpty; ) {
                const e6 = n4.parent;
                n4 = t4.createPositionBefore(e6), t4.remove(e6);
              }
              if (!ol(t4.model.schema, i4, n4))
                return;
              e5(t4, i4, n4, o4);
            }(e4, t3, i3, o3.parent);
          }(e3, r2, s2), o2.removeDisallowedAttributes(r2.parent.getChildren(), e3)), sl(e3, t2, r2), !i2.doNotAutoparagraph && function(e4, t3) {
            const i3 = e4.checkChild(t3, "$text"), n3 = e4.checkChild(t3, "paragraph");
            return !i3 && n3;
          }(o2, r2) && rl(e3, r2, t2), r2.detach(), s2.detach();
        });
      }
      function ol(e2, t2, i2) {
        const n2 = t2.parent, o2 = i2.parent;
        return n2 != o2 && (!e2.isLimit(n2) && !e2.isLimit(o2) && function(e3, t3, i3) {
          const n3 = new na(e3, t3);
          for (const e4 of n3.getWalker())
            if (i3.isLimit(e4.item))
              return false;
          return true;
        }(t2, i2, e2));
      }
      function rl(e2, t2, i2) {
        const n2 = e2.createElement("paragraph");
        e2.insert(n2, t2), sl(e2, i2, e2.createPositionAt(n2, 0));
      }
      function sl(e2, t2, i2) {
        t2 instanceof ka ? e2.setSelection(i2) : t2.setTo(i2);
      }
      function al(e2, t2) {
        const { isForward: i2, walker: n2, unit: o2, schema: r2 } = e2, { type: s2, item: a2, nextPosition: c2 } = t2;
        if (s2 == "text")
          return e2.unit === "word" ? function(e3, t3) {
            let i3 = e3.position.textNode;
            if (i3) {
              let n3 = e3.position.offset - i3.startOffset;
              for (; !ll(i3.data, n3, t3) && !dl(i3, n3, t3); ) {
                e3.next();
                const o3 = t3 ? e3.position.nodeAfter : e3.position.nodeBefore;
                if (o3 && o3.is("$text")) {
                  const n4 = o3.data.charAt(t3 ? 0 : o3.data.length - 1);
                  ' ,.?!:;"-()'.includes(n4) || (e3.next(), i3 = e3.position.textNode);
                }
                n3 = e3.position.offset - i3.startOffset;
              }
            }
            return e3.position;
          }(n2, i2) : function(e3, t3) {
            const i3 = e3.position.textNode;
            if (i3) {
              const n3 = i3.data;
              let o3 = e3.position.offset - i3.startOffset;
              for (; qc(n3, o3) || t3 == "character" && $c(n3, o3); )
                e3.next(), o3 = e3.position.offset - i3.startOffset;
            }
            return e3.position;
          }(n2, o2);
        if (s2 == (i2 ? "elementStart" : "elementEnd")) {
          if (r2.isSelectable(a2))
            return Xs._createAt(a2, i2 ? "after" : "before");
          if (r2.checkChild(c2, "$text"))
            return c2;
        } else {
          if (r2.isLimit(a2))
            return void n2.skip(() => true);
          if (r2.checkChild(c2, "$text"))
            return c2;
        }
      }
      function cl(e2, t2) {
        const i2 = e2.root, n2 = Xs._createAt(i2, t2 ? "end" : 0);
        return t2 ? new na(e2, n2) : new na(n2, e2);
      }
      function ll(e2, t2, i2) {
        const n2 = t2 + (i2 ? 0 : -1);
        return ' ,.?!:;"-()'.includes(e2.charAt(n2));
      }
      function dl(e2, t2, i2) {
        return t2 === (i2 ? e2.endOffset : 0);
      }
      function hl(e2, t2) {
        const i2 = [];
        Array.from(e2.getItems({ direction: "backward" })).map((e3) => t2.createRangeOn(e3)).filter((t3) => (t3.start.isAfter(e2.start) || t3.start.isEqual(e2.start)) && (t3.end.isBefore(e2.end) || t3.end.isEqual(e2.end))).forEach((e3) => {
          i2.push(e3.start.parent), t2.remove(e3);
        }), i2.forEach((e3) => {
          let i3 = e3;
          for (; i3.parent && i3.isEmpty; ) {
            const e4 = t2.createRangeOn(i3);
            i3 = i3.parent, t2.remove(e4);
          }
        });
      }
      function ul(e2) {
        e2.document.registerPostFixer((t2) => function(e3, t3) {
          const i2 = t3.document.selection, n2 = t3.schema, o2 = [];
          let r2 = false;
          for (const e4 of i2.getRanges()) {
            const t4 = gl(e4, n2);
            t4 && !t4.isEqual(e4) ? (o2.push(t4), r2 = true) : o2.push(e4);
          }
          r2 && e3.setSelection(function(e4) {
            const t4 = [];
            t4.push(e4.shift());
            for (const i3 of e4) {
              const e5 = t4.pop();
              if (i3.isEqual(e5))
                t4.push(e5);
              else if (i3.isIntersecting(e5)) {
                const n3 = e5.start.isAfter(i3.start) ? i3.start : e5.start, o3 = e5.end.isAfter(i3.end) ? e5.end : i3.end, r3 = new na(n3, o3);
                t4.push(r3);
              } else
                t4.push(e5), t4.push(i3);
            }
            return t4;
          }(o2), { backward: i2.isBackward });
        }(t2, e2));
      }
      function gl(e2, t2) {
        return e2.isCollapsed ? function(e3, t3) {
          const i2 = e3.start, n2 = t3.getNearestSelectionRange(i2);
          if (!n2)
            return null;
          if (!n2.isCollapsed)
            return n2;
          const o2 = n2.start;
          if (i2.isEqual(o2))
            return null;
          return new na(o2);
        }(e2, t2) : function(e3, t3) {
          const { start: i2, end: n2 } = e3, o2 = t3.checkChild(i2, "$text"), r2 = t3.checkChild(n2, "$text"), s2 = t3.getLimitElement(i2), a2 = t3.getLimitElement(n2);
          if (s2 === a2) {
            if (o2 && r2)
              return null;
            if (function(e4, t4, i3) {
              const n3 = e4.nodeAfter && !i3.isLimit(e4.nodeAfter) || i3.checkChild(e4, "$text"), o3 = t4.nodeBefore && !i3.isLimit(t4.nodeBefore) || i3.checkChild(t4, "$text");
              return n3 || o3;
            }(i2, n2, t3)) {
              const e4 = i2.nodeAfter && t3.isSelectable(i2.nodeAfter) ? null : t3.getNearestSelectionRange(i2, "forward"), o3 = n2.nodeBefore && t3.isSelectable(n2.nodeBefore) ? null : t3.getNearestSelectionRange(n2, "backward"), r3 = e4 ? e4.start : i2, s3 = o3 ? o3.end : n2;
              return new na(r3, s3);
            }
          }
          const c2 = s2 && !s2.is("rootElement"), l2 = a2 && !a2.is("rootElement");
          if (c2 || l2) {
            const e4 = i2.nodeAfter && n2.nodeBefore && i2.nodeAfter.parent === n2.nodeBefore.parent, o3 = c2 && (!e4 || !fl(i2.nodeAfter, t3)), r3 = l2 && (!e4 || !fl(n2.nodeBefore, t3));
            let d2 = i2, h2 = n2;
            return o3 && (d2 = Xs._createBefore(ml(s2, t3))), r3 && (h2 = Xs._createAfter(ml(a2, t3))), new na(d2, h2);
          }
          return null;
        }(e2, t2);
      }
      function ml(e2, t2) {
        let i2 = e2, n2 = i2;
        for (; t2.isLimit(n2) && n2.parent; )
          i2 = n2, n2 = n2.parent;
        return i2;
      }
      function fl(e2, t2) {
        return e2 && t2.isSelectable(e2);
      }
      class pl {
        constructor() {
          this.markers = new Kc(), this.document = new Yc(this), this.schema = new qa(), this._pendingChanges = [], this._currentWriter = null, ["insertContent", "deleteContent", "modifySelection", "getSelectedContent", "applyOperation"].forEach((e2) => this.decorate(e2)), this.on("applyOperation", (e2, t2) => {
            t2[0]._validate();
          }, { priority: "highest" }), this.schema.register("$root", { isLimit: true }), this.schema.register("$block", { allowIn: "$root", isBlock: true }), this.schema.register("$text", { allowIn: "$block", isInline: true, isContent: true }), this.schema.register("$clipboardHolder", { allowContentOf: "$root", allowChildren: "$text", isLimit: true }), this.schema.register("$documentFragment", { allowContentOf: "$root", allowChildren: "$text", isLimit: true }), this.schema.register("$marker"), this.schema.addChildCheck((e2, t2) => {
            if (t2.name === "$marker")
              return true;
          }), ul(this), this.document.registerPostFixer(Ma);
        }
        change(e2) {
          try {
            return this._pendingChanges.length === 0 ? (this._pendingChanges.push({ batch: new gc(), callback: e2 }), this._runPendingChanges()[0]) : e2(this._currentWriter);
          } catch (e3) {
            c.a.rethrowUnexpectedError(e3, this);
          }
        }
        enqueueChange(e2, t2) {
          try {
            typeof e2 == "string" ? e2 = new gc(e2) : typeof e2 == "function" && (t2 = e2, e2 = new gc()), this._pendingChanges.push({ batch: e2, callback: t2 }), this._pendingChanges.length == 1 && this._runPendingChanges();
          } catch (e3) {
            c.a.rethrowUnexpectedError(e3, this);
          }
        }
        applyOperation(e2) {
          e2._execute();
        }
        insertContent(e2, t2, i2) {
          return function(e3, t3, i3, n2) {
            return e3.change((o2) => {
              let r2;
              r2 = i3 ? i3 instanceof ha || i3 instanceof ka ? i3 : o2.createSelection(i3, n2) : e3.document.selection, r2.isCollapsed || e3.deleteContent(r2, { doNotAutoparagraph: true });
              const s2 = new il(e3, o2, r2.anchor);
              let a2;
              a2 = t3.is("documentFragment") ? t3.getChildren() : [t3], s2.handleNodes(a2);
              const c2 = s2.getSelectionRange();
              c2 && (r2 instanceof ka ? o2.setSelection(c2) : r2.setTo(c2));
              const l2 = s2.getAffectedRange() || e3.createRange(r2.anchor);
              return s2.destroy(), l2;
            });
          }(this, e2, t2, i2);
        }
        deleteContent(e2, t2) {
          nl(this, e2, t2);
        }
        modifySelection(e2, t2) {
          !function(e3, t3, i2 = {}) {
            const n2 = e3.schema, o2 = i2.direction != "backward", r2 = i2.unit ? i2.unit : "character", s2 = t3.focus, a2 = new Js({ boundaries: cl(s2, o2), singleCharacters: true, direction: o2 ? "forward" : "backward" }), c2 = { walker: a2, schema: n2, isForward: o2, unit: r2 };
            let l2;
            for (; l2 = a2.next(); ) {
              if (l2.done)
                return;
              const i3 = al(c2, l2.value);
              if (i3)
                return void (t3 instanceof ka ? e3.change((e4) => {
                  e4.setSelectionFocus(i3);
                }) : t3.setFocus(i3));
            }
          }(this, e2, t2);
        }
        getSelectedContent(e2) {
          return function(e3, t2) {
            return e3.change((e4) => {
              const i2 = e4.createDocumentFragment(), n2 = t2.getFirstRange();
              if (!n2 || n2.isCollapsed)
                return i2;
              const o2 = n2.start.root, r2 = n2.start.getCommonPath(n2.end), s2 = o2.getNodeByPath(r2);
              let a2;
              a2 = n2.start.parent == n2.end.parent ? n2 : e4.createRange(e4.createPositionAt(s2, n2.start.path[r2.length]), e4.createPositionAt(s2, n2.end.path[r2.length] + 1));
              const c2 = a2.end.offset - a2.start.offset;
              for (const t3 of a2.getItems({ shallow: true }))
                t3.is("$textProxy") ? e4.appendText(t3.data, t3.getAttributes(), i2) : e4.append(e4.cloneElement(t3, true), i2);
              if (a2 != n2) {
                const t3 = n2._getTransformedByMove(a2.start, e4.createPositionAt(i2, 0), c2)[0], o3 = e4.createRange(e4.createPositionAt(i2, 0), t3.start);
                hl(e4.createRange(t3.end, e4.createPositionAt(i2, "end")), e4), hl(o3, e4);
              }
              return i2;
            });
          }(this, e2);
        }
        hasContent(e2, t2 = {}) {
          const i2 = e2 instanceof Qs ? na._createIn(e2) : e2;
          if (i2.isCollapsed)
            return false;
          const { ignoreWhitespaces: n2 = false, ignoreMarkers: o2 = false } = t2;
          if (!o2) {
            for (const e3 of this.markers.getMarkersIntersectingRange(i2))
              if (e3.affectsData)
                return true;
          }
          for (const e3 of i2.getItems())
            if (this.schema.isContent(e3)) {
              if (!e3.is("$textProxy"))
                return true;
              if (!n2)
                return true;
              if (e3.data.search(/\S/) !== -1)
                return true;
            }
          return false;
        }
        createPositionFromPath(e2, t2, i2) {
          return new Xs(e2, t2, i2);
        }
        createPositionAt(e2, t2) {
          return Xs._createAt(e2, t2);
        }
        createPositionAfter(e2) {
          return Xs._createAfter(e2);
        }
        createPositionBefore(e2) {
          return Xs._createBefore(e2);
        }
        createRange(e2, t2) {
          return new na(e2, t2);
        }
        createRangeIn(e2) {
          return na._createIn(e2);
        }
        createRangeOn(e2) {
          return na._createOn(e2);
        }
        createSelection(e2, t2, i2) {
          return new ha(e2, t2, i2);
        }
        createBatch(e2) {
          return new gc(e2);
        }
        createOperationFromJSON(e2) {
          return class {
            static fromJSON(e3, t2) {
              return Zc[e3.__className].fromJSON(e3, t2);
            }
          }.fromJSON(e2, this.document);
        }
        destroy() {
          this.document.destroy(), this.stopListening();
        }
        _runPendingChanges() {
          const e2 = [];
          for (this.fire("_beforeChanges"); this._pendingChanges.length; ) {
            const t2 = this._pendingChanges[0].batch;
            this._currentWriter = new Oc(this, t2);
            const i2 = this._pendingChanges[0].callback(this._currentWriter);
            e2.push(i2), this.document._handleChangeBlock(this._currentWriter), this._pendingChanges.shift(), this._currentWriter = null;
          }
          return this.fire("_afterChanges"), e2;
        }
      }
      Ke(pl, Ue);
      class bl extends Rs {
        constructor(e2) {
          super(), this.editor = e2;
        }
        set(e2, t2, i2 = {}) {
          if (typeof t2 == "string") {
            const e3 = t2;
            t2 = (t3, i3) => {
              this.editor.execute(e3), i3();
            };
          }
          super.set(e2, t2, i2);
        }
      }
      class wl {
        constructor(e2 = {}) {
          this._context = e2.context || new sn({ language: e2.language }), this._context._addEditor(this, !e2.context);
          const t2 = Array.from(this.constructor.builtinPlugins || []);
          this.config = new Gi(e2, this.constructor.defaultConfig), this.config.define("plugins", t2), this.config.define(this._context._getEditorConfig()), this.plugins = new Xi(this, t2, this._context.plugins), this.locale = this._context.locale, this.t = this.locale.t, this.commands = new Ha(), this.set("state", "initializing"), this.once("ready", () => this.state = "ready", { priority: "high" }), this.once("destroy", () => this.state = "destroyed", { priority: "high" }), this.set("isReadOnly", false), this.model = new pl();
          const i2 = new Jn();
          this.data = new lc(this.model, i2), this.editing = new Fa(this.model, i2), this.editing.view.document.bind("isReadOnly").to(this), this.conversion = new dc([this.editing.downcastDispatcher, this.data.downcastDispatcher], this.data.upcastDispatcher), this.conversion.addAlias("dataDowncast", this.data.downcastDispatcher), this.conversion.addAlias("editingDowncast", this.editing.downcastDispatcher), this.keystrokes = new bl(this), this.keystrokes.listenTo(this.editing.view.document);
        }
        initPlugins() {
          const e2 = this.config, t2 = e2.get("plugins"), i2 = e2.get("removePlugins") || [], n2 = e2.get("extraPlugins") || [], o2 = e2.get("substitutePlugins") || [];
          return this.plugins.init(t2.concat(n2), i2, o2);
        }
        destroy() {
          let e2 = Promise.resolve();
          return this.state == "initializing" && (e2 = new Promise((e3) => this.once("ready", e3))), e2.then(() => {
            this.fire("destroy"), this.stopListening(), this.commands.destroy();
          }).then(() => this.plugins.destroy()).then(() => {
            this.model.destroy(), this.data.destroy(), this.editing.destroy(), this.keystrokes.destroy();
          }).then(() => this._context._removeEditor(this));
        }
        execute(...e2) {
          try {
            return this.commands.execute(...e2);
          } catch (e3) {
            c.a.rethrowUnexpectedError(e3, this);
          }
        }
        focus() {
          this.editing.view.focus();
        }
      }
      Ke(wl, Ue);
      class kl {
        constructor(e2) {
          this.editor = e2, this._components = new Map();
        }
        *names() {
          for (const e2 of this._components.values())
            yield e2.originalName;
        }
        add(e2, t2) {
          this._components.set(_l(e2), { callback: t2, originalName: e2 });
        }
        create(e2) {
          if (!this.has(e2))
            throw new c.a("componentfactory-item-missing", this, { name: e2 });
          return this._components.get(_l(e2)).callback(this.editor.locale);
        }
        has(e2) {
          return this._components.has(_l(e2));
        }
      }
      function _l(e2) {
        return String(e2).toLowerCase();
      }
      class vl {
        constructor(e2) {
          this.editor = e2, this.componentFactory = new kl(e2), this.focusTracker = new Ns(), this.set("viewportOffset", this._readViewportOffsetFromConfig()), this._editableElementsMap = new Map(), this.listenTo(e2.editing.view.document, "layoutChanged", () => this.update());
        }
        get element() {
          return null;
        }
        update() {
          this.fire("update");
        }
        destroy() {
          this.stopListening(), this.focusTracker.destroy();
          for (const e2 of this._editableElementsMap.values())
            e2.ckeditorInstance = null;
          this._editableElementsMap = new Map();
        }
        setEditableElement(e2, t2) {
          this._editableElementsMap.set(e2, t2), t2.ckeditorInstance || (t2.ckeditorInstance = this.editor);
        }
        getEditableElement(e2 = "main") {
          return this._editableElementsMap.get(e2);
        }
        getEditableElementsNames() {
          return this._editableElementsMap.keys();
        }
        get _editableElements() {
          return console.warn("editor-ui-deprecated-editable-elements: The EditorUI#_editableElements property has been deprecated and will be removed in the near future.", { editorUI: this }), this._editableElementsMap;
        }
        _readViewportOffsetFromConfig() {
          const e2 = this.editor, t2 = e2.config.get("ui.viewportOffset");
          if (t2)
            return t2;
          const i2 = e2.config.get("toolbar.viewportTopOffset");
          return i2 ? (console.warn("editor-ui-deprecated-viewport-offset-config: The `toolbar.vieportTopOffset` configuration option is deprecated. It will be removed from future CKEditor versions. Use `ui.viewportOffset.top` instead."), { top: i2 }) : { top: 0 };
        }
      }
      Ke(vl, Ue);
      var yl = { setData(e2) {
        this.data.set(e2);
      }, getData(e2) {
        return this.data.get(e2);
      } };
      var xl = { updateSourceElement() {
        if (!this.sourceElement)
          throw new c.a("editor-missing-sourceelement", this);
        var e2, t2;
        e2 = this.sourceElement, t2 = this.data.get(), e2 instanceof HTMLTextAreaElement && (e2.value = t2), e2.innerHTML = t2;
      } };
      class Al extends an {
        static get pluginName() {
          return "PendingActions";
        }
        init() {
          this.set("hasAny", false), this._actions = new Zi({ idProperty: "_id" }), this._actions.delegate("add", "remove").to(this);
        }
        add(e2) {
          if (typeof e2 != "string")
            throw new c.a("pendingactions-add-invalid-message", this);
          const t2 = Object.create(Ue);
          return t2.set("message", e2), this._actions.add(t2), this.hasAny = true, t2;
        }
        remove(e2) {
          this._actions.remove(e2), this.hasAny = !!this._actions.length;
        }
        get first() {
          return this._actions.get(0);
        }
        [Symbol.iterator]() {
          return this._actions[Symbol.iterator]();
        }
      }
      var Cl = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.999 2H15a1 1 0 0 1 0 2h-1.004v13a1 1 0 1 1-2 0V4H8.999v13a1 1 0 1 1-2 0v-7A4 4 0 0 1 3 6a4 4 0 0 1 3.999-4z"/></svg>', Tl = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><circle cx="9.5" cy="4.5" r="1.5"/><circle cx="9.5" cy="10.5" r="1.5"/><circle cx="9.5" cy="16.5" r="1.5"/></svg>';
      const El = { cancel: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.591 10.177 4.243 4.242a1 1 0 0 1-1.415 1.415l-4.242-4.243-4.243 4.243a1 1 0 0 1-1.414-1.415l4.243-4.242L4.52 5.934A1 1 0 0 1 5.934 4.52l4.243 4.243 4.242-4.243a1 1 0 1 1 1.415 1.414l-4.243 4.243z"/></svg>', caption: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 16h9a1 1 0 0 1 0 2H2a1 1 0 0 1 0-2z"/><path d="M17 1a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h14zm0 1.5H3a.5.5 0 0 0-.492.41L2.5 3v9a.5.5 0 0 0 .41.492L3 12.5h14a.5.5 0 0 0 .492-.41L17.5 12V3a.5.5 0 0 0-.41-.492L17 2.5z" fill-opacity=".6"/></svg>', check: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.972 16.615a.997.997 0 0 1-.744-.292l-4.596-4.596a1 1 0 1 1 1.414-1.414l3.926 3.926 9.937-9.937a1 1 0 0 1 1.414 1.415L7.717 16.323a.997.997 0 0 1-.745.292z"/></svg>', cog: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.333 2 .19 2.263a5.899 5.899 0 0 1 1.458.604L14.714 3.4 16.6 5.286l-1.467 1.733c.263.452.468.942.605 1.46L18 8.666v2.666l-2.263.19a5.899 5.899 0 0 1-.604 1.458l1.467 1.733-1.886 1.886-1.733-1.467a5.899 5.899 0 0 1-1.46.605L11.334 18H8.667l-.19-2.263a5.899 5.899 0 0 1-1.458-.604L5.286 16.6 3.4 14.714l1.467-1.733a5.899 5.899 0 0 1-.604-1.458L2 11.333V8.667l2.262-.189a5.899 5.899 0 0 1 .605-1.459L3.4 5.286 5.286 3.4l1.733 1.467a5.899 5.899 0 0 1 1.46-.605L8.666 2h2.666zM10 6.267a3.733 3.733 0 1 0 0 7.466 3.733 3.733 0 0 0 0-7.466z"/></svg>', eraser: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m8.636 9.531-2.758 3.94a.5.5 0 0 0 .122.696l3.224 2.284h1.314l2.636-3.736L8.636 9.53zm.288 8.451L5.14 15.396a2 2 0 0 1-.491-2.786l6.673-9.53a2 2 0 0 1 2.785-.49l3.742 2.62a2 2 0 0 1 .491 2.785l-7.269 10.053-2.147-.066z"/><path d="M4 18h5.523v-1H4zm-2 0h1v-1H2z"/></svg>', lowVision: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5.085 6.22 2.943 4.078a.75.75 0 1 1 1.06-1.06l2.592 2.59A11.094 11.094 0 0 1 10 5.068c4.738 0 8.578 3.101 8.578 5.083 0 1.197-1.401 2.803-3.555 3.887l1.714 1.713a.75.75 0 0 1-.09 1.138.488.488 0 0 1-.15.084.75.75 0 0 1-.821-.16L6.17 7.304c-.258.11-.51.233-.757.365l6.239 6.24-.006.005.78.78c-.388.094-.78.166-1.174.215l-1.11-1.11h.011L4.55 8.197a7.2 7.2 0 0 0-.665.514l-.112.098 4.897 4.897-.005.006 1.276 1.276a10.164 10.164 0 0 1-1.477-.117l-.479-.479-.009.009-4.863-4.863-.022.031a2.563 2.563 0 0 0-.124.2c-.043.077-.08.158-.108.241a.534.534 0 0 0-.028.133.29.29 0 0 0 .008.072.927.927 0 0 0 .082.226c.067.133.145.26.234.379l3.242 3.365.025.01.59.623c-3.265-.918-5.59-3.155-5.59-4.668 0-1.194 1.448-2.838 3.663-3.93zm7.07.531a4.632 4.632 0 0 1 1.108 5.992l.345.344.046-.018a9.313 9.313 0 0 0 2-1.112c.256-.187.5-.392.727-.613.137-.134.27-.277.392-.431.072-.091.141-.185.203-.286.057-.093.107-.19.148-.292a.72.72 0 0 0 .036-.12.29.29 0 0 0 .008-.072.492.492 0 0 0-.028-.133.999.999 0 0 0-.036-.096 2.165 2.165 0 0 0-.071-.145 2.917 2.917 0 0 0-.125-.2 3.592 3.592 0 0 0-.263-.335 5.444 5.444 0 0 0-.53-.523 7.955 7.955 0 0 0-1.054-.768 9.766 9.766 0 0 0-1.879-.891c-.337-.118-.68-.219-1.027-.301zm-2.85.21-.069.002a.508.508 0 0 0-.254.097.496.496 0 0 0-.104.679.498.498 0 0 0 .326.199l.045.005c.091.003.181.003.272.012a2.45 2.45 0 0 1 2.017 1.513c.024.061.043.125.069.185a.494.494 0 0 0 .45.287h.008a.496.496 0 0 0 .35-.158.482.482 0 0 0 .13-.335.638.638 0 0 0-.048-.219 3.379 3.379 0 0 0-.36-.723 3.438 3.438 0 0 0-2.791-1.543l-.028-.001h-.013z"/></svg>', image: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.91 10.54c.26-.23.64-.21.88.03l3.36 3.14 2.23-2.06a.64.64 0 0 1 .87 0l2.52 2.97V4.5H3.2v10.12l3.71-4.08zm10.27-7.51c.6 0 1.09.47 1.09 1.05v11.84c0 .59-.49 1.06-1.09 1.06H2.79c-.6 0-1.09-.47-1.09-1.06V4.08c0-.58.49-1.05 1.1-1.05h14.38zm-5.22 5.56a1.96 1.96 0 1 1 3.4-1.96 1.96 1.96 0 0 1-3.4 1.96z"/></svg>', alignBottom: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.239 13.938-2.88-1.663a.75.75 0 0 1 .75-1.3L9 12.067V4.75a.75.75 0 1 1 1.5 0v7.318l1.89-1.093a.75.75 0 0 1 .75 1.3l-2.879 1.663a.752.752 0 0 1-.511.187.752.752 0 0 1-.511-.187zM4.25 17a.75.75 0 1 1 0-1.5h10.5a.75.75 0 0 1 0 1.5H4.25z"/></svg>', alignMiddle: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.75 11.875a.752.752 0 0 1 .508.184l2.883 1.666a.75.75 0 0 1-.659 1.344l-.091-.044-1.892-1.093.001 4.318a.75.75 0 1 1-1.5 0v-4.317l-1.89 1.092a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .51-.187zM15.25 9a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM9.75.375a.75.75 0 0 1 .75.75v4.318l1.89-1.093.092-.045a.75.75 0 0 1 .659 1.344l-2.883 1.667a.752.752 0 0 1-.508.184.752.752 0 0 1-.511-.187L6.359 5.65a.75.75 0 0 1 .75-1.299L9 5.442V1.125a.75.75 0 0 1 .75-.75z"/></svg>', alignTop: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m10.261 7.062 2.88 1.663a.75.75 0 0 1-.75 1.3L10.5 8.933v7.317a.75.75 0 1 1-1.5 0V8.932l-1.89 1.093a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .511-.187.752.752 0 0 1 .511.187zM15.25 4a.75.75 0 1 1 0 1.5H4.75a.75.75 0 0 1 0-1.5h10.5z"/></svg>', alignLeft: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>', alignCenter: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm2.286 4c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75z"/></svg>', alignRight: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M18 3.75a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 8a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 4a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75zm0-8a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75z"/></svg>', alignJustify: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>', objectLeft: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zm0-3H18v1.5h-4.5zm0-3H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>', objectCenter: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M15.003 7v5.5a1 1 0 0 1-1 1H5.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H6.5V12h6.997V7.5z"/></svg>', objectRight: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2zm0-9h5v1.5H2zm0 3h5v1.5H2zm0 3h5v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>', objectFullWidth: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18 7v5.5a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1zm-1.505.5H3.504V12h12.991V7.5z"/></svg>', objectInline: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>', objectBlockLeft: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>', objectBlockRight: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>', objectSizeFull: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M18.095 2H1.905C.853 2 0 2.895 0 4v12c0 1.105.853 2 1.905 2h16.19C19.147 18 20 17.105 20 16V4c0-1.105-.853-2-1.905-2zm0 1.5c.263 0 .476.224.476.5v12c0 .276-.213.5-.476.5H1.905a.489.489 0 0 1-.476-.5V4c0-.276.213-.5.476-.5h16.19z"/></svg>', objectSizeLarge: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M13 6H2a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5V8a.5.5 0 0 1 .5-.5h11z"/></svg>', objectSizeSmall: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M7 10H2a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h5a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-4a.5.5 0 0 1 .5-.5h5z"/></svg>', objectSizeMedium: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M10 8H2a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2v-6a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-6a.5.5 0 0 1 .5-.5h8z"/></svg>', pencil: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m7.3 17.37-.061.088a1.518 1.518 0 0 1-.934.535l-4.178.663-.806-4.153a1.495 1.495 0 0 1 .187-1.058l.056-.086L8.77 2.639c.958-1.351 2.803-1.076 4.296-.03 1.497 1.047 2.387 2.693 1.433 4.055L7.3 17.37zM9.14 4.728l-5.545 8.346 3.277 2.294 5.544-8.346L9.14 4.728zM6.07 16.512l-3.276-2.295.53 2.73 2.746-.435zM9.994 3.506 13.271 5.8c.316-.452-.16-1.333-1.065-1.966-.905-.634-1.895-.78-2.212-.328zM8 18.5 9.375 17H19v1.5H8z"/></svg>', pilcrow: Cl, quote: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 10.423a6.5 6.5 0 0 1 6.056-6.408l.038.67C6.448 5.423 5.354 7.663 5.22 10H9c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574zm8 0a6.5 6.5 0 0 1 6.056-6.408l.038.67c-2.646.739-3.74 2.979-3.873 5.315H17c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574z"/></svg>', threeVerticalDots: Tl };
      function Il({ emitter: e2, activator: t2, callback: i2, contextElements: n2 }) {
        e2.listenTo(document, "mousedown", (e3, o2) => {
          if (!t2())
            return;
          const r2 = typeof o2.composedPath == "function" ? o2.composedPath() : [];
          for (const e4 of n2)
            if (e4.contains(o2.target) || r2.includes(e4))
              return;
          i2();
        });
      }
      function Sl(e2) {
        e2.set("_isCssTransitionsDisabled", false), e2.disableCssTransitions = () => {
          e2._isCssTransitionsDisabled = true;
        }, e2.enableCssTransitions = () => {
          e2._isCssTransitionsDisabled = false;
        }, e2.extendTemplate({ attributes: { class: [e2.bindTemplate.if("_isCssTransitionsDisabled", "ck-transitions-disabled")] } });
      }
      function Pl({ view: e2 }) {
        e2.listenTo(e2.element, "submit", (t2, i2) => {
          i2.preventDefault(), e2.fire("submit");
        }, { useCapture: true });
      }
      class Ml extends Zi {
        constructor(e2 = []) {
          super(e2, { idProperty: "viewUid" }), this.on("add", (e3, t2, i2) => {
            this._renderViewIntoCollectionParent(t2, i2);
          }), this.on("remove", (e3, t2) => {
            t2.element && this._parentElement && t2.element.remove();
          }), this._parentElement = null;
        }
        destroy() {
          this.map((e2) => e2.destroy());
        }
        setParent(e2) {
          this._parentElement = e2;
          for (const e3 of this)
            this._renderViewIntoCollectionParent(e3);
        }
        delegate(...e2) {
          if (!e2.length || !e2.every((e3) => typeof e3 == "string"))
            throw new c.a("ui-viewcollection-delegate-wrong-events", this);
          return { to: (t2) => {
            for (const i2 of this)
              for (const n2 of e2)
                i2.delegate(n2).to(t2);
            this.on("add", (i2, n2) => {
              for (const i3 of e2)
                n2.delegate(i3).to(t2);
            }), this.on("remove", (i2, n2) => {
              for (const i3 of e2)
                n2.stopDelegating(i3, t2);
            });
          } };
        }
        _renderViewIntoCollectionParent(e2, t2) {
          e2.isRendered || e2.render(), e2.element && this._parentElement && this._parentElement.insertBefore(e2.element, this._parentElement.children[t2]);
        }
      }
      i(15);
      class Nl {
        constructor(e2) {
          this.element = null, this.isRendered = false, this.locale = e2, this.t = e2 && e2.t, this._viewCollections = new Zi(), this._unboundChildren = this.createCollection(), this._viewCollections.on("add", (t2, i2) => {
            i2.locale = e2;
          }), this.decorate("render");
        }
        get bindTemplate() {
          return this._bindTemplate ? this._bindTemplate : this._bindTemplate = Rl.bind(this, this);
        }
        createCollection(e2) {
          const t2 = new Ml(e2);
          return this._viewCollections.add(t2), t2;
        }
        registerChild(e2) {
          Ji(e2) || (e2 = [e2]);
          for (const t2 of e2)
            this._unboundChildren.add(t2);
        }
        deregisterChild(e2) {
          Ji(e2) || (e2 = [e2]);
          for (const t2 of e2)
            this._unboundChildren.remove(t2);
        }
        setTemplate(e2) {
          this.template = new Rl(e2);
        }
        extendTemplate(e2) {
          Rl.extend(this.template, e2);
        }
        render() {
          if (this.isRendered)
            throw new c.a("ui-view-render-already-rendered", this);
          this.template && (this.element = this.template.render(), this.registerChild(this.template.getViews())), this.isRendered = true;
        }
        destroy() {
          this.stopListening(), this._viewCollections.map((e2) => e2.destroy()), this.template && this.template._revertData && this.template.revert(this.element);
        }
      }
      Ke(Nl, Pr), Ke(Nl, Ue);
      class Rl {
        constructor(e2) {
          Object.assign(this, Ul(Hl(e2))), this._isRendered = false, this._revertData = null;
        }
        render() {
          const e2 = this._renderNode({ intoFragment: true });
          return this._isRendered = true, e2;
        }
        apply(e2) {
          return this._revertData = { children: [], bindings: [], attributes: {} }, this._renderNode({ node: e2, isApplying: true, revertData: this._revertData }), e2;
        }
        revert(e2) {
          if (!this._revertData)
            throw new c.a("ui-template-revert-not-applied", [this, e2]);
          this._revertTemplateFromNode(e2, this._revertData);
        }
        *getViews() {
          yield* function* e2(t2) {
            if (t2.children)
              for (const i2 of t2.children)
                Gl(i2) ? yield i2 : Kl(i2) && (yield* e2(i2));
          }(this);
        }
        static bind(e2, t2) {
          return { to: (i2, n2) => new zl({ eventNameOrFunction: i2, attribute: i2, observable: e2, emitter: t2, callback: n2 }), if: (i2, n2, o2) => new Dl({ observable: e2, emitter: t2, attribute: i2, valueIfTrue: n2, callback: o2 }) };
        }
        static extend(e2, t2) {
          if (e2._isRendered)
            throw new c.a("template-extend-render", [this, e2]);
          !function e3(t3, i2) {
            i2.attributes && (t3.attributes || (t3.attributes = {}), $l(t3.attributes, i2.attributes));
            i2.eventListeners && (t3.eventListeners || (t3.eventListeners = {}), $l(t3.eventListeners, i2.eventListeners));
            i2.text && t3.text.push(...i2.text);
            if (i2.children && i2.children.length) {
              if (t3.children.length != i2.children.length)
                throw new c.a("ui-template-extend-children-mismatch", t3);
              let n2 = 0;
              for (const o2 of i2.children)
                e3(t3.children[n2++], o2);
            }
          }(e2, Ul(Hl(t2)));
        }
        _renderNode(e2) {
          let t2;
          if (t2 = e2.node ? this.tag && this.text : this.tag ? this.text : !this.text, t2)
            throw new c.a("ui-template-wrong-syntax", this);
          return this.text ? this._renderText(e2) : this._renderElement(e2);
        }
        _renderElement(e2) {
          let t2 = e2.node;
          return t2 || (t2 = e2.node = document.createElementNS(this.ns || "http://www.w3.org/1999/xhtml", this.tag)), this._renderAttributes(e2), this._renderElementChildren(e2), this._setUpListeners(e2), t2;
        }
        _renderText(e2) {
          let t2 = e2.node;
          return t2 ? e2.revertData.text = t2.textContent : t2 = e2.node = document.createTextNode(""), Ll(this.text) ? this._bindToObservable({ schema: this.text, updater: jl(t2), data: e2 }) : t2.textContent = this.text.join(""), t2;
        }
        _renderAttributes(e2) {
          let t2, i2, n2, o2;
          if (!this.attributes)
            return;
          const r2 = e2.node, s2 = e2.revertData;
          for (t2 in this.attributes)
            if (n2 = r2.getAttribute(t2), i2 = this.attributes[t2], s2 && (s2.attributes[t2] = n2), o2 = w(i2[0]) && i2[0].ns ? i2[0].ns : null, Ll(i2)) {
              const a2 = o2 ? i2[0].value : i2;
              s2 && Jl(t2) && a2.unshift(n2), this._bindToObservable({ schema: a2, updater: Bl(r2, t2, o2), data: e2 });
            } else
              t2 == "style" && typeof i2[0] != "string" ? this._renderStyleAttribute(i2[0], e2) : (s2 && n2 && Jl(t2) && i2.unshift(n2), i2 = i2.map((e3) => e3 && e3.value || e3).reduce((e3, t3) => e3.concat(t3), []).reduce(ql, ""), Yl(i2) || r2.setAttributeNS(o2, t2, i2));
        }
        _renderStyleAttribute(e2, t2) {
          const i2 = t2.node;
          for (const n2 in e2) {
            const o2 = e2[n2];
            Ll(o2) ? this._bindToObservable({ schema: [o2], updater: Fl(i2, n2), data: t2 }) : i2.style[n2] = o2;
          }
        }
        _renderElementChildren(e2) {
          const t2 = e2.node, i2 = e2.intoFragment ? document.createDocumentFragment() : t2, n2 = e2.isApplying;
          let o2 = 0;
          for (const r2 of this.children)
            if (Ql(r2)) {
              if (!n2) {
                r2.setParent(t2);
                for (const e3 of r2)
                  i2.appendChild(e3.element);
              }
            } else if (Gl(r2))
              n2 || (r2.isRendered || r2.render(), i2.appendChild(r2.element));
            else if (fr(r2))
              i2.appendChild(r2);
            else if (n2) {
              const t3 = { children: [], bindings: [], attributes: {} };
              e2.revertData.children.push(t3), r2._renderNode({ node: i2.childNodes[o2++], isApplying: true, revertData: t3 });
            } else
              i2.appendChild(r2.render());
          e2.intoFragment && t2.appendChild(i2);
        }
        _setUpListeners(e2) {
          if (this.eventListeners)
            for (const t2 in this.eventListeners) {
              const i2 = this.eventListeners[t2].map((i3) => {
                const [n2, o2] = t2.split("@");
                return i3.activateDomEventListener(n2, o2, e2);
              });
              e2.revertData && e2.revertData.bindings.push(i2);
            }
        }
        _bindToObservable({ schema: e2, updater: t2, data: i2 }) {
          const n2 = i2.revertData;
          Vl(e2, t2, i2);
          const o2 = e2.filter((e3) => !Yl(e3)).filter((e3) => e3.observable).map((n3) => n3.activateAttributeListener(e2, t2, i2));
          n2 && n2.bindings.push(o2);
        }
        _revertTemplateFromNode(e2, t2) {
          for (const e3 of t2.bindings)
            for (const t3 of e3)
              t3();
          if (t2.text)
            e2.textContent = t2.text;
          else {
            for (const i2 in t2.attributes) {
              const n2 = t2.attributes[i2];
              n2 === null ? e2.removeAttribute(i2) : e2.setAttribute(i2, n2);
            }
            for (let i2 = 0; i2 < t2.children.length; ++i2)
              this._revertTemplateFromNode(e2.childNodes[i2], t2.children[i2]);
          }
        }
      }
      Ke(Rl, h);
      class Ol {
        constructor(e2) {
          Object.assign(this, e2);
        }
        getValue(e2) {
          const t2 = this.observable[this.attribute];
          return this.callback ? this.callback(t2, e2) : t2;
        }
        activateAttributeListener(e2, t2, i2) {
          const n2 = () => Vl(e2, t2, i2);
          return this.emitter.listenTo(this.observable, "change:" + this.attribute, n2), () => {
            this.emitter.stopListening(this.observable, "change:" + this.attribute, n2);
          };
        }
      }
      class zl extends Ol {
        activateDomEventListener(e2, t2, i2) {
          const n2 = (e3, i3) => {
            t2 && !i3.target.matches(t2) || (typeof this.eventNameOrFunction == "function" ? this.eventNameOrFunction(i3) : this.observable.fire(this.eventNameOrFunction, i3));
          };
          return this.emitter.listenTo(i2.node, e2, n2), () => {
            this.emitter.stopListening(i2.node, e2, n2);
          };
        }
      }
      class Dl extends Ol {
        getValue(e2) {
          return !Yl(super.getValue(e2)) && (this.valueIfTrue || true);
        }
      }
      function Ll(e2) {
        return !!e2 && (e2.value && (e2 = e2.value), Array.isArray(e2) ? e2.some(Ll) : e2 instanceof Ol);
      }
      function Vl(e2, t2, { node: i2 }) {
        let n2 = function(e3, t3) {
          return e3.map((e4) => e4 instanceof Ol ? e4.getValue(t3) : e4);
        }(e2, i2);
        n2 = e2.length == 1 && e2[0] instanceof Dl ? n2[0] : n2.reduce(ql, ""), Yl(n2) ? t2.remove() : t2.set(n2);
      }
      function jl(e2) {
        return { set(t2) {
          e2.textContent = t2;
        }, remove() {
          e2.textContent = "";
        } };
      }
      function Bl(e2, t2, i2) {
        return { set(n2) {
          e2.setAttributeNS(i2, t2, n2);
        }, remove() {
          e2.removeAttributeNS(i2, t2);
        } };
      }
      function Fl(e2, t2) {
        return { set(i2) {
          e2.style[t2] = i2;
        }, remove() {
          e2.style[t2] = null;
        } };
      }
      function Hl(e2) {
        return $i(e2, (e3) => {
          if (e3 && (e3 instanceof Ol || Kl(e3) || Gl(e3) || Ql(e3)))
            return e3;
        });
      }
      function Ul(e2) {
        if (typeof e2 == "string" ? e2 = function(e3) {
          return { text: [e3] };
        }(e2) : e2.text && function(e3) {
          e3.text = en(e3.text);
        }(e2), e2.on && (e2.eventListeners = function(e3) {
          for (const t2 in e3)
            Wl(e3, t2);
          return e3;
        }(e2.on), delete e2.on), !e2.text) {
          e2.attributes && function(e3) {
            for (const t3 in e3)
              e3[t3].value && (e3[t3].value = en(e3[t3].value)), Wl(e3, t3);
          }(e2.attributes);
          const t2 = [];
          if (e2.children)
            if (Ql(e2.children))
              t2.push(e2.children);
            else
              for (const i2 of e2.children)
                Kl(i2) || Gl(i2) || fr(i2) ? t2.push(i2) : t2.push(new Rl(i2));
          e2.children = t2;
        }
        return e2;
      }
      function Wl(e2, t2) {
        e2[t2] = en(e2[t2]);
      }
      function ql(e2, t2) {
        return Yl(t2) ? e2 : Yl(e2) ? t2 : `${e2} ${t2}`;
      }
      function $l(e2, t2) {
        for (const i2 in t2)
          e2[i2] ? e2[i2].push(...t2[i2]) : e2[i2] = t2[i2];
      }
      function Yl(e2) {
        return !e2 && e2 !== 0;
      }
      function Gl(e2) {
        return e2 instanceof Nl;
      }
      function Kl(e2) {
        return e2 instanceof Rl;
      }
      function Ql(e2) {
        return e2 instanceof Ml;
      }
      function Jl(e2) {
        return e2 == "class" || e2 == "style";
      }
      class Zl extends Ml {
        constructor(e2, t2 = []) {
          super(t2), this.locale = e2;
        }
        attachToDom() {
          this._bodyCollectionContainer = new Rl({ tag: "div", attributes: { class: ["ck", "ck-reset_all", "ck-body", "ck-rounded-corners"], dir: this.locale.uiLanguageDirection }, children: this }).render();
          let e2 = document.querySelector(".ck-body-wrapper");
          e2 || (e2 = function(e3, t2, i2 = {}, n2 = []) {
            const o2 = i2 && i2.xmlns, r2 = o2 ? e3.createElementNS(o2, t2) : e3.createElement(t2);
            for (const e4 in i2)
              r2.setAttribute(e4, i2[e4]);
            !vs(n2) && Ji(n2) || (n2 = [n2]);
            for (let t3 of n2)
              vs(t3) && (t3 = e3.createTextNode(t3)), r2.appendChild(t3);
            return r2;
          }(document, "div", { class: "ck-body-wrapper" }), document.body.appendChild(e2)), e2.appendChild(this._bodyCollectionContainer);
        }
        detachFromDom() {
          super.destroy(), this._bodyCollectionContainer && this._bodyCollectionContainer.remove();
          const e2 = document.querySelector(".ck-body-wrapper");
          e2 && e2.childElementCount == 0 && e2.remove();
        }
      }
      i(17);
      class Xl extends Nl {
        constructor() {
          super();
          const e2 = this.bindTemplate;
          this.set("content", ""), this.set("viewBox", "0 0 20 20"), this.set("fillColor", ""), this.setTemplate({ tag: "svg", ns: "http://www.w3.org/2000/svg", attributes: { class: ["ck", "ck-icon"], viewBox: e2.to("viewBox") } });
        }
        render() {
          super.render(), this._updateXMLContent(), this._colorFillPaths(), this.on("change:content", () => {
            this._updateXMLContent(), this._colorFillPaths();
          }), this.on("change:fillColor", () => {
            this._colorFillPaths();
          });
        }
        _updateXMLContent() {
          if (this.content) {
            const e2 = new DOMParser().parseFromString(this.content.trim(), "image/svg+xml").querySelector("svg"), t2 = e2.getAttribute("viewBox");
            for (t2 && (this.viewBox = t2), this.element.innerHTML = ""; e2.childNodes.length > 0; )
              this.element.appendChild(e2.childNodes[0]);
          }
        }
        _colorFillPaths() {
          this.fillColor && this.element.querySelectorAll(".ck-icon__fill").forEach((e2) => {
            e2.style.fill = this.fillColor;
          });
        }
      }
      i(19);
      class ed extends Nl {
        constructor(e2) {
          super(e2), this.set("text", ""), this.set("position", "s");
          const t2 = this.bindTemplate;
          this.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-tooltip", t2.to("position", (e3) => "ck-tooltip_" + e3), t2.if("text", "ck-hidden", (e3) => !e3.trim())] }, children: [{ tag: "span", attributes: { class: ["ck", "ck-tooltip__text"] }, children: [{ text: t2.to("text") }] }] });
        }
      }
      i(21);
      class td extends Nl {
        constructor(e2) {
          super(e2);
          const t2 = this.bindTemplate, i2 = s();
          this.set("class"), this.set("labelStyle"), this.set("icon"), this.set("isEnabled", true), this.set("isOn", false), this.set("isVisible", true), this.set("isToggleable", false), this.set("keystroke"), this.set("label"), this.set("tabindex", -1), this.set("tooltip"), this.set("tooltipPosition", "s"), this.set("type", "button"), this.set("withText", false), this.set("withKeystroke", false), this.children = this.createCollection(), this.tooltipView = this._createTooltipView(), this.labelView = this._createLabelView(i2), this.iconView = new Xl(), this.iconView.extendTemplate({ attributes: { class: "ck-button__icon" } }), this.keystrokeView = this._createKeystrokeView(), this.bind("_tooltipString").to(this, "tooltip", this, "label", this, "keystroke", this._getTooltipString.bind(this)), this.setTemplate({ tag: "button", attributes: { class: ["ck", "ck-button", t2.to("class"), t2.if("isEnabled", "ck-disabled", (e3) => !e3), t2.if("isVisible", "ck-hidden", (e3) => !e3), t2.to("isOn", (e3) => e3 ? "ck-on" : "ck-off"), t2.if("withText", "ck-button_with-text"), t2.if("withKeystroke", "ck-button_with-keystroke")], type: t2.to("type", (e3) => e3 || "button"), tabindex: t2.to("tabindex"), "aria-labelledby": "ck-editor__aria-label_" + i2, "aria-disabled": t2.if("isEnabled", true, (e3) => !e3), "aria-pressed": t2.to("isOn", (e3) => !!this.isToggleable && String(e3)) }, children: this.children, on: { mousedown: t2.to((e3) => {
            e3.preventDefault();
          }), click: t2.to((e3) => {
            this.isEnabled ? this.fire("execute") : e3.preventDefault();
          }) } });
        }
        render() {
          super.render(), this.icon && (this.iconView.bind("content").to(this, "icon"), this.children.add(this.iconView)), this.children.add(this.tooltipView), this.children.add(this.labelView), this.withKeystroke && this.keystroke && this.children.add(this.keystrokeView);
        }
        focus() {
          this.element.focus();
        }
        _createTooltipView() {
          const e2 = new ed();
          return e2.bind("text").to(this, "_tooltipString"), e2.bind("position").to(this, "tooltipPosition"), e2;
        }
        _createLabelView(e2) {
          const t2 = new Nl(), i2 = this.bindTemplate;
          return t2.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-button__label"], style: i2.to("labelStyle"), id: "ck-editor__aria-label_" + e2 }, children: [{ text: this.bindTemplate.to("label") }] }), t2;
        }
        _createKeystrokeView() {
          const e2 = new Nl();
          return e2.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-button__keystroke"] }, children: [{ text: this.bindTemplate.to("keystroke", (e3) => Do(e3)) }] }), e2;
        }
        _getTooltipString(e2, t2, i2) {
          return e2 ? typeof e2 == "string" ? e2 : (i2 && (i2 = Do(i2)), e2 instanceof Function ? e2(t2, i2) : `${t2}${i2 ? ` (${i2})` : ""}`) : "";
        }
      }
      i(23);
      class id extends td {
        constructor(e2) {
          super(e2), this.isToggleable = true, this.toggleSwitchView = this._createToggleView(), this.extendTemplate({ attributes: { class: "ck-switchbutton" } });
        }
        render() {
          super.render(), this.children.add(this.toggleSwitchView);
        }
        _createToggleView() {
          const e2 = new Nl();
          return e2.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-button__toggle"] }, children: [{ tag: "span", attributes: { class: ["ck", "ck-button__toggle__inner"] } }] }), e2;
        }
      }
      class nd {
        constructor(e2) {
          if (Object.assign(this, e2), e2.actions && e2.keystrokeHandler)
            for (const t2 in e2.actions) {
              let i2 = e2.actions[t2];
              typeof i2 == "string" && (i2 = [i2]);
              for (const n2 of i2)
                e2.keystrokeHandler.set(n2, (e3, i3) => {
                  this[t2](), i3();
                });
            }
        }
        get first() {
          return this.focusables.find(od) || null;
        }
        get last() {
          return this.focusables.filter(od).slice(-1)[0] || null;
        }
        get next() {
          return this._getFocusableItem(1);
        }
        get previous() {
          return this._getFocusableItem(-1);
        }
        get current() {
          let e2 = null;
          return this.focusTracker.focusedElement === null ? null : (this.focusables.find((t2, i2) => {
            const n2 = t2.element === this.focusTracker.focusedElement;
            return n2 && (e2 = i2), n2;
          }), e2);
        }
        focusFirst() {
          this._focus(this.first);
        }
        focusLast() {
          this._focus(this.last);
        }
        focusNext() {
          this._focus(this.next);
        }
        focusPrevious() {
          this._focus(this.previous);
        }
        _focus(e2) {
          e2 && e2.focus();
        }
        _getFocusableItem(e2) {
          const t2 = this.current, i2 = this.focusables.length;
          if (!i2)
            return null;
          if (t2 === null)
            return this[e2 === 1 ? "first" : "last"];
          let n2 = (t2 + i2 + e2) % i2;
          do {
            const t3 = this.focusables.get(n2);
            if (od(t3))
              return t3;
            n2 = (n2 + i2 + e2) % i2;
          } while (n2 !== t2);
          return null;
        }
      }
      function od(e2) {
        return !(!e2.focus || _r.window.getComputedStyle(e2.element).display == "none");
      }
      i(25);
      var rd = '<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><path d="M.941 4.523a.75.75 0 1 1 1.06-1.06l3.006 3.005 3.005-3.005a.75.75 0 1 1 1.06 1.06l-3.549 3.55a.75.75 0 0 1-1.168-.136L.941 4.523z"/></svg>';
      class sd extends td {
        constructor(e2) {
          super(e2), this.arrowView = this._createArrowView(), this.extendTemplate({ attributes: { "aria-haspopup": true } }), this.delegate("execute").to(this, "open");
        }
        render() {
          super.render(), this.children.add(this.arrowView);
        }
        _createArrowView() {
          const e2 = new Xl();
          return e2.content = rd, e2.extendTemplate({ attributes: { class: "ck-dropdown__arrow" } }), e2;
        }
      }
      i(27);
      class ad extends Nl {
        constructor(e2) {
          super(e2);
          const t2 = this.bindTemplate;
          this.set("class"), this.set("icon"), this.set("isEnabled", true), this.set("isOn", false), this.set("isToggleable", false), this.set("isVisible", true), this.set("keystroke"), this.set("label"), this.set("tabindex", -1), this.set("tooltip"), this.set("tooltipPosition", "s"), this.set("type", "button"), this.set("withText", false), this.children = this.createCollection(), this.actionView = this._createActionView(), this.arrowView = this._createArrowView(), this.keystrokes = new Rs(), this.focusTracker = new Ns(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-splitbutton", t2.to("class"), t2.if("isVisible", "ck-hidden", (e3) => !e3), this.arrowView.bindTemplate.if("isOn", "ck-splitbutton_open")] }, children: this.children });
        }
        render() {
          super.render(), this.children.add(this.actionView), this.children.add(this.arrowView), this.focusTracker.add(this.actionView.element), this.focusTracker.add(this.arrowView.element), this.keystrokes.listenTo(this.element), this.keystrokes.set("arrowright", (e2, t2) => {
            this.focusTracker.focusedElement === this.actionView.element && (this.arrowView.focus(), t2());
          }), this.keystrokes.set("arrowleft", (e2, t2) => {
            this.focusTracker.focusedElement === this.arrowView.element && (this.actionView.focus(), t2());
          });
        }
        focus() {
          this.actionView.focus();
        }
        _createActionView() {
          const e2 = new td();
          return e2.bind("icon", "isEnabled", "isOn", "isToggleable", "keystroke", "label", "tabindex", "tooltip", "tooltipPosition", "type", "withText").to(this), e2.extendTemplate({ attributes: { class: "ck-splitbutton__action" } }), e2.delegate("execute").to(this), e2;
        }
        _createArrowView() {
          const e2 = new td(), t2 = e2.bindTemplate;
          return e2.icon = rd, e2.extendTemplate({ attributes: { class: "ck-splitbutton__arrow", "aria-haspopup": true, "aria-expanded": t2.to("isOn", (e3) => String(e3)) } }), e2.bind("isEnabled").to(this), e2.delegate("execute").to(this, "open"), e2;
        }
      }
      class cd extends Nl {
        constructor(e2) {
          super(e2);
          const t2 = this.bindTemplate;
          this.set("isVisible", false), this.set("position", "se"), this.children = this.createCollection(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-reset", "ck-dropdown__panel", t2.to("position", (e3) => "ck-dropdown__panel_" + e3), t2.if("isVisible", "ck-dropdown__panel-visible")] }, children: this.children, on: { selectstart: t2.to((e3) => e3.preventDefault()) } });
        }
        focus() {
          this.children.length && this.children.first.focus();
        }
        focusLast() {
          if (this.children.length) {
            const e2 = this.children.last;
            typeof e2.focusLast == "function" ? e2.focusLast() : e2.focus();
          }
        }
      }
      i(29);
      function ld({ element: e2, target: t2, positions: i2, limiter: n2, fitInViewport: o2, viewportOffsetConfig: r2 }) {
        M(t2) && (t2 = t2()), M(n2) && (n2 = n2());
        const s2 = function(e3) {
          return e3 && e3.parentNode ? e3.offsetParent === _r.document.body ? null : e3.offsetParent : null;
        }(e2), a2 = new Cs(e2);
        let c2;
        const l2 = { targetRect: new Cs(t2), elementRect: a2, positionedElementAncestor: s2 };
        if (n2 || o2) {
          const e3 = n2 && new Cs(n2).getVisible(), t3 = o2 && function(e4) {
            e4 = Object.assign({ top: 0, bottom: 0, left: 0, right: 0 }, e4);
            const t4 = new Cs(_r.window);
            return t4.top += e4.top, t4.height -= e4.top, t4.bottom -= e4.bottom, t4.height -= e4.bottom, t4;
          }(r2);
          Object.assign(l2, { limiterRect: e3, viewportRect: t3 }), c2 = function(e4, t4) {
            const { elementRect: i3 } = t4, n3 = i3.getArea(), o3 = e4.map((e5) => new hd(e5, t4)).filter((e5) => !!e5.name);
            let r3 = 0, s3 = null;
            for (const e5 of o3) {
              const { _limiterIntersectionArea: t5, _viewportIntersectionArea: i4 } = e5;
              if (t5 === n3)
                return e5;
              const o4 = i4 ** 2 + t5 ** 2;
              o4 > r3 && (r3 = o4, s3 = e5);
            }
            return s3;
          }(i2, l2) || new hd(i2[0], l2);
        } else
          c2 = new hd(i2[0], l2);
        return c2;
      }
      function dd(e2) {
        const { scrollX: t2, scrollY: i2 } = _r.window;
        return e2.clone().moveBy(t2, i2);
      }
      class hd {
        constructor(e2, t2) {
          const i2 = e2(t2.targetRect, t2.elementRect, t2.viewportRect);
          if (!i2)
            return;
          const { left: n2, top: o2, name: r2, config: s2 } = i2;
          Object.assign(this, { name: r2, config: s2 }), this._positioningFunctionCorrdinates = { left: n2, top: o2 }, this._options = t2;
        }
        get left() {
          return this._absoluteRect.left;
        }
        get top() {
          return this._absoluteRect.top;
        }
        get _limiterIntersectionArea() {
          const e2 = this._options.limiterRect;
          if (e2) {
            const t2 = this._options.viewportRect;
            if (!t2)
              return e2.getIntersectionArea(this._rect);
            {
              const i2 = e2.getIntersection(t2);
              if (i2)
                return i2.getIntersectionArea(this._rect);
            }
          }
          return 0;
        }
        get _viewportIntersectionArea() {
          const e2 = this._options.viewportRect;
          return e2 ? e2.getIntersectionArea(this._rect) : 0;
        }
        get _rect() {
          return this._cachedRect || (this._cachedRect = this._options.elementRect.clone().moveTo(this._positioningFunctionCorrdinates.left, this._positioningFunctionCorrdinates.top)), this._cachedRect;
        }
        get _absoluteRect() {
          return this._cachedAbsoluteRect || (this._cachedAbsoluteRect = dd(this._rect), this._options.positionedElementAncestor && function(e2, t2) {
            const i2 = dd(new Cs(t2)), n2 = xs(t2);
            let o2 = 0, r2 = 0;
            o2 -= i2.left, r2 -= i2.top, o2 += t2.scrollLeft, r2 += t2.scrollTop, o2 -= n2.left, r2 -= n2.top, e2.moveBy(o2, r2);
          }(this._cachedAbsoluteRect, this._options.positionedElementAncestor)), this._cachedAbsoluteRect;
        }
      }
      class ud extends Nl {
        constructor(e2, t2, i2) {
          super(e2);
          const n2 = this.bindTemplate;
          this.buttonView = t2, this.panelView = i2, this.set("isOpen", false), this.set("isEnabled", true), this.set("class"), this.set("id"), this.set("panelPosition", "auto"), this.keystrokes = new Rs(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-dropdown", n2.to("class"), n2.if("isEnabled", "ck-disabled", (e3) => !e3)], id: n2.to("id"), "aria-describedby": n2.to("ariaDescribedById") }, children: [t2, i2] }), t2.extendTemplate({ attributes: { class: ["ck-dropdown__button"] } });
        }
        render() {
          super.render(), this.listenTo(this.buttonView, "open", () => {
            this.isOpen = !this.isOpen;
          }), this.panelView.bind("isVisible").to(this, "isOpen"), this.on("change:isOpen", () => {
            this.isOpen && (this.panelPosition === "auto" ? this.panelView.position = ud._getOptimalPosition({ element: this.panelView.element, target: this.buttonView.element, fitInViewport: true, positions: this._panelPositions }).name : this.panelView.position = this.panelPosition);
          }), this.keystrokes.listenTo(this.element);
          const e2 = (e3, t2) => {
            this.isOpen && (this.buttonView.focus(), this.isOpen = false, t2());
          };
          this.keystrokes.set("arrowdown", (e3, t2) => {
            this.buttonView.isEnabled && !this.isOpen && (this.isOpen = true, t2());
          }), this.keystrokes.set("arrowright", (e3, t2) => {
            this.isOpen && t2();
          }), this.keystrokes.set("arrowleft", e2), this.keystrokes.set("esc", e2);
        }
        focus() {
          this.buttonView.focus();
        }
        get _panelPositions() {
          const { south: e2, north: t2, southEast: i2, southWest: n2, northEast: o2, northWest: r2, southMiddleEast: s2, southMiddleWest: a2, northMiddleEast: c2, northMiddleWest: l2 } = ud.defaultPanelPositions;
          return this.locale.uiLanguageDirection !== "rtl" ? [i2, n2, s2, a2, e2, o2, r2, c2, l2, t2] : [n2, i2, a2, s2, e2, r2, o2, l2, c2, t2];
        }
      }
      ud.defaultPanelPositions = { south: (e2, t2) => ({ top: e2.bottom, left: e2.left - (t2.width - e2.width) / 2, name: "s" }), southEast: (e2) => ({ top: e2.bottom, left: e2.left, name: "se" }), southWest: (e2, t2) => ({ top: e2.bottom, left: e2.left - t2.width + e2.width, name: "sw" }), southMiddleEast: (e2, t2) => ({ top: e2.bottom, left: e2.left - (t2.width - e2.width) / 4, name: "sme" }), southMiddleWest: (e2, t2) => ({ top: e2.bottom, left: e2.left - 3 * (t2.width - e2.width) / 4, name: "smw" }), north: (e2, t2) => ({ top: e2.top - t2.height, left: e2.left - (t2.width - e2.width) / 2, name: "n" }), northEast: (e2, t2) => ({ top: e2.top - t2.height, left: e2.left, name: "ne" }), northWest: (e2, t2) => ({ top: e2.top - t2.height, left: e2.left - t2.width + e2.width, name: "nw" }), northMiddleEast: (e2, t2) => ({ top: e2.top - t2.height, left: e2.left - (t2.width - e2.width) / 4, name: "nme" }), northMiddleWest: (e2, t2) => ({ top: e2.top - t2.height, left: e2.left - 3 * (t2.width - e2.width) / 4, name: "nmw" }) }, ud._getOptimalPosition = ld;
      class gd extends Nl {
        constructor(e2) {
          super(e2), this.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-toolbar__separator"] } });
        }
      }
      class md extends Nl {
        constructor(e2) {
          super(e2), this.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-toolbar__line-break"] } });
        }
      }
      function fd(e2) {
        return Array.isArray(e2) ? { items: e2, removeItems: [] } : e2 ? Object.assign({ items: [], removeItems: [] }, e2) : { items: [], removeItems: [] };
      }
      i(31);
      class pd extends Nl {
        constructor(e2, t2) {
          super(e2);
          const i2 = this.bindTemplate, n2 = this.t;
          this.options = t2 || {}, this.set("ariaLabel", n2("Editor toolbar")), this.set("maxWidth", "auto"), this.items = this.createCollection(), this.focusTracker = new Ns(), this.keystrokes = new Rs(), this.set("class"), this.set("isCompact", false), this.itemsView = new bd(e2), this.children = this.createCollection(), this.children.add(this.itemsView), this.focusables = this.createCollection();
          const o2 = e2.uiLanguageDirection === "rtl";
          this._focusCycler = new nd({ focusables: this.focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: [o2 ? "arrowright" : "arrowleft", "arrowup"], focusNext: [o2 ? "arrowleft" : "arrowright", "arrowdown"] } });
          const r2 = ["ck", "ck-toolbar", i2.to("class"), i2.if("isCompact", "ck-toolbar_compact")];
          var s2;
          this.options.shouldGroupWhenFull && this.options.isFloating && r2.push("ck-toolbar_floating"), this.setTemplate({ tag: "div", attributes: { class: r2, role: "toolbar", "aria-label": i2.to("ariaLabel"), style: { maxWidth: i2.to("maxWidth") } }, children: this.children, on: { mousedown: (s2 = this, s2.bindTemplate.to((e3) => {
            e3.target === s2.element && e3.preventDefault();
          })) } }), this._behavior = this.options.shouldGroupWhenFull ? new kd(this) : new wd(this);
        }
        render() {
          super.render();
          for (const e2 of this.items)
            this.focusTracker.add(e2.element);
          this.items.on("add", (e2, t2) => {
            this.focusTracker.add(t2.element);
          }), this.items.on("remove", (e2, t2) => {
            this.focusTracker.remove(t2.element);
          }), this.keystrokes.listenTo(this.element), this._behavior.render(this);
        }
        destroy() {
          return this._behavior.destroy(), super.destroy();
        }
        focus() {
          this._focusCycler.focusFirst();
        }
        focusLast() {
          this._focusCycler.focusLast();
        }
        fillFromConfig(e2, t2) {
          const i2 = fd(e2), n2 = i2.items.filter((e3, n3, o3) => e3 === "|" || i2.removeItems.indexOf(e3) === -1 && (e3 === "-" ? !this.options.shouldGroupWhenFull || (Object(c.b)("toolbarview-line-break-ignored-when-grouping-items", o3), false) : !!t2.has(e3) || (Object(c.b)("toolbarview-item-unavailable", { name: e3 }), false))), o2 = this._cleanSeparators(n2).map((e3) => e3 === "|" ? new gd() : e3 === "-" ? new md() : t2.create(e3));
          this.items.addMany(o2);
        }
        _cleanSeparators(e2) {
          const t2 = (e3) => e3 !== "-" && e3 !== "|", i2 = e2.length, n2 = e2.findIndex(t2), o2 = i2 - e2.slice().reverse().findIndex(t2);
          return e2.slice(n2, o2).filter((e3, i3, n3) => {
            if (t2(e3))
              return true;
            return !(i3 > 0 && n3[i3 - 1] === e3);
          });
        }
      }
      class bd extends Nl {
        constructor(e2) {
          super(e2), this.children = this.createCollection(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-toolbar__items"] }, children: this.children });
        }
      }
      class wd {
        constructor(e2) {
          const t2 = e2.bindTemplate;
          e2.set("isVertical", false), e2.itemsView.children.bindTo(e2.items).using((e3) => e3), e2.focusables.bindTo(e2.items).using((e3) => e3), e2.extendTemplate({ attributes: { class: [t2.if("isVertical", "ck-toolbar_vertical")] } });
        }
        render() {
        }
        destroy() {
        }
      }
      class kd {
        constructor(e2) {
          this.view = e2, this.viewChildren = e2.children, this.viewFocusables = e2.focusables, this.viewItemsView = e2.itemsView, this.viewFocusTracker = e2.focusTracker, this.viewLocale = e2.locale, this.ungroupedItems = e2.createCollection(), this.groupedItems = e2.createCollection(), this.groupedItemsDropdown = this._createGroupedItemsDropdown(), this.resizeObserver = null, this.cachedPadding = null, this.shouldUpdateGroupingOnNextResize = false, e2.itemsView.children.bindTo(this.ungroupedItems).using((e3) => e3), this.ungroupedItems.on("add", this._updateFocusCycleableItems.bind(this)), this.ungroupedItems.on("remove", this._updateFocusCycleableItems.bind(this)), e2.children.on("add", this._updateFocusCycleableItems.bind(this)), e2.children.on("remove", this._updateFocusCycleableItems.bind(this)), e2.items.on("change", (e3, t2) => {
            const i2 = t2.index;
            for (const e4 of t2.removed)
              i2 >= this.ungroupedItems.length ? this.groupedItems.remove(e4) : this.ungroupedItems.remove(e4);
            for (let e4 = i2; e4 < i2 + t2.added.length; e4++) {
              const n2 = t2.added[e4 - i2];
              e4 > this.ungroupedItems.length ? this.groupedItems.add(n2, e4 - this.ungroupedItems.length) : this.ungroupedItems.add(n2, e4);
            }
            this._updateGrouping();
          }), e2.extendTemplate({ attributes: { class: ["ck-toolbar_grouping"] } });
        }
        render(e2) {
          this.viewElement = e2.element, this._enableGroupingOnResize(), this._enableGroupingOnMaxWidthChange(e2);
        }
        destroy() {
          this.groupedItemsDropdown.destroy(), this.resizeObserver.destroy();
        }
        _updateGrouping() {
          if (!this.viewElement.ownerDocument.body.contains(this.viewElement))
            return;
          if (!this.viewElement.offsetParent)
            return void (this.shouldUpdateGroupingOnNextResize = true);
          const e2 = this.groupedItems.length;
          let t2;
          for (; this._areItemsOverflowing; )
            this._groupLastItem(), t2 = true;
          if (!t2 && this.groupedItems.length) {
            for (; this.groupedItems.length && !this._areItemsOverflowing; )
              this._ungroupFirstItem();
            this._areItemsOverflowing && this._groupLastItem();
          }
          this.groupedItems.length !== e2 && this.view.fire("groupedItemsUpdate");
        }
        get _areItemsOverflowing() {
          if (!this.ungroupedItems.length)
            return false;
          const e2 = this.viewElement, t2 = this.viewLocale.uiLanguageDirection, i2 = new Cs(e2.lastChild), n2 = new Cs(e2);
          if (!this.cachedPadding) {
            const i3 = _r.window.getComputedStyle(e2), n3 = t2 === "ltr" ? "paddingRight" : "paddingLeft";
            this.cachedPadding = Number.parseInt(i3[n3]);
          }
          return t2 === "ltr" ? i2.right > n2.right - this.cachedPadding : i2.left < n2.left + this.cachedPadding;
        }
        _enableGroupingOnResize() {
          let e2;
          this.resizeObserver = new Is(this.viewElement, (t2) => {
            e2 && e2 === t2.contentRect.width && !this.shouldUpdateGroupingOnNextResize || (this.shouldUpdateGroupingOnNextResize = false, this._updateGrouping(), e2 = t2.contentRect.width);
          }), this._updateGrouping();
        }
        _enableGroupingOnMaxWidthChange(e2) {
          e2.on("change:maxWidth", () => {
            this._updateGrouping();
          });
        }
        _groupLastItem() {
          this.groupedItems.length || (this.viewChildren.add(new gd()), this.viewChildren.add(this.groupedItemsDropdown), this.viewFocusTracker.add(this.groupedItemsDropdown.element)), this.groupedItems.add(this.ungroupedItems.remove(this.ungroupedItems.last), 0);
        }
        _ungroupFirstItem() {
          this.ungroupedItems.add(this.groupedItems.remove(this.groupedItems.first)), this.groupedItems.length || (this.viewChildren.remove(this.groupedItemsDropdown), this.viewChildren.remove(this.viewChildren.last), this.viewFocusTracker.remove(this.groupedItemsDropdown.element));
        }
        _createGroupedItemsDropdown() {
          const e2 = this.viewLocale, t2 = e2.t, i2 = xd(e2);
          return i2.class = "ck-toolbar__grouped-dropdown", i2.panelPosition = e2.uiLanguageDirection === "ltr" ? "sw" : "se", Ad(i2, []), i2.buttonView.set({ label: t2("Show more items"), tooltip: true, tooltipPosition: e2.uiLanguageDirection === "rtl" ? "se" : "sw", icon: Tl }), i2.toolbarView.items.bindTo(this.groupedItems).using((e3) => e3), i2;
        }
        _updateFocusCycleableItems() {
          this.viewFocusables.clear(), this.ungroupedItems.map((e2) => {
            this.viewFocusables.add(e2);
          }), this.groupedItems.length && this.viewFocusables.add(this.groupedItemsDropdown);
        }
      }
      i(33);
      class _d extends Nl {
        constructor() {
          super(), this.items = this.createCollection(), this.focusTracker = new Ns(), this.keystrokes = new Rs(), this._focusCycler = new nd({ focusables: this.items, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "arrowup", focusNext: "arrowdown" } }), this.setTemplate({ tag: "ul", attributes: { class: ["ck", "ck-reset", "ck-list"] }, children: this.items });
        }
        render() {
          super.render();
          for (const e2 of this.items)
            this.focusTracker.add(e2.element);
          this.items.on("add", (e2, t2) => {
            this.focusTracker.add(t2.element);
          }), this.items.on("remove", (e2, t2) => {
            this.focusTracker.remove(t2.element);
          }), this.keystrokes.listenTo(this.element);
        }
        focus() {
          this._focusCycler.focusFirst();
        }
        focusLast() {
          this._focusCycler.focusLast();
        }
      }
      class vd extends Nl {
        constructor(e2) {
          super(e2), this.children = this.createCollection(), this.setTemplate({ tag: "li", attributes: { class: ["ck", "ck-list__item"] }, children: this.children });
        }
        focus() {
          this.children.first.focus();
        }
      }
      class yd extends Nl {
        constructor(e2) {
          super(e2), this.setTemplate({ tag: "li", attributes: { class: ["ck", "ck-list__separator"] } });
        }
      }
      i(35), i(37);
      function xd(e2, t2 = sd) {
        const i2 = new t2(e2), n2 = new cd(e2), o2 = new ud(e2, i2, n2);
        return i2.bind("isEnabled").to(o2), i2 instanceof sd ? i2.bind("isOn").to(o2, "isOpen") : i2.arrowView.bind("isOn").to(o2, "isOpen"), function(e3) {
          (function(e4) {
            e4.on("render", () => {
              Il({ emitter: e4, activator: () => e4.isOpen, callback: () => {
                e4.isOpen = false;
              }, contextElements: [e4.element] });
            });
          })(e3), function(e4) {
            e4.on("execute", (t3) => {
              t3.source instanceof id || (e4.isOpen = false);
            });
          }(e3), function(e4) {
            e4.keystrokes.set("arrowdown", (t3, i3) => {
              e4.isOpen && (e4.panelView.focus(), i3());
            }), e4.keystrokes.set("arrowup", (t3, i3) => {
              e4.isOpen && (e4.panelView.focusLast(), i3());
            });
          }(e3);
        }(o2), o2;
      }
      function Ad(e2, t2) {
        const i2 = e2.locale, n2 = i2.t, o2 = e2.toolbarView = new pd(i2);
        o2.set("ariaLabel", n2("Dropdown toolbar")), e2.extendTemplate({ attributes: { class: ["ck-toolbar-dropdown"] } }), t2.map((e3) => o2.items.add(e3)), e2.panelView.children.add(o2), o2.items.delegate("execute").to(e2);
      }
      function Cd(e2, t2) {
        const i2 = e2.locale, n2 = e2.listView = new _d(i2);
        n2.items.bindTo(t2).using(({ type: e3, model: t3 }) => {
          if (e3 === "separator")
            return new yd(i2);
          if (e3 === "button" || e3 === "switchbutton") {
            const n3 = new vd(i2);
            let o2;
            return o2 = e3 === "button" ? new td(i2) : new id(i2), o2.bind(...Object.keys(t3)).to(t3), o2.delegate("execute").to(n3), n3.children.add(o2), n3;
          }
        }), e2.panelView.children.add(n2), n2.items.delegate("execute").to(e2);
      }
      i(39);
      class Td extends Nl {
        constructor(e2) {
          super(e2), this.body = new Zl(e2);
        }
        render() {
          super.render(), this.body.attachToDom();
        }
        destroy() {
          return this.body.detachFromDom(), super.destroy();
        }
      }
      i(41);
      class Ed extends Nl {
        constructor(e2) {
          super(e2), this.set("text"), this.set("for"), this.id = "ck-editor__label_" + s();
          const t2 = this.bindTemplate;
          this.setTemplate({ tag: "label", attributes: { class: ["ck", "ck-label"], id: this.id, for: t2.to("for") }, children: [{ text: t2.to("text") }] });
        }
      }
      class Id extends Td {
        constructor(e2) {
          super(e2), this.top = this.createCollection(), this.main = this.createCollection(), this._voiceLabelView = this._createVoiceLabel(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-reset", "ck-editor", "ck-rounded-corners"], role: "application", dir: e2.uiLanguageDirection, lang: e2.uiLanguage, "aria-labelledby": this._voiceLabelView.id }, children: [this._voiceLabelView, { tag: "div", attributes: { class: ["ck", "ck-editor__top", "ck-reset_all"], role: "presentation" }, children: this.top }, { tag: "div", attributes: { class: ["ck", "ck-editor__main"], role: "presentation" }, children: this.main }] });
        }
        _createVoiceLabel() {
          const e2 = this.t, t2 = new Ed();
          return t2.text = e2("Rich Text Editor"), t2.extendTemplate({ attributes: { class: "ck-voice-label" } }), t2;
        }
      }
      class Sd extends Nl {
        constructor(e2, t2, i2) {
          super(e2), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-content", "ck-editor__editable", "ck-rounded-corners"], lang: e2.contentLanguage, dir: e2.contentLanguageDirection } }), this.name = null, this.set("isFocused", false), this._editableElement = i2, this._hasExternalElement = !!this._editableElement, this._editingView = t2;
        }
        render() {
          super.render(), this._hasExternalElement ? this.template.apply(this.element = this._editableElement) : this._editableElement = this.element, this.on("change:isFocused", () => this._updateIsFocusedClasses()), this._updateIsFocusedClasses();
        }
        destroy() {
          this._hasExternalElement && this.template.revert(this._editableElement), super.destroy();
        }
        _updateIsFocusedClasses() {
          const e2 = this._editingView;
          function t2(t3) {
            e2.change((i2) => {
              const n2 = e2.document.getRoot(t3.name);
              i2.addClass(t3.isFocused ? "ck-focused" : "ck-blurred", n2), i2.removeClass(t3.isFocused ? "ck-blurred" : "ck-focused", n2);
            });
          }
          e2.isRenderingInProgress ? function i2(n2) {
            e2.once("change:isRenderingInProgress", (e3, o2, r2) => {
              r2 ? i2(n2) : t2(n2);
            });
          }(this) : t2(this);
        }
      }
      class Pd extends Sd {
        constructor(e2, t2, i2) {
          super(e2, t2, i2), this.extendTemplate({ attributes: { role: "textbox", class: "ck-editor__editable_inline" } });
        }
        render() {
          super.render();
          const e2 = this._editingView, t2 = this.t;
          e2.change((i2) => {
            const n2 = e2.document.getRoot(this.name);
            i2.setAttribute("aria-label", t2("Rich Text Editor, %0", this.name), n2);
          });
        }
      }
      i(43);
      i(45);
      class Md extends Nl {
        constructor(e2) {
          super(e2), this.set("value"), this.set("id"), this.set("placeholder"), this.set("isReadOnly", false), this.set("hasError", false), this.set("ariaDescribedById"), this.focusTracker = new Ns(), this.bind("isFocused").to(this.focusTracker), this.set("isEmpty", true);
          const t2 = this.bindTemplate;
          this.setTemplate({ tag: "input", attributes: { type: "text", class: ["ck", "ck-input", "ck-input-text", t2.if("isFocused", "ck-input_focused"), t2.if("isEmpty", "ck-input-text_empty"), t2.if("hasError", "ck-error")], id: t2.to("id"), placeholder: t2.to("placeholder"), readonly: t2.to("isReadOnly"), "aria-invalid": t2.if("hasError", true), "aria-describedby": t2.to("ariaDescribedById") }, on: { input: t2.to("input"), change: t2.to(this._updateIsEmpty.bind(this)) } });
        }
        render() {
          super.render(), this.focusTracker.add(this.element), this._setDomElementValue(this.value), this._updateIsEmpty(), this.on("change:value", (e2, t2, i2) => {
            this._setDomElementValue(i2), this._updateIsEmpty();
          });
        }
        select() {
          this.element.select();
        }
        focus() {
          this.element.focus();
        }
        _updateIsEmpty() {
          this.isEmpty = !this.element.value;
        }
        _setDomElementValue(e2) {
          this.element.value = e2 || e2 === 0 ? e2 : "";
        }
      }
      i(47);
      class Nd extends Nl {
        constructor(e2, t2) {
          super(e2);
          const i2 = "ck-labeled-field-view-" + s(), n2 = "ck-labeled-field-view-status-" + s();
          this.fieldView = t2(this, i2, n2), this.set("label"), this.set("isEnabled", true), this.set("isEmpty", true), this.set("isFocused", false), this.set("errorText", null), this.set("infoText", null), this.set("class"), this.set("placeholder"), this.labelView = this._createLabelView(i2), this.statusView = this._createStatusView(n2), this.bind("_statusText").to(this, "errorText", this, "infoText", (e3, t3) => e3 || t3);
          const o2 = this.bindTemplate;
          this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-labeled-field-view", o2.to("class"), o2.if("isEnabled", "ck-disabled", (e3) => !e3), o2.if("isEmpty", "ck-labeled-field-view_empty"), o2.if("isFocused", "ck-labeled-field-view_focused"), o2.if("placeholder", "ck-labeled-field-view_placeholder"), o2.if("errorText", "ck-error")] }, children: [{ tag: "div", attributes: { class: ["ck", "ck-labeled-field-view__input-wrapper"] }, children: [this.fieldView, this.labelView] }, this.statusView] });
        }
        _createLabelView(e2) {
          const t2 = new Ed(this.locale);
          return t2.for = e2, t2.bind("text").to(this, "label"), t2;
        }
        _createStatusView(e2) {
          const t2 = new Nl(this.locale), i2 = this.bindTemplate;
          return t2.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-labeled-field-view__status", i2.if("errorText", "ck-labeled-field-view__status_error"), i2.if("_statusText", "ck-hidden", (e3) => !e3)], id: e2, role: i2.if("errorText", "alert") }, children: [{ text: i2.to("_statusText") }] }), t2;
        }
        focus() {
          this.fieldView.focus();
        }
      }
      function Rd(e2, t2, i2) {
        const n2 = new Md(e2.locale);
        return n2.set({ id: t2, ariaDescribedById: i2 }), n2.bind("isReadOnly").to(e2, "isEnabled", (e3) => !e3), n2.bind("hasError").to(e2, "errorText", (e3) => !!e3), n2.on("input", () => {
          e2.errorText = null;
        }), e2.bind("isEmpty", "isFocused", "placeholder").to(n2), n2;
      }
      class Od extends an {
        static get pluginName() {
          return "Notification";
        }
        init() {
          this.on("show:warning", (e2, t2) => {
            window.alert(t2.message);
          }, { priority: "lowest" });
        }
        showSuccess(e2, t2 = {}) {
          this._showNotification({ message: e2, type: "success", namespace: t2.namespace, title: t2.title });
        }
        showInfo(e2, t2 = {}) {
          this._showNotification({ message: e2, type: "info", namespace: t2.namespace, title: t2.title });
        }
        showWarning(e2, t2 = {}) {
          this._showNotification({ message: e2, type: "warning", namespace: t2.namespace, title: t2.title });
        }
        _showNotification(e2) {
          const t2 = "show:" + e2.type + (e2.namespace ? ":" + e2.namespace : "");
          this.fire(t2, { message: e2.message, type: e2.type, title: e2.title || "" });
        }
      }
      class zd {
        constructor(e2, t2) {
          t2 && De(this, t2), e2 && this.set(e2);
        }
      }
      Ke(zd, Ue);
      i(49);
      const Dd = Ps("px"), Ld = _r.document.body;
      class Vd extends Nl {
        constructor(e2) {
          super(e2);
          const t2 = this.bindTemplate;
          this.set("top", 0), this.set("left", 0), this.set("position", "arrow_nw"), this.set("isVisible", false), this.set("withArrow", true), this.set("class"), this.content = this.createCollection(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-balloon-panel", t2.to("position", (e3) => "ck-balloon-panel_" + e3), t2.if("isVisible", "ck-balloon-panel_visible"), t2.if("withArrow", "ck-balloon-panel_with-arrow"), t2.to("class")], style: { top: t2.to("top", Dd), left: t2.to("left", Dd) } }, children: this.content });
        }
        show() {
          this.isVisible = true;
        }
        hide() {
          this.isVisible = false;
        }
        attachTo(e2) {
          this.show();
          const t2 = Vd.defaultPositions, i2 = Object.assign({}, { element: this.element, positions: [t2.southArrowNorth, t2.southArrowNorthMiddleWest, t2.southArrowNorthMiddleEast, t2.southArrowNorthWest, t2.southArrowNorthEast, t2.northArrowSouth, t2.northArrowSouthMiddleWest, t2.northArrowSouthMiddleEast, t2.northArrowSouthWest, t2.northArrowSouthEast, t2.viewportStickyNorth], limiter: Ld, fitInViewport: true }, e2), n2 = Vd._getOptimalPosition(i2), o2 = parseInt(n2.left), r2 = parseInt(n2.top), { name: s2, config: a2 = {} } = n2, { withArrow: c2 = true } = a2;
          Object.assign(this, { top: r2, left: o2, position: s2, withArrow: c2 });
        }
        pin(e2) {
          this.unpin(), this._pinWhenIsVisibleCallback = () => {
            this.isVisible ? this._startPinning(e2) : this._stopPinning();
          }, this._startPinning(e2), this.listenTo(this, "change:isVisible", this._pinWhenIsVisibleCallback);
        }
        unpin() {
          this._pinWhenIsVisibleCallback && (this._stopPinning(), this.stopListening(this, "change:isVisible", this._pinWhenIsVisibleCallback), this._pinWhenIsVisibleCallback = null, this.hide());
        }
        _startPinning(e2) {
          this.attachTo(e2);
          const t2 = jd(e2.target), i2 = e2.limiter ? jd(e2.limiter) : Ld;
          this.listenTo(_r.document, "scroll", (n2, o2) => {
            const r2 = o2.target, s2 = t2 && r2.contains(t2), a2 = i2 && r2.contains(i2);
            !s2 && !a2 && t2 && i2 || this.attachTo(e2);
          }, { useCapture: true }), this.listenTo(_r.window, "resize", () => {
            this.attachTo(e2);
          });
        }
        _stopPinning() {
          this.stopListening(_r.document, "scroll"), this.stopListening(_r.window, "resize");
        }
      }
      function jd(e2) {
        return Yi(e2) ? e2 : ys(e2) ? e2.commonAncestorContainer : typeof e2 == "function" ? jd(e2()) : null;
      }
      function Bd(e2, t2) {
        return e2.top - t2.height - Vd.arrowVerticalOffset;
      }
      function Fd(e2) {
        return e2.bottom + Vd.arrowVerticalOffset;
      }
      Vd.arrowHorizontalOffset = 25, Vd.arrowVerticalOffset = 10, Vd.stickyVerticalOffset = 20, Vd._getOptimalPosition = ld, Vd.defaultPositions = { northWestArrowSouthWest: (e2, t2) => ({ top: Bd(e2, t2), left: e2.left - Vd.arrowHorizontalOffset, name: "arrow_sw" }), northWestArrowSouthMiddleWest: (e2, t2) => ({ top: Bd(e2, t2), left: e2.left - 0.25 * t2.width - Vd.arrowHorizontalOffset, name: "arrow_smw" }), northWestArrowSouth: (e2, t2) => ({ top: Bd(e2, t2), left: e2.left - t2.width / 2, name: "arrow_s" }), northWestArrowSouthMiddleEast: (e2, t2) => ({ top: Bd(e2, t2), left: e2.left - 0.75 * t2.width + Vd.arrowHorizontalOffset, name: "arrow_sme" }), northWestArrowSouthEast: (e2, t2) => ({ top: Bd(e2, t2), left: e2.left - t2.width + Vd.arrowHorizontalOffset, name: "arrow_se" }), northArrowSouthWest: (e2, t2) => ({ top: Bd(e2, t2), left: e2.left + e2.width / 2 - Vd.arrowHorizontalOffset, name: "arrow_sw" }), northArrowSouthMiddleWest: (e2, t2) => ({ top: Bd(e2, t2), left: e2.left + e2.width / 2 - 0.25 * t2.width - Vd.arrowHorizontalOffset, name: "arrow_smw" }), northArrowSouth: (e2, t2) => ({ top: Bd(e2, t2), left: e2.left + e2.width / 2 - t2.width / 2, name: "arrow_s" }), northArrowSouthMiddleEast: (e2, t2) => ({ top: Bd(e2, t2), left: e2.left + e2.width / 2 - 0.75 * t2.width + Vd.arrowHorizontalOffset, name: "arrow_sme" }), northArrowSouthEast: (e2, t2) => ({ top: Bd(e2, t2), left: e2.left + e2.width / 2 - t2.width + Vd.arrowHorizontalOffset, name: "arrow_se" }), northEastArrowSouthWest: (e2, t2) => ({ top: Bd(e2, t2), left: e2.right - Vd.arrowHorizontalOffset, name: "arrow_sw" }), northEastArrowSouthMiddleWest: (e2, t2) => ({ top: Bd(e2, t2), left: e2.right - 0.25 * t2.width - Vd.arrowHorizontalOffset, name: "arrow_smw" }), northEastArrowSouth: (e2, t2) => ({ top: Bd(e2, t2), left: e2.right - t2.width / 2, name: "arrow_s" }), northEastArrowSouthMiddleEast: (e2, t2) => ({ top: Bd(e2, t2), left: e2.right - 0.75 * t2.width + Vd.arrowHorizontalOffset, name: "arrow_sme" }), northEastArrowSouthEast: (e2, t2) => ({ top: Bd(e2, t2), left: e2.right - t2.width + Vd.arrowHorizontalOffset, name: "arrow_se" }), southWestArrowNorthWest: (e2, t2) => ({ top: Fd(e2), left: e2.left - Vd.arrowHorizontalOffset, name: "arrow_nw" }), southWestArrowNorthMiddleWest: (e2, t2) => ({ top: Fd(e2), left: e2.left - 0.25 * t2.width - Vd.arrowHorizontalOffset, name: "arrow_nmw" }), southWestArrowNorth: (e2, t2) => ({ top: Fd(e2), left: e2.left - t2.width / 2, name: "arrow_n" }), southWestArrowNorthMiddleEast: (e2, t2) => ({ top: Fd(e2), left: e2.left - 0.75 * t2.width + Vd.arrowHorizontalOffset, name: "arrow_nme" }), southWestArrowNorthEast: (e2, t2) => ({ top: Fd(e2), left: e2.left - t2.width + Vd.arrowHorizontalOffset, name: "arrow_ne" }), southArrowNorthWest: (e2, t2) => ({ top: Fd(e2), left: e2.left + e2.width / 2 - Vd.arrowHorizontalOffset, name: "arrow_nw" }), southArrowNorthMiddleWest: (e2, t2) => ({ top: Fd(e2), left: e2.left + e2.width / 2 - 0.25 * t2.width - Vd.arrowHorizontalOffset, name: "arrow_nmw" }), southArrowNorth: (e2, t2) => ({ top: Fd(e2), left: e2.left + e2.width / 2 - t2.width / 2, name: "arrow_n" }), southArrowNorthMiddleEast: (e2, t2) => ({ top: Fd(e2), left: e2.left + e2.width / 2 - 0.75 * t2.width + Vd.arrowHorizontalOffset, name: "arrow_nme" }), southArrowNorthEast: (e2, t2) => ({ top: Fd(e2), left: e2.left + e2.width / 2 - t2.width + Vd.arrowHorizontalOffset, name: "arrow_ne" }), southEastArrowNorthWest: (e2, t2) => ({ top: Fd(e2), left: e2.right - Vd.arrowHorizontalOffset, name: "arrow_nw" }), southEastArrowNorthMiddleWest: (e2, t2) => ({ top: Fd(e2), left: e2.right - 0.25 * t2.width - Vd.arrowHorizontalOffset, name: "arrow_nmw" }), southEastArrowNorth: (e2, t2) => ({ top: Fd(e2), left: e2.right - t2.width / 2, name: "arrow_n" }), southEastArrowNorthMiddleEast: (e2, t2) => ({ top: Fd(e2), left: e2.right - 0.75 * t2.width + Vd.arrowHorizontalOffset, name: "arrow_nme" }), southEastArrowNorthEast: (e2, t2) => ({ top: Fd(e2), left: e2.right - t2.width + Vd.arrowHorizontalOffset, name: "arrow_ne" }), viewportStickyNorth: (e2, t2, i2) => e2.getIntersection(i2) ? { top: i2.top + Vd.stickyVerticalOffset, left: e2.left + e2.width / 2 - t2.width / 2, name: "arrowless", config: { withArrow: false } } : null };
      i(51), i(53);
      const Hd = Ps("px");
      class Ud extends Qe {
        static get pluginName() {
          return "ContextualBalloon";
        }
        constructor(e2) {
          super(e2), this.positionLimiter = () => {
            const e3 = this.editor.editing.view, t2 = e3.document.selection.editableElement;
            return t2 ? e3.domConverter.mapViewToDom(t2.root) : null;
          }, this.set("visibleView", null), this.view = new Vd(e2.locale), e2.ui.view.body.add(this.view), e2.ui.focusTracker.add(this.view.element), this._viewToStack = new Map(), this._idToStack = new Map(), this.set("_numberOfStacks", 0), this.set("_singleViewMode", false), this._rotatorView = this._createRotatorView(), this._fakePanelsView = this._createFakePanelsView();
        }
        hasView(e2) {
          return Array.from(this._viewToStack.keys()).includes(e2);
        }
        add(e2) {
          if (this.hasView(e2.view))
            throw new c.a("contextualballoon-add-view-exist", [this, e2]);
          const t2 = e2.stackId || "main";
          if (!this._idToStack.has(t2))
            return this._idToStack.set(t2, new Map([[e2.view, e2]])), this._viewToStack.set(e2.view, this._idToStack.get(t2)), this._numberOfStacks = this._idToStack.size, void (this._visibleStack && !e2.singleViewMode || this.showStack(t2));
          const i2 = this._idToStack.get(t2);
          e2.singleViewMode && this.showStack(t2), i2.set(e2.view, e2), this._viewToStack.set(e2.view, i2), i2 === this._visibleStack && this._showView(e2);
        }
        remove(e2) {
          if (!this.hasView(e2))
            throw new c.a("contextualballoon-remove-view-not-exist", [this, e2]);
          const t2 = this._viewToStack.get(e2);
          this._singleViewMode && this.visibleView === e2 && (this._singleViewMode = false), this.visibleView === e2 && (t2.size === 1 ? this._idToStack.size > 1 ? this._showNextStack() : (this.view.hide(), this.visibleView = null, this._rotatorView.hideView()) : this._showView(Array.from(t2.values())[t2.size - 2])), t2.size === 1 ? (this._idToStack.delete(this._getStackId(t2)), this._numberOfStacks = this._idToStack.size) : t2.delete(e2), this._viewToStack.delete(e2);
        }
        updatePosition(e2) {
          e2 && (this._visibleStack.get(this.visibleView).position = e2), this.view.pin(this._getBalloonPosition()), this._fakePanelsView.updatePosition();
        }
        showStack(e2) {
          this.visibleStack = e2;
          const t2 = this._idToStack.get(e2);
          if (!t2)
            throw new c.a("contextualballoon-showstack-stack-not-exist", this);
          this._visibleStack !== t2 && this._showView(Array.from(t2.values()).pop());
        }
        get _visibleStack() {
          return this._viewToStack.get(this.visibleView);
        }
        _getStackId(e2) {
          return Array.from(this._idToStack.entries()).find((t2) => t2[1] === e2)[0];
        }
        _showNextStack() {
          const e2 = Array.from(this._idToStack.values());
          let t2 = e2.indexOf(this._visibleStack) + 1;
          e2[t2] || (t2 = 0), this.showStack(this._getStackId(e2[t2]));
        }
        _showPrevStack() {
          const e2 = Array.from(this._idToStack.values());
          let t2 = e2.indexOf(this._visibleStack) - 1;
          e2[t2] || (t2 = e2.length - 1), this.showStack(this._getStackId(e2[t2]));
        }
        _createRotatorView() {
          const e2 = new Wd(this.editor.locale), t2 = this.editor.locale.t;
          return this.view.content.add(e2), e2.bind("isNavigationVisible").to(this, "_numberOfStacks", this, "_singleViewMode", (e3, t3) => !t3 && e3 > 1), e2.on("change:isNavigationVisible", () => this.updatePosition(), { priority: "low" }), e2.bind("counter").to(this, "visibleView", this, "_numberOfStacks", (e3, i2) => {
            if (i2 < 2)
              return "";
            const n2 = Array.from(this._idToStack.values()).indexOf(this._visibleStack) + 1;
            return t2("%0 of %1", [n2, i2]);
          }), e2.buttonNextView.on("execute", () => {
            e2.focusTracker.isFocused && this.editor.editing.view.focus(), this._showNextStack();
          }), e2.buttonPrevView.on("execute", () => {
            e2.focusTracker.isFocused && this.editor.editing.view.focus(), this._showPrevStack();
          }), e2;
        }
        _createFakePanelsView() {
          const e2 = new qd(this.editor.locale, this.view);
          return e2.bind("numberOfPanels").to(this, "_numberOfStacks", this, "_singleViewMode", (e3, t2) => !t2 && e3 >= 2 ? Math.min(e3 - 1, 2) : 0), e2.listenTo(this.view, "change:top", () => e2.updatePosition()), e2.listenTo(this.view, "change:left", () => e2.updatePosition()), this.editor.ui.view.body.add(e2), e2;
        }
        _showView({ view: e2, balloonClassName: t2 = "", withArrow: i2 = true, singleViewMode: n2 = false }) {
          this.view.class = t2, this.view.withArrow = i2, this._rotatorView.showView(e2), this.visibleView = e2, this.view.pin(this._getBalloonPosition()), this._fakePanelsView.updatePosition(), n2 && (this._singleViewMode = true);
        }
        _getBalloonPosition() {
          let e2 = Array.from(this._visibleStack.values()).pop().position;
          return e2 && (e2.limiter || (e2 = Object.assign({}, e2, { limiter: this.positionLimiter })), e2 = Object.assign({}, e2, { viewportOffsetConfig: this.editor.config.get("ui.viewportOffset") })), e2;
        }
      }
      class Wd extends Nl {
        constructor(e2) {
          super(e2);
          const t2 = e2.t, i2 = this.bindTemplate;
          this.set("isNavigationVisible", true), this.focusTracker = new Ns(), this.buttonPrevView = this._createButtonView(t2("Previous"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.463 5.187a.888.888 0 1 1 1.254 1.255L9.16 10l3.557 3.557a.888.888 0 1 1-1.254 1.255L7.26 10.61a.888.888 0 0 1 .16-1.382l4.043-4.042z"/></svg>'), this.buttonNextView = this._createButtonView(t2("Next"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.537 14.813a.888.888 0 1 1-1.254-1.255L10.84 10 7.283 6.442a.888.888 0 1 1 1.254-1.255L12.74 9.39a.888.888 0 0 1-.16 1.382l-4.043 4.042z"/></svg>'), this.content = this.createCollection(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-balloon-rotator"], "z-index": "-1" }, children: [{ tag: "div", attributes: { class: ["ck-balloon-rotator__navigation", i2.to("isNavigationVisible", (e3) => e3 ? "" : "ck-hidden")] }, children: [this.buttonPrevView, { tag: "span", attributes: { class: ["ck-balloon-rotator__counter"] }, children: [{ text: i2.to("counter") }] }, this.buttonNextView] }, { tag: "div", attributes: { class: "ck-balloon-rotator__content" }, children: this.content }] });
        }
        render() {
          super.render(), this.focusTracker.add(this.element);
        }
        showView(e2) {
          this.hideView(), this.content.add(e2);
        }
        hideView() {
          this.content.clear();
        }
        _createButtonView(e2, t2) {
          const i2 = new td(this.locale);
          return i2.set({ label: e2, icon: t2, tooltip: true }), i2;
        }
      }
      class qd extends Nl {
        constructor(e2, t2) {
          super(e2);
          const i2 = this.bindTemplate;
          this.set("top", 0), this.set("left", 0), this.set("height", 0), this.set("width", 0), this.set("numberOfPanels", 0), this.content = this.createCollection(), this._balloonPanelView = t2, this.setTemplate({ tag: "div", attributes: { class: ["ck-fake-panel", i2.to("numberOfPanels", (e3) => e3 ? "" : "ck-hidden")], style: { top: i2.to("top", Hd), left: i2.to("left", Hd), width: i2.to("width", Hd), height: i2.to("height", Hd) } }, children: this.content }), this.on("change:numberOfPanels", (e3, t3, i3, n2) => {
            i3 > n2 ? this._addPanels(i3 - n2) : this._removePanels(n2 - i3), this.updatePosition();
          });
        }
        _addPanels(e2) {
          for (; e2--; ) {
            const e3 = new Nl();
            e3.setTemplate({ tag: "div" }), this.content.add(e3), this.registerChild(e3);
          }
        }
        _removePanels(e2) {
          for (; e2--; ) {
            const e3 = this.content.last;
            this.content.remove(e3), this.deregisterChild(e3), e3.destroy();
          }
        }
        updatePosition() {
          if (this.numberOfPanels) {
            const { top: e2, left: t2 } = this._balloonPanelView, { width: i2, height: n2 } = new Cs(this._balloonPanelView.element);
            Object.assign(this, { top: e2, left: t2, width: i2, height: n2 });
          }
        }
      }
      i(55);
      const $d = Ps("px");
      class Yd extends Nl {
        constructor(e2) {
          super(e2);
          const t2 = this.bindTemplate;
          this.set("isActive", false), this.set("isSticky", false), this.set("limiterElement", null), this.set("limiterBottomOffset", 50), this.set("viewportTopOffset", 0), this.set("_marginLeft", null), this.set("_isStickyToTheLimiter", false), this.set("_hasViewportTopOffset", false), this.content = this.createCollection(), this._contentPanelPlaceholder = new Rl({ tag: "div", attributes: { class: ["ck", "ck-sticky-panel__placeholder"], style: { display: t2.to("isSticky", (e3) => e3 ? "block" : "none"), height: t2.to("isSticky", (e3) => e3 ? $d(this._panelRect.height) : null) } } }).render(), this._contentPanel = new Rl({ tag: "div", attributes: { class: ["ck", "ck-sticky-panel__content", t2.if("isSticky", "ck-sticky-panel__content_sticky"), t2.if("_isStickyToTheLimiter", "ck-sticky-panel__content_sticky_bottom-limit")], style: { width: t2.to("isSticky", (e3) => e3 ? $d(this._contentPanelPlaceholder.getBoundingClientRect().width) : null), top: t2.to("_hasViewportTopOffset", (e3) => e3 ? $d(this.viewportTopOffset) : null), bottom: t2.to("_isStickyToTheLimiter", (e3) => e3 ? $d(this.limiterBottomOffset) : null), marginLeft: t2.to("_marginLeft") } }, children: this.content }).render(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-sticky-panel"] }, children: [this._contentPanelPlaceholder, this._contentPanel] });
        }
        render() {
          super.render(), this._checkIfShouldBeSticky(), this.listenTo(_r.window, "scroll", () => {
            this._checkIfShouldBeSticky();
          }), this.listenTo(this, "change:isActive", () => {
            this._checkIfShouldBeSticky();
          });
        }
        _checkIfShouldBeSticky() {
          const e2 = this._panelRect = this._contentPanel.getBoundingClientRect();
          let t2;
          this.limiterElement ? (t2 = this._limiterRect = this.limiterElement.getBoundingClientRect(), this.isSticky = this.isActive && t2.top < this.viewportTopOffset && this._panelRect.height + this.limiterBottomOffset < t2.height) : this.isSticky = false, this.isSticky ? (this._isStickyToTheLimiter = t2.bottom < e2.height + this.limiterBottomOffset + this.viewportTopOffset, this._hasViewportTopOffset = !this._isStickyToTheLimiter && !!this.viewportTopOffset, this._marginLeft = this._isStickyToTheLimiter ? null : $d(-_r.window.scrollX)) : (this._isStickyToTheLimiter = false, this._hasViewportTopOffset = false, this._marginLeft = null);
        }
      }
      i(57);
      i(59);
      const Gd = new WeakMap();
      function Kd(e2) {
        const { view: t2, element: i2, text: n2, isDirectHost: o2 = true, keepOnFocus: r2 = false } = e2, s2 = t2.document;
        Gd.has(s2) || (Gd.set(s2, new Map()), s2.registerPostFixer((e3) => Jd(s2, e3))), Gd.get(s2).set(i2, { text: n2, isDirectHost: o2, keepOnFocus: r2, hostElement: o2 ? i2 : null }), t2.change((e3) => Jd(s2, e3));
      }
      function Qd(e2, t2) {
        return !!t2.hasClass("ck-placeholder") && (e2.removeClass("ck-placeholder", t2), true);
      }
      function Jd(e2, t2) {
        const i2 = Gd.get(e2), n2 = [];
        let o2 = false;
        for (const [e3, r2] of i2)
          r2.isDirectHost && (n2.push(e3), Zd(t2, e3, r2) && (o2 = true));
        for (const [e3, r2] of i2) {
          if (r2.isDirectHost)
            continue;
          const i3 = Xd(e3);
          i3 && (n2.includes(i3) || (r2.hostElement = i3, Zd(t2, e3, r2) && (o2 = true)));
        }
        return o2;
      }
      function Zd(e2, t2, i2) {
        const { text: n2, isDirectHost: o2, hostElement: r2 } = i2;
        let s2 = false;
        r2.getAttribute("data-placeholder") !== n2 && (e2.setAttribute("data-placeholder", n2, r2), s2 = true);
        return (o2 || t2.childCount == 1) && function(e3, t3) {
          if (!e3.isAttached())
            return false;
          if (Array.from(e3.getChildren()).some((e4) => !e4.is("uiElement")))
            return false;
          if (t3)
            return true;
          const i3 = e3.document;
          if (!i3.isFocused)
            return true;
          const n3 = i3.selection.anchor;
          return n3 && n3.parent !== e3;
        }(r2, i2.keepOnFocus) ? function(e3, t3) {
          return !t3.hasClass("ck-placeholder") && (e3.addClass("ck-placeholder", t3), true);
        }(e2, r2) && (s2 = true) : Qd(e2, r2) && (s2 = true), s2;
      }
      function Xd(e2) {
        if (e2.childCount) {
          const t2 = e2.getChild(0);
          if (t2.is("element") && !t2.is("uiElement"))
            return t2;
        }
        return null;
      }
      const eh = new Map();
      function th(e2, t2, i2) {
        let n2 = eh.get(e2);
        n2 || (n2 = new Map(), eh.set(e2, n2)), n2.set(t2, i2);
      }
      function ih(e2) {
        return [e2];
      }
      function nh(e2, t2, i2 = {}) {
        const n2 = function(e3, t3) {
          const i3 = eh.get(e3);
          return i3 && i3.has(t3) ? i3.get(t3) : ih;
        }(e2.constructor, t2.constructor);
        try {
          return n2(e2 = e2.clone(), t2, i2);
        } catch (e3) {
          throw e3;
        }
      }
      function oh(e2, t2, i2) {
        e2 = e2.slice(), t2 = t2.slice();
        const n2 = new rh(i2.document, i2.useRelations, i2.forceWeakRemove);
        n2.setOriginalOperations(e2), n2.setOriginalOperations(t2);
        const o2 = n2.originalOperations;
        if (e2.length == 0 || t2.length == 0)
          return { operationsA: e2, operationsB: t2, originalOperations: o2 };
        const r2 = new WeakMap();
        for (const t3 of e2)
          r2.set(t3, 0);
        const s2 = { nextBaseVersionA: e2[e2.length - 1].baseVersion + 1, nextBaseVersionB: t2[t2.length - 1].baseVersion + 1, originalOperationsACount: e2.length, originalOperationsBCount: t2.length };
        let a2 = 0;
        for (; a2 < e2.length; ) {
          const i3 = e2[a2], o3 = r2.get(i3);
          if (o3 == t2.length) {
            a2++;
            continue;
          }
          const s3 = t2[o3], c2 = nh(i3, s3, n2.getContext(i3, s3, true)), l2 = nh(s3, i3, n2.getContext(s3, i3, false));
          n2.updateRelation(i3, s3), n2.setOriginalOperations(c2, i3), n2.setOriginalOperations(l2, s3);
          for (const e3 of c2)
            r2.set(e3, o3 + l2.length);
          e2.splice(a2, 1, ...c2), t2.splice(o3, 1, ...l2);
        }
        if (i2.padWithNoOps) {
          const i3 = e2.length - s2.originalOperationsACount, n3 = t2.length - s2.originalOperationsBCount;
          ah(e2, n3 - i3), ah(t2, i3 - n3);
        }
        return sh(e2, s2.nextBaseVersionB), sh(t2, s2.nextBaseVersionA), { operationsA: e2, operationsB: t2, originalOperations: o2 };
      }
      class rh {
        constructor(e2, t2, i2 = false) {
          this.originalOperations = new Map(), this._history = e2.history, this._useRelations = t2, this._forceWeakRemove = !!i2, this._relations = new Map();
        }
        setOriginalOperations(e2, t2 = null) {
          const i2 = t2 ? this.originalOperations.get(t2) : null;
          for (const t3 of e2)
            this.originalOperations.set(t3, i2 || t3);
        }
        updateRelation(e2, t2) {
          switch (e2.constructor) {
            case Tc:
              switch (t2.constructor) {
                case Mc:
                  e2.targetPosition.isEqual(t2.sourcePosition) || t2.movedRange.containsPosition(e2.targetPosition) ? this._setRelation(e2, t2, "insertAtSource") : e2.targetPosition.isEqual(t2.deletionPosition) ? this._setRelation(e2, t2, "insertBetween") : e2.targetPosition.isAfter(t2.sourcePosition) && this._setRelation(e2, t2, "moveTargetAfter");
                  break;
                case Tc:
                  e2.targetPosition.isEqual(t2.sourcePosition) || e2.targetPosition.isBefore(t2.sourcePosition) ? this._setRelation(e2, t2, "insertBefore") : this._setRelation(e2, t2, "insertAfter");
              }
              break;
            case Nc:
              switch (t2.constructor) {
                case Mc:
                  e2.splitPosition.isBefore(t2.sourcePosition) && this._setRelation(e2, t2, "splitBefore");
                  break;
                case Tc:
                  if (e2.splitPosition.isEqual(t2.sourcePosition) || e2.splitPosition.isBefore(t2.sourcePosition))
                    this._setRelation(e2, t2, "splitBefore");
                  else {
                    const i2 = na._createFromPositionAndShift(t2.sourcePosition, t2.howMany);
                    if (e2.splitPosition.hasSameParentAs(t2.sourcePosition) && i2.containsPosition(e2.splitPosition)) {
                      const n2 = i2.end.offset - e2.splitPosition.offset, o2 = e2.splitPosition.offset - i2.start.offset;
                      this._setRelation(e2, t2, { howMany: n2, offset: o2 });
                    }
                  }
              }
              break;
            case Mc:
              switch (t2.constructor) {
                case Mc:
                  e2.targetPosition.isEqual(t2.sourcePosition) || this._setRelation(e2, t2, "mergeTargetNotMoved"), e2.sourcePosition.isEqual(t2.targetPosition) && this._setRelation(e2, t2, "mergeSourceNotMoved"), e2.sourcePosition.isEqual(t2.sourcePosition) && this._setRelation(e2, t2, "mergeSameElement");
                  break;
                case Nc:
                  e2.sourcePosition.isEqual(t2.splitPosition) && this._setRelation(e2, t2, "splitAtSource");
              }
              break;
            case Ic: {
              const i2 = e2.newRange;
              if (!i2)
                return;
              switch (t2.constructor) {
                case Tc: {
                  const n2 = na._createFromPositionAndShift(t2.sourcePosition, t2.howMany), o2 = n2.containsPosition(i2.start) || n2.start.isEqual(i2.start), r2 = n2.containsPosition(i2.end) || n2.end.isEqual(i2.end);
                  !o2 && !r2 || n2.containsRange(i2) || this._setRelation(e2, t2, { side: o2 ? "left" : "right", path: o2 ? i2.start.path.slice() : i2.end.path.slice() });
                  break;
                }
                case Mc: {
                  const n2 = i2.start.isEqual(t2.targetPosition), o2 = i2.start.isEqual(t2.deletionPosition), r2 = i2.end.isEqual(t2.deletionPosition), s2 = i2.end.isEqual(t2.sourcePosition);
                  (n2 || o2 || r2 || s2) && this._setRelation(e2, t2, { wasInLeftElement: n2, wasStartBeforeMergedElement: o2, wasEndBeforeMergedElement: r2, wasInRightElement: s2 });
                  break;
                }
              }
              break;
            }
          }
        }
        getContext(e2, t2, i2) {
          return { aIsStrong: i2, aWasUndone: this._wasUndone(e2), bWasUndone: this._wasUndone(t2), abRelation: this._useRelations ? this._getRelation(e2, t2) : null, baRelation: this._useRelations ? this._getRelation(t2, e2) : null, forceWeakRemove: this._forceWeakRemove };
        }
        _wasUndone(e2) {
          const t2 = this.originalOperations.get(e2);
          return t2.wasUndone || this._history.isUndoneOperation(t2);
        }
        _getRelation(e2, t2) {
          const i2 = this.originalOperations.get(t2), n2 = this._history.getUndoneOperation(i2);
          if (!n2)
            return null;
          const o2 = this.originalOperations.get(e2), r2 = this._relations.get(o2);
          return r2 && r2.get(n2) || null;
        }
        _setRelation(e2, t2, i2) {
          const n2 = this.originalOperations.get(e2), o2 = this.originalOperations.get(t2);
          let r2 = this._relations.get(n2);
          r2 || (r2 = new Map(), this._relations.set(n2, r2)), r2.set(o2, i2);
        }
      }
      function sh(e2, t2) {
        for (const i2 of e2)
          i2.baseVersion = t2++;
      }
      function ah(e2, t2) {
        for (let i2 = 0; i2 < t2; i2++)
          e2.push(new Jc(0));
      }
      function ch(e2, t2, i2) {
        const n2 = e2.nodes.getNode(0).getAttribute(t2);
        if (n2 == i2)
          return null;
        const o2 = new na(e2.position, e2.position.getShiftedBy(e2.howMany));
        return new Ac(o2, t2, n2, i2, 0);
      }
      function lh(e2, t2) {
        return e2.targetPosition._getTransformedByDeletion(t2.sourcePosition, t2.howMany) === null;
      }
      function dh(e2, t2) {
        const i2 = [];
        for (let n2 = 0; n2 < e2.length; n2++) {
          const o2 = e2[n2], r2 = new Tc(o2.start, o2.end.offset - o2.start.offset, t2, 0);
          i2.push(r2);
          for (let t3 = n2 + 1; t3 < e2.length; t3++)
            e2[t3] = e2[t3]._getTransformedByMove(r2.sourcePosition, r2.targetPosition, r2.howMany)[0];
          t2 = t2._getTransformedByMove(r2.sourcePosition, r2.targetPosition, r2.howMany);
        }
        return i2;
      }
      th(Ac, Ac, (e2, t2, i2) => {
        if (e2.key === t2.key && e2.range.start.hasSameParentAs(t2.range.start)) {
          const n2 = e2.range.getDifference(t2.range).map((t3) => new Ac(t3, e2.key, e2.oldValue, e2.newValue, 0)), o2 = e2.range.getIntersection(t2.range);
          return o2 && i2.aIsStrong && n2.push(new Ac(o2, t2.key, t2.newValue, e2.newValue, 0)), n2.length == 0 ? [new Jc(0)] : n2;
        }
        return [e2];
      }), th(Ac, Ec, (e2, t2) => {
        if (e2.range.start.hasSameParentAs(t2.position) && e2.range.containsPosition(t2.position)) {
          const i2 = e2.range._getTransformedByInsertion(t2.position, t2.howMany, !t2.shouldReceiveAttributes).map((t3) => new Ac(t3, e2.key, e2.oldValue, e2.newValue, e2.baseVersion));
          if (t2.shouldReceiveAttributes) {
            const n2 = ch(t2, e2.key, e2.oldValue);
            n2 && i2.unshift(n2);
          }
          return i2;
        }
        return e2.range = e2.range._getTransformedByInsertion(t2.position, t2.howMany, false)[0], [e2];
      }), th(Ac, Mc, (e2, t2) => {
        const i2 = [];
        e2.range.start.hasSameParentAs(t2.deletionPosition) && (e2.range.containsPosition(t2.deletionPosition) || e2.range.start.isEqual(t2.deletionPosition)) && i2.push(na._createFromPositionAndShift(t2.graveyardPosition, 1));
        const n2 = e2.range._getTransformedByMergeOperation(t2);
        return n2.isCollapsed || i2.push(n2), i2.map((t3) => new Ac(t3, e2.key, e2.oldValue, e2.newValue, e2.baseVersion));
      }), th(Ac, Tc, (e2, t2) => function(e3, t3) {
        const i2 = na._createFromPositionAndShift(t3.sourcePosition, t3.howMany);
        let n2 = null, o2 = [];
        i2.containsRange(e3, true) ? n2 = e3 : e3.start.hasSameParentAs(i2.start) ? (o2 = e3.getDifference(i2), n2 = e3.getIntersection(i2)) : o2 = [e3];
        const r2 = [];
        for (let e4 of o2) {
          e4 = e4._getTransformedByDeletion(t3.sourcePosition, t3.howMany);
          const i3 = t3.getMovedRangeStart(), n3 = e4.start.hasSameParentAs(i3);
          e4 = e4._getTransformedByInsertion(i3, t3.howMany, n3), r2.push(...e4);
        }
        n2 && r2.push(n2._getTransformedByMove(t3.sourcePosition, t3.targetPosition, t3.howMany, false)[0]);
        return r2;
      }(e2.range, t2).map((t3) => new Ac(t3, e2.key, e2.oldValue, e2.newValue, e2.baseVersion))), th(Ac, Nc, (e2, t2) => {
        if (e2.range.end.isEqual(t2.insertionPosition))
          return t2.graveyardPosition || e2.range.end.offset++, [e2];
        if (e2.range.start.hasSameParentAs(t2.splitPosition) && e2.range.containsPosition(t2.splitPosition)) {
          const i2 = e2.clone();
          return i2.range = new na(t2.moveTargetPosition.clone(), e2.range.end._getCombined(t2.splitPosition, t2.moveTargetPosition)), e2.range.end = t2.splitPosition.clone(), e2.range.end.stickiness = "toPrevious", [e2, i2];
        }
        return e2.range = e2.range._getTransformedBySplitOperation(t2), [e2];
      }), th(Ec, Ac, (e2, t2) => {
        const i2 = [e2];
        if (e2.shouldReceiveAttributes && e2.position.hasSameParentAs(t2.range.start) && t2.range.containsPosition(e2.position)) {
          const n2 = ch(e2, t2.key, t2.newValue);
          n2 && i2.push(n2);
        }
        return i2;
      }), th(Ec, Ec, (e2, t2, i2) => (e2.position.isEqual(t2.position) && i2.aIsStrong || (e2.position = e2.position._getTransformedByInsertOperation(t2)), [e2])), th(Ec, Tc, (e2, t2) => (e2.position = e2.position._getTransformedByMoveOperation(t2), [e2])), th(Ec, Nc, (e2, t2) => (e2.position = e2.position._getTransformedBySplitOperation(t2), [e2])), th(Ec, Mc, (e2, t2) => (e2.position = e2.position._getTransformedByMergeOperation(t2), [e2])), th(Ic, Ec, (e2, t2) => (e2.oldRange && (e2.oldRange = e2.oldRange._getTransformedByInsertOperation(t2)[0]), e2.newRange && (e2.newRange = e2.newRange._getTransformedByInsertOperation(t2)[0]), [e2])), th(Ic, Ic, (e2, t2, i2) => {
        if (e2.name == t2.name) {
          if (!i2.aIsStrong)
            return [new Jc(0)];
          e2.oldRange = t2.newRange ? t2.newRange.clone() : null;
        }
        return [e2];
      }), th(Ic, Mc, (e2, t2) => (e2.oldRange && (e2.oldRange = e2.oldRange._getTransformedByMergeOperation(t2)), e2.newRange && (e2.newRange = e2.newRange._getTransformedByMergeOperation(t2)), [e2])), th(Ic, Tc, (e2, t2, i2) => {
        if (e2.oldRange && (e2.oldRange = na._createFromRanges(e2.oldRange._getTransformedByMoveOperation(t2))), e2.newRange) {
          if (i2.abRelation) {
            const n2 = na._createFromRanges(e2.newRange._getTransformedByMoveOperation(t2));
            if (i2.abRelation.side == "left" && t2.targetPosition.isEqual(e2.newRange.start))
              return e2.newRange.start.path = i2.abRelation.path, e2.newRange.end = n2.end, [e2];
            if (i2.abRelation.side == "right" && t2.targetPosition.isEqual(e2.newRange.end))
              return e2.newRange.start = n2.start, e2.newRange.end.path = i2.abRelation.path, [e2];
          }
          e2.newRange = na._createFromRanges(e2.newRange._getTransformedByMoveOperation(t2));
        }
        return [e2];
      }), th(Ic, Nc, (e2, t2, i2) => {
        if (e2.oldRange && (e2.oldRange = e2.oldRange._getTransformedBySplitOperation(t2)), e2.newRange) {
          if (i2.abRelation) {
            const n2 = e2.newRange._getTransformedBySplitOperation(t2);
            return e2.newRange.start.isEqual(t2.splitPosition) && i2.abRelation.wasStartBeforeMergedElement ? e2.newRange.start = Xs._createAt(t2.insertionPosition) : e2.newRange.start.isEqual(t2.splitPosition) && !i2.abRelation.wasInLeftElement && (e2.newRange.start = Xs._createAt(t2.moveTargetPosition)), e2.newRange.end.isEqual(t2.splitPosition) && i2.abRelation.wasInRightElement ? e2.newRange.end = Xs._createAt(t2.moveTargetPosition) : e2.newRange.end.isEqual(t2.splitPosition) && i2.abRelation.wasEndBeforeMergedElement ? e2.newRange.end = Xs._createAt(t2.insertionPosition) : e2.newRange.end = n2.end, [e2];
          }
          e2.newRange = e2.newRange._getTransformedBySplitOperation(t2);
        }
        return [e2];
      }), th(Mc, Ec, (e2, t2) => (e2.sourcePosition.hasSameParentAs(t2.position) && (e2.howMany += t2.howMany), e2.sourcePosition = e2.sourcePosition._getTransformedByInsertOperation(t2), e2.targetPosition = e2.targetPosition._getTransformedByInsertOperation(t2), [e2])), th(Mc, Mc, (e2, t2, i2) => {
        if (e2.sourcePosition.isEqual(t2.sourcePosition) && e2.targetPosition.isEqual(t2.targetPosition)) {
          if (i2.bWasUndone) {
            const i3 = t2.graveyardPosition.path.slice();
            return i3.push(0), e2.sourcePosition = new Xs(t2.graveyardPosition.root, i3), e2.howMany = 0, [e2];
          }
          return [new Jc(0)];
        }
        if (e2.sourcePosition.isEqual(t2.sourcePosition) && !e2.targetPosition.isEqual(t2.targetPosition) && !i2.bWasUndone && i2.abRelation != "splitAtSource") {
          const n2 = e2.targetPosition.root.rootName == "$graveyard", o2 = t2.targetPosition.root.rootName == "$graveyard", r2 = n2 && !o2;
          if (o2 && !n2 || !r2 && i2.aIsStrong) {
            const i3 = t2.targetPosition._getTransformedByMergeOperation(t2), n3 = e2.targetPosition._getTransformedByMergeOperation(t2);
            return [new Tc(i3, e2.howMany, n3, 0)];
          }
          return [new Jc(0)];
        }
        return e2.sourcePosition.hasSameParentAs(t2.targetPosition) && (e2.howMany += t2.howMany), e2.sourcePosition = e2.sourcePosition._getTransformedByMergeOperation(t2), e2.targetPosition = e2.targetPosition._getTransformedByMergeOperation(t2), e2.graveyardPosition.isEqual(t2.graveyardPosition) && i2.aIsStrong || (e2.graveyardPosition = e2.graveyardPosition._getTransformedByMergeOperation(t2)), [e2];
      }), th(Mc, Tc, (e2, t2, i2) => {
        const n2 = na._createFromPositionAndShift(t2.sourcePosition, t2.howMany);
        return t2.type == "remove" && !i2.bWasUndone && !i2.forceWeakRemove && e2.deletionPosition.hasSameParentAs(t2.sourcePosition) && n2.containsPosition(e2.sourcePosition) ? [new Jc(0)] : (e2.sourcePosition.hasSameParentAs(t2.targetPosition) && (e2.howMany += t2.howMany), e2.sourcePosition.hasSameParentAs(t2.sourcePosition) && (e2.howMany -= t2.howMany), e2.sourcePosition = e2.sourcePosition._getTransformedByMoveOperation(t2), e2.targetPosition = e2.targetPosition._getTransformedByMoveOperation(t2), e2.graveyardPosition.isEqual(t2.targetPosition) || (e2.graveyardPosition = e2.graveyardPosition._getTransformedByMoveOperation(t2)), [e2]);
      }), th(Mc, Nc, (e2, t2, i2) => {
        if (t2.graveyardPosition && (e2.graveyardPosition = e2.graveyardPosition._getTransformedByDeletion(t2.graveyardPosition, 1), e2.deletionPosition.isEqual(t2.graveyardPosition) && (e2.howMany = t2.howMany)), e2.targetPosition.isEqual(t2.splitPosition)) {
          const n2 = t2.howMany != 0, o2 = t2.graveyardPosition && e2.deletionPosition.isEqual(t2.graveyardPosition);
          if (n2 || o2 || i2.abRelation == "mergeTargetNotMoved")
            return e2.sourcePosition = e2.sourcePosition._getTransformedBySplitOperation(t2), [e2];
        }
        if (e2.sourcePosition.isEqual(t2.splitPosition)) {
          if (i2.abRelation == "mergeSourceNotMoved")
            return e2.howMany = 0, e2.targetPosition = e2.targetPosition._getTransformedBySplitOperation(t2), [e2];
          if (i2.abRelation == "mergeSameElement" || e2.sourcePosition.offset > 0)
            return e2.sourcePosition = t2.moveTargetPosition.clone(), e2.targetPosition = e2.targetPosition._getTransformedBySplitOperation(t2), [e2];
        }
        return e2.sourcePosition.hasSameParentAs(t2.splitPosition) && (e2.howMany = t2.splitPosition.offset), e2.sourcePosition = e2.sourcePosition._getTransformedBySplitOperation(t2), e2.targetPosition = e2.targetPosition._getTransformedBySplitOperation(t2), [e2];
      }), th(Tc, Ec, (e2, t2) => {
        const i2 = na._createFromPositionAndShift(e2.sourcePosition, e2.howMany)._getTransformedByInsertOperation(t2, false)[0];
        return e2.sourcePosition = i2.start, e2.howMany = i2.end.offset - i2.start.offset, e2.targetPosition.isEqual(t2.position) || (e2.targetPosition = e2.targetPosition._getTransformedByInsertOperation(t2)), [e2];
      }), th(Tc, Tc, (e2, t2, i2) => {
        const n2 = na._createFromPositionAndShift(e2.sourcePosition, e2.howMany), o2 = na._createFromPositionAndShift(t2.sourcePosition, t2.howMany);
        let r2, s2 = i2.aIsStrong, a2 = !i2.aIsStrong;
        if (i2.abRelation == "insertBefore" || i2.baRelation == "insertAfter" ? a2 = true : i2.abRelation != "insertAfter" && i2.baRelation != "insertBefore" || (a2 = false), r2 = e2.targetPosition.isEqual(t2.targetPosition) && a2 ? e2.targetPosition._getTransformedByDeletion(t2.sourcePosition, t2.howMany) : e2.targetPosition._getTransformedByMove(t2.sourcePosition, t2.targetPosition, t2.howMany), lh(e2, t2) && lh(t2, e2))
          return [t2.getReversed()];
        if (n2.containsPosition(t2.targetPosition) && n2.containsRange(o2, true))
          return n2.start = n2.start._getTransformedByMove(t2.sourcePosition, t2.targetPosition, t2.howMany), n2.end = n2.end._getTransformedByMove(t2.sourcePosition, t2.targetPosition, t2.howMany), dh([n2], r2);
        if (o2.containsPosition(e2.targetPosition) && o2.containsRange(n2, true))
          return n2.start = n2.start._getCombined(t2.sourcePosition, t2.getMovedRangeStart()), n2.end = n2.end._getCombined(t2.sourcePosition, t2.getMovedRangeStart()), dh([n2], r2);
        const c2 = cn(e2.sourcePosition.getParentPath(), t2.sourcePosition.getParentPath());
        if (c2 == "prefix" || c2 == "extension")
          return n2.start = n2.start._getTransformedByMove(t2.sourcePosition, t2.targetPosition, t2.howMany), n2.end = n2.end._getTransformedByMove(t2.sourcePosition, t2.targetPosition, t2.howMany), dh([n2], r2);
        e2.type != "remove" || t2.type == "remove" || i2.aWasUndone || i2.forceWeakRemove ? e2.type == "remove" || t2.type != "remove" || i2.bWasUndone || i2.forceWeakRemove || (s2 = false) : s2 = true;
        const l2 = [], d2 = n2.getDifference(o2);
        for (const e3 of d2) {
          e3.start = e3.start._getTransformedByDeletion(t2.sourcePosition, t2.howMany), e3.end = e3.end._getTransformedByDeletion(t2.sourcePosition, t2.howMany);
          const i3 = cn(e3.start.getParentPath(), t2.getMovedRangeStart().getParentPath()) == "same", n3 = e3._getTransformedByInsertion(t2.getMovedRangeStart(), t2.howMany, i3);
          l2.push(...n3);
        }
        const h2 = n2.getIntersection(o2);
        return h2 !== null && s2 && (h2.start = h2.start._getCombined(t2.sourcePosition, t2.getMovedRangeStart()), h2.end = h2.end._getCombined(t2.sourcePosition, t2.getMovedRangeStart()), l2.length === 0 ? l2.push(h2) : l2.length == 1 ? o2.start.isBefore(n2.start) || o2.start.isEqual(n2.start) ? l2.unshift(h2) : l2.push(h2) : l2.splice(1, 0, h2)), l2.length === 0 ? [new Jc(e2.baseVersion)] : dh(l2, r2);
      }), th(Tc, Nc, (e2, t2, i2) => {
        let n2 = e2.targetPosition.clone();
        e2.targetPosition.isEqual(t2.insertionPosition) && t2.graveyardPosition && i2.abRelation != "moveTargetAfter" || (n2 = e2.targetPosition._getTransformedBySplitOperation(t2));
        const o2 = na._createFromPositionAndShift(e2.sourcePosition, e2.howMany);
        if (o2.end.isEqual(t2.insertionPosition))
          return t2.graveyardPosition || e2.howMany++, e2.targetPosition = n2, [e2];
        if (o2.start.hasSameParentAs(t2.splitPosition) && o2.containsPosition(t2.splitPosition)) {
          let e3 = new na(t2.splitPosition, o2.end);
          e3 = e3._getTransformedBySplitOperation(t2);
          return dh([new na(o2.start, t2.splitPosition), e3], n2);
        }
        e2.targetPosition.isEqual(t2.splitPosition) && i2.abRelation == "insertAtSource" && (n2 = t2.moveTargetPosition), e2.targetPosition.isEqual(t2.insertionPosition) && i2.abRelation == "insertBetween" && (n2 = e2.targetPosition);
        const r2 = [o2._getTransformedBySplitOperation(t2)];
        if (t2.graveyardPosition) {
          const n3 = o2.start.isEqual(t2.graveyardPosition) || o2.containsPosition(t2.graveyardPosition);
          e2.howMany > 1 && n3 && !i2.aWasUndone && r2.push(na._createFromPositionAndShift(t2.insertionPosition, 1));
        }
        return dh(r2, n2);
      }), th(Tc, Mc, (e2, t2, i2) => {
        const n2 = na._createFromPositionAndShift(e2.sourcePosition, e2.howMany);
        if (t2.deletionPosition.hasSameParentAs(e2.sourcePosition) && n2.containsPosition(t2.sourcePosition)) {
          if (e2.type != "remove" || i2.forceWeakRemove) {
            if (e2.howMany == 1)
              return i2.bWasUndone ? (e2.sourcePosition = t2.graveyardPosition.clone(), e2.targetPosition = e2.targetPosition._getTransformedByMergeOperation(t2), [e2]) : [new Jc(0)];
          } else if (!i2.aWasUndone) {
            const i3 = [];
            let n3 = t2.graveyardPosition.clone(), o3 = t2.targetPosition._getTransformedByMergeOperation(t2);
            e2.howMany > 1 && (i3.push(new Tc(e2.sourcePosition, e2.howMany - 1, e2.targetPosition, 0)), n3 = n3._getTransformedByMove(e2.sourcePosition, e2.targetPosition, e2.howMany - 1), o3 = o3._getTransformedByMove(e2.sourcePosition, e2.targetPosition, e2.howMany - 1));
            const r2 = t2.deletionPosition._getCombined(e2.sourcePosition, e2.targetPosition), s2 = new Tc(n3, 1, r2, 0), a2 = s2.getMovedRangeStart().path.slice();
            a2.push(0);
            const c2 = new Xs(s2.targetPosition.root, a2);
            o3 = o3._getTransformedByMove(n3, r2, 1);
            const l2 = new Tc(o3, t2.howMany, c2, 0);
            return i3.push(s2), i3.push(l2), i3;
          }
        }
        const o2 = na._createFromPositionAndShift(e2.sourcePosition, e2.howMany)._getTransformedByMergeOperation(t2);
        return e2.sourcePosition = o2.start, e2.howMany = o2.end.offset - o2.start.offset, e2.targetPosition = e2.targetPosition._getTransformedByMergeOperation(t2), [e2];
      }), th(Sc, Ec, (e2, t2) => (e2.position = e2.position._getTransformedByInsertOperation(t2), [e2])), th(Sc, Mc, (e2, t2) => e2.position.isEqual(t2.deletionPosition) ? (e2.position = t2.graveyardPosition.clone(), e2.position.stickiness = "toNext", [e2]) : (e2.position = e2.position._getTransformedByMergeOperation(t2), [e2])), th(Sc, Tc, (e2, t2) => (e2.position = e2.position._getTransformedByMoveOperation(t2), [e2])), th(Sc, Sc, (e2, t2, i2) => {
        if (e2.position.isEqual(t2.position)) {
          if (!i2.aIsStrong)
            return [new Jc(0)];
          e2.oldName = t2.newName;
        }
        return [e2];
      }), th(Sc, Nc, (e2, t2) => {
        if (cn(e2.position.path, t2.splitPosition.getParentPath()) == "same" && !t2.graveyardPosition) {
          const t3 = new Sc(e2.position.getShiftedBy(1), e2.oldName, e2.newName, 0);
          return [e2, t3];
        }
        return e2.position = e2.position._getTransformedBySplitOperation(t2), [e2];
      }), th(Pc, Pc, (e2, t2, i2) => {
        if (e2.root === t2.root && e2.key === t2.key) {
          if (!i2.aIsStrong || e2.newValue === t2.newValue)
            return [new Jc(0)];
          e2.oldValue = t2.newValue;
        }
        return [e2];
      }), th(Nc, Ec, (e2, t2) => (e2.splitPosition.hasSameParentAs(t2.position) && e2.splitPosition.offset < t2.position.offset && (e2.howMany += t2.howMany), e2.splitPosition = e2.splitPosition._getTransformedByInsertOperation(t2), e2.insertionPosition = e2.insertionPosition._getTransformedByInsertOperation(t2), [e2])), th(Nc, Mc, (e2, t2, i2) => {
        if (!e2.graveyardPosition && !i2.bWasUndone && e2.splitPosition.hasSameParentAs(t2.sourcePosition)) {
          const i3 = t2.graveyardPosition.path.slice();
          i3.push(0);
          const n2 = new Xs(t2.graveyardPosition.root, i3), o2 = Nc.getInsertionPosition(new Xs(t2.graveyardPosition.root, i3)), r2 = new Nc(n2, 0, o2, null, 0);
          return e2.splitPosition = e2.splitPosition._getTransformedByMergeOperation(t2), e2.insertionPosition = Nc.getInsertionPosition(e2.splitPosition), e2.graveyardPosition = r2.insertionPosition.clone(), e2.graveyardPosition.stickiness = "toNext", [r2, e2];
        }
        return e2.splitPosition.hasSameParentAs(t2.deletionPosition) && !e2.splitPosition.isAfter(t2.deletionPosition) && e2.howMany--, e2.splitPosition.hasSameParentAs(t2.targetPosition) && (e2.howMany += t2.howMany), e2.splitPosition = e2.splitPosition._getTransformedByMergeOperation(t2), e2.insertionPosition = Nc.getInsertionPosition(e2.splitPosition), e2.graveyardPosition && (e2.graveyardPosition = e2.graveyardPosition._getTransformedByMergeOperation(t2)), [e2];
      }), th(Nc, Tc, (e2, t2, i2) => {
        const n2 = na._createFromPositionAndShift(t2.sourcePosition, t2.howMany);
        if (e2.graveyardPosition) {
          const o3 = n2.start.isEqual(e2.graveyardPosition) || n2.containsPosition(e2.graveyardPosition);
          if (!i2.bWasUndone && o3) {
            const i3 = e2.splitPosition._getTransformedByMoveOperation(t2), n3 = e2.graveyardPosition._getTransformedByMoveOperation(t2), o4 = n3.path.slice();
            o4.push(0);
            const r2 = new Xs(n3.root, o4);
            return [new Tc(i3, e2.howMany, r2, 0)];
          }
          e2.graveyardPosition = e2.graveyardPosition._getTransformedByMoveOperation(t2);
        }
        const o2 = e2.splitPosition.isEqual(t2.targetPosition);
        if (o2 && (i2.baRelation == "insertAtSource" || i2.abRelation == "splitBefore"))
          return e2.howMany += t2.howMany, e2.splitPosition = e2.splitPosition._getTransformedByDeletion(t2.sourcePosition, t2.howMany), e2.insertionPosition = Nc.getInsertionPosition(e2.splitPosition), [e2];
        if (o2 && i2.abRelation && i2.abRelation.howMany) {
          const { howMany: t3, offset: n3 } = i2.abRelation;
          return e2.howMany += t3, e2.splitPosition = e2.splitPosition.getShiftedBy(n3), [e2];
        }
        if (e2.splitPosition.hasSameParentAs(t2.sourcePosition) && n2.containsPosition(e2.splitPosition)) {
          const i3 = t2.howMany - (e2.splitPosition.offset - t2.sourcePosition.offset);
          return e2.howMany -= i3, e2.splitPosition.hasSameParentAs(t2.targetPosition) && e2.splitPosition.offset < t2.targetPosition.offset && (e2.howMany += t2.howMany), e2.splitPosition = t2.sourcePosition.clone(), e2.insertionPosition = Nc.getInsertionPosition(e2.splitPosition), [e2];
        }
        return t2.sourcePosition.isEqual(t2.targetPosition) || (e2.splitPosition.hasSameParentAs(t2.sourcePosition) && e2.splitPosition.offset <= t2.sourcePosition.offset && (e2.howMany -= t2.howMany), e2.splitPosition.hasSameParentAs(t2.targetPosition) && e2.splitPosition.offset < t2.targetPosition.offset && (e2.howMany += t2.howMany)), e2.splitPosition.stickiness = "toNone", e2.splitPosition = e2.splitPosition._getTransformedByMoveOperation(t2), e2.splitPosition.stickiness = "toNext", e2.graveyardPosition ? e2.insertionPosition = e2.insertionPosition._getTransformedByMoveOperation(t2) : e2.insertionPosition = Nc.getInsertionPosition(e2.splitPosition), [e2];
      }), th(Nc, Nc, (e2, t2, i2) => {
        if (e2.splitPosition.isEqual(t2.splitPosition)) {
          if (!e2.graveyardPosition && !t2.graveyardPosition)
            return [new Jc(0)];
          if (e2.graveyardPosition && t2.graveyardPosition && e2.graveyardPosition.isEqual(t2.graveyardPosition))
            return [new Jc(0)];
          if (i2.abRelation == "splitBefore")
            return e2.howMany = 0, e2.graveyardPosition = e2.graveyardPosition._getTransformedBySplitOperation(t2), [e2];
        }
        if (e2.graveyardPosition && t2.graveyardPosition && e2.graveyardPosition.isEqual(t2.graveyardPosition)) {
          const n2 = e2.splitPosition.root.rootName == "$graveyard", o2 = t2.splitPosition.root.rootName == "$graveyard", r2 = n2 && !o2;
          if (o2 && !n2 || !r2 && i2.aIsStrong) {
            const i3 = [];
            return t2.howMany && i3.push(new Tc(t2.moveTargetPosition, t2.howMany, t2.splitPosition, 0)), e2.howMany && i3.push(new Tc(e2.splitPosition, e2.howMany, e2.moveTargetPosition, 0)), i3;
          }
          return [new Jc(0)];
        }
        if (e2.graveyardPosition && (e2.graveyardPosition = e2.graveyardPosition._getTransformedBySplitOperation(t2)), e2.splitPosition.isEqual(t2.insertionPosition) && i2.abRelation == "splitBefore")
          return e2.howMany++, [e2];
        if (t2.splitPosition.isEqual(e2.insertionPosition) && i2.baRelation == "splitBefore") {
          const i3 = t2.insertionPosition.path.slice();
          i3.push(0);
          const n2 = new Xs(t2.insertionPosition.root, i3);
          return [e2, new Tc(e2.insertionPosition, 1, n2, 0)];
        }
        return e2.splitPosition.hasSameParentAs(t2.splitPosition) && e2.splitPosition.offset < t2.splitPosition.offset && (e2.howMany -= t2.howMany), e2.splitPosition = e2.splitPosition._getTransformedBySplitOperation(t2), e2.insertionPosition = Nc.getInsertionPosition(e2.splitPosition), [e2];
      });
      class hh extends es {
        constructor(e2) {
          super(e2), this.domEventType = "click";
        }
        onDomEvent(e2) {
          this.fire(e2.type, e2);
        }
      }
      class uh extends es {
        constructor(e2) {
          super(e2), this.domEventType = ["mousedown", "mouseup", "mouseover", "mouseout"];
        }
        onDomEvent(e2) {
          this.fire(e2.type, e2);
        }
      }
      class gh {
        constructor(e2) {
          this.document = e2;
        }
        createDocumentFragment(e2) {
          return new Uo(this.document, e2);
        }
        createElement(e2, t2, i2) {
          return new eo(this.document, e2, t2, i2);
        }
        createText(e2) {
          return new hn(this.document, e2);
        }
        clone(e2, t2 = false) {
          return e2._clone(t2);
        }
        appendChild(e2, t2) {
          return t2._appendChild(e2);
        }
        insertChild(e2, t2, i2) {
          return i2._insertChild(e2, t2);
        }
        removeChildren(e2, t2, i2) {
          return i2._removeChildren(e2, t2);
        }
        remove(e2) {
          const t2 = e2.parent;
          return t2 ? this.removeChildren(t2.getChildIndex(e2), 1, t2) : [];
        }
        replace(e2, t2) {
          const i2 = e2.parent;
          if (i2) {
            const n2 = i2.getChildIndex(e2);
            return this.removeChildren(n2, 1, i2), this.insertChild(n2, t2, i2), true;
          }
          return false;
        }
        unwrapElement(e2) {
          const t2 = e2.parent;
          if (t2) {
            const i2 = t2.getChildIndex(e2);
            this.remove(e2), this.insertChild(i2, e2.getChildren(), t2);
          }
        }
        rename(e2, t2) {
          const i2 = new eo(this.document, e2, t2.getAttributes(), t2.getChildren());
          return this.replace(t2, i2) ? i2 : null;
        }
        setAttribute(e2, t2, i2) {
          i2._setAttribute(e2, t2);
        }
        removeAttribute(e2, t2) {
          t2._removeAttribute(e2);
        }
        addClass(e2, t2) {
          t2._addClass(e2);
        }
        removeClass(e2, t2) {
          t2._removeClass(e2);
        }
        setStyle(e2, t2, i2) {
          ct(e2) && i2 === void 0 && (i2 = t2), i2._setStyle(e2, t2);
        }
        removeStyle(e2, t2) {
          t2._removeStyle(e2);
        }
        setCustomProperty(e2, t2, i2) {
          i2._setCustomProperty(e2, t2);
        }
        removeCustomProperty(e2, t2) {
          return t2._removeCustomProperty(e2);
        }
        createPositionAt(e2, t2) {
          return co._createAt(e2, t2);
        }
        createPositionAfter(e2) {
          return co._createAfter(e2);
        }
        createPositionBefore(e2) {
          return co._createBefore(e2);
        }
        createRange(e2, t2) {
          return new lo(e2, t2);
        }
        createRangeOn(e2) {
          return lo._createOn(e2);
        }
        createRangeIn(e2) {
          return lo._createIn(e2);
        }
        createSelection(e2, t2, i2) {
          return new go(e2, t2, i2);
        }
      }
      class mh extends vl {
        constructor(e2, t2) {
          super(e2), this.view = t2, this._toolbarConfig = fd(e2.config.get("toolbar")), this._elementReplacer = new _s();
        }
        get element() {
          return this.view.element;
        }
        init(e2) {
          const t2 = this.editor, i2 = this.view, n2 = t2.editing.view, o2 = i2.editable, r2 = n2.document.getRoot();
          o2.name = r2.rootName, i2.render();
          const s2 = o2.element;
          this.setEditableElement(o2.name, s2), this.focusTracker.add(s2), i2.editable.bind("isFocused").to(this.focusTracker), n2.attachDomRoot(s2), e2 && this._elementReplacer.replace(e2, this.element), this._initPlaceholder(), this._initToolbar(), this.fire("ready");
        }
        destroy() {
          const e2 = this.view, t2 = this.editor.editing.view;
          this._elementReplacer.restore(), t2.detachDomRoot(e2.editable.name), e2.destroy(), super.destroy();
        }
        _initToolbar() {
          const e2 = this.editor, t2 = this.view, i2 = e2.editing.view;
          t2.stickyPanel.bind("isActive").to(this.focusTracker, "isFocused"), t2.stickyPanel.limiterElement = t2.element, t2.stickyPanel.bind("viewportTopOffset").to(this, "viewportOffset", ({ top: e3 }) => e3), t2.toolbar.fillFromConfig(this._toolbarConfig, this.componentFactory), function({ origin: e3, originKeystrokeHandler: t3, originFocusTracker: i3, toolbar: n2, beforeFocus: o2, afterBlur: r2 }) {
            i3.add(n2.element), t3.set("Alt+F10", (e4, t4) => {
              i3.isFocused && !n2.focusTracker.isFocused && (o2 && o2(), n2.focus(), t4());
            }), n2.keystrokes.set("Esc", (t4, i4) => {
              n2.focusTracker.isFocused && (e3.focus(), r2 && r2(), i4());
            });
          }({ origin: i2, originFocusTracker: this.focusTracker, originKeystrokeHandler: e2.keystrokes, toolbar: t2.toolbar });
        }
        _initPlaceholder() {
          const e2 = this.editor, t2 = e2.editing.view, i2 = t2.document.getRoot(), n2 = e2.sourceElement, o2 = e2.config.get("placeholder") || n2 && n2.tagName.toLowerCase() === "textarea" && n2.getAttribute("placeholder");
          o2 && Kd({ view: t2, element: i2, text: o2, isDirectHost: false, keepOnFocus: true });
        }
      }
      i(61);
      class fh extends Id {
        constructor(e2, t2, i2 = {}) {
          super(e2), this.stickyPanel = new Yd(e2), this.toolbar = new pd(e2, { shouldGroupWhenFull: i2.shouldToolbarGroupWhenFull }), this.editable = new Pd(e2, t2);
        }
        render() {
          super.render(), this.stickyPanel.content.add(this.toolbar), this.top.add(this.stickyPanel), this.main.add(this.editable);
        }
      }
      class ph extends wl {
        constructor(e2, t2) {
          super(t2), Yi(e2) && (this.sourceElement = e2), this.model.document.createRoot();
          const i2 = !this.config.get("toolbar.shouldNotGroupWhenFull"), n2 = new fh(this.locale, this.editing.view, { shouldToolbarGroupWhenFull: i2 });
          this.ui = new mh(this, n2), function(e3) {
            if (!M(e3.updateSourceElement))
              throw new c.a("attachtoform-missing-elementapi-interface", e3);
            const t3 = e3.sourceElement;
            if (t3 && t3.tagName.toLowerCase() === "textarea" && t3.form) {
              let i3;
              const n3 = t3.form, o2 = () => e3.updateSourceElement();
              M(n3.submit) && (i3 = n3.submit, n3.submit = () => {
                o2(), i3.apply(n3);
              }), n3.addEventListener("submit", o2), e3.on("destroy", () => {
                n3.removeEventListener("submit", o2), i3 && (n3.submit = i3);
              });
            }
          }(this);
        }
        destroy() {
          return this.sourceElement && this.updateSourceElement(), this.ui.destroy(), super.destroy();
        }
        static create(e2, t2 = {}) {
          return new Promise((i2) => {
            const n2 = new this(e2, t2);
            i2(n2.initPlugins().then(() => n2.ui.init(Yi(e2) ? e2 : null)).then(() => {
              if (!Yi(e2) && t2.initialData)
                throw new c.a("editor-create-initial-data", null);
              const i3 = t2.initialData !== void 0 ? t2.initialData : function(e3) {
                return Yi(e3) ? (t3 = e3, t3 instanceof HTMLTextAreaElement ? t3.value : t3.innerHTML) : e3;
                var t3;
              }(e2);
              return n2.data.init(i3);
            }).then(() => n2.fire("ready")).then(() => n2));
          });
        }
      }
      Ke(ph, yl), Ke(ph, xl);
      class bh {
        constructor(e2) {
          this.files = function(e3) {
            const t2 = Array.from(e3.files || []), i2 = Array.from(e3.items || []);
            if (t2.length)
              return t2;
            return i2.filter((e4) => e4.kind === "file").map((e4) => e4.getAsFile());
          }(e2), this._native = e2;
        }
        get types() {
          return this._native.types;
        }
        getData(e2) {
          return this._native.getData(e2);
        }
        setData(e2, t2) {
          this._native.setData(e2, t2);
        }
        set effectAllowed(e2) {
          this._native.effectAllowed = e2;
        }
        get effectAllowed() {
          return this._native.effectAllowed;
        }
        set dropEffect(e2) {
          this._native.dropEffect = e2;
        }
        get dropEffect() {
          return this._native.dropEffect;
        }
        get isCanceled() {
          return this._native.dropEffect == "none" || !!this._native.mozUserCancelled;
        }
      }
      class wh extends es {
        constructor(e2) {
          super(e2);
          const t2 = this.document;
          function i2(e3) {
            return (i3, n2) => {
              n2.preventDefault();
              const r2 = n2.dropRange ? [n2.dropRange] : null, s2 = new o(t2, e3);
              t2.fire(s2, { dataTransfer: n2.dataTransfer, method: i3.name, targetRanges: r2, target: n2.target }), s2.stop.called && n2.stopPropagation();
            };
          }
          this.domEventType = ["paste", "copy", "cut", "drop", "dragover", "dragstart", "dragend", "dragenter", "dragleave"], this.listenTo(t2, "paste", i2("clipboardInput"), { priority: "low" }), this.listenTo(t2, "drop", i2("clipboardInput"), { priority: "low" }), this.listenTo(t2, "dragover", i2("dragging"), { priority: "low" });
        }
        onDomEvent(e2) {
          const t2 = { dataTransfer: new bh(e2.clipboardData ? e2.clipboardData : e2.dataTransfer) };
          e2.type != "drop" && e2.type != "dragover" || (t2.dropRange = function(e3, t3) {
            const i2 = t3.target.ownerDocument, n2 = t3.clientX, o2 = t3.clientY;
            let r2;
            i2.caretRangeFromPoint && i2.caretRangeFromPoint(n2, o2) ? r2 = i2.caretRangeFromPoint(n2, o2) : t3.rangeParent && (r2 = i2.createRange(), r2.setStart(t3.rangeParent, t3.rangeOffset), r2.collapse(true));
            if (r2)
              return e3.domConverter.domRangeToView(r2);
            return null;
          }(this.view, e2)), this.fire(e2.type, e2, t2);
        }
      }
      const kh = ["figcaption", "li"];
      class _h extends Qe {
        static get pluginName() {
          return "ClipboardPipeline";
        }
        init() {
          this.editor.editing.view.addObserver(wh), this._setupPasteDrop(), this._setupCopyCut();
        }
        _setupPasteDrop() {
          const e2 = this.editor, t2 = e2.model, i2 = e2.editing.view, n2 = i2.document;
          this.listenTo(n2, "clipboardInput", (t3) => {
            e2.isReadOnly && t3.stop();
          }, { priority: "highest" }), this.listenTo(n2, "clipboardInput", (e3, t3) => {
            const n3 = t3.dataTransfer;
            let r2 = t3.content || "";
            var s2;
            r2 || (n3.getData("text/html") ? r2 = function(e4) {
              return e4.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, (e5, t4) => t4.length == 1 ? " " : t4).replace(/<!--[\s\S]*?-->/g, "");
            }(n3.getData("text/html")) : n3.getData("text/plain") && (((s2 = (s2 = n3.getData("text/plain")).replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r?\n\r?\n/g, "</p><p>").replace(/\r?\n/g, "<br>").replace(/^\s/, "&nbsp;").replace(/\s$/, "&nbsp;").replace(/\s\s/g, " &nbsp;")).includes("</p><p>") || s2.includes("<br>")) && (s2 = `<p>${s2}</p>`), r2 = s2), r2 = this.editor.data.htmlProcessor.toView(r2));
            const a2 = new o(this, "inputTransformation");
            this.fire(a2, { content: r2, dataTransfer: n3, targetRanges: t3.targetRanges, method: t3.method }), a2.stop.called && e3.stop(), i2.scrollToTheSelection();
          }, { priority: "low" }), this.listenTo(this, "inputTransformation", (e3, i3) => {
            if (i3.content.isEmpty)
              return;
            const n3 = this.editor.data.toModel(i3.content, "$clipboardHolder");
            n3.childCount != 0 && (e3.stop(), t2.change(() => {
              this.fire("contentInsertion", { content: n3, method: i3.method, dataTransfer: i3.dataTransfer, targetRanges: i3.targetRanges });
            }));
          }, { priority: "low" }), this.listenTo(this, "contentInsertion", (e3, i3) => {
            i3.resultRange = t2.insertContent(i3.content);
          }, { priority: "low" });
        }
        _setupCopyCut() {
          const e2 = this.editor, t2 = e2.model.document, i2 = e2.editing.view.document;
          function n2(n3, o2) {
            const r2 = o2.dataTransfer;
            o2.preventDefault();
            const s2 = e2.data.toView(e2.model.getSelectedContent(t2.selection));
            i2.fire("clipboardOutput", { dataTransfer: r2, content: s2, method: n3.name });
          }
          this.listenTo(i2, "copy", n2, { priority: "low" }), this.listenTo(i2, "cut", (t3, i3) => {
            e2.isReadOnly ? i3.preventDefault() : n2(t3, i3);
          }, { priority: "low" }), this.listenTo(i2, "clipboardOutput", (i3, n3) => {
            n3.content.isEmpty || (n3.dataTransfer.setData("text/html", this.editor.data.htmlProcessor.toData(n3.content)), n3.dataTransfer.setData("text/plain", function e3(t3) {
              let i4 = "";
              if (t3.is("$text") || t3.is("$textProxy"))
                i4 = t3.data;
              else if (t3.is("element", "img") && t3.hasAttribute("alt"))
                i4 = t3.getAttribute("alt");
              else if (t3.is("element", "br"))
                i4 = "\n";
              else {
                let n4 = null;
                for (const o2 of t3.getChildren()) {
                  const t4 = e3(o2);
                  n4 && (n4.is("containerElement") || o2.is("containerElement")) && (kh.includes(n4.name) || kh.includes(o2.name) ? i4 += "\n" : i4 += "\n\n"), i4 += t4, n4 = o2;
                }
              }
              return i4;
            }(n3.content))), n3.method == "cut" && e2.model.deleteContent(t2.selection);
          }, { priority: "low" });
        }
      }
      function* vh(e2, t2) {
        for (const i2 of t2)
          i2 && e2.getAttributeProperties(i2[0]).copyOnEnter && (yield i2);
      }
      class yh extends Ze {
        execute() {
          const e2 = this.editor.model, t2 = e2.document;
          e2.change((i2) => {
            !function(e3, t3, i3, n2) {
              const o2 = i3.isCollapsed, r2 = i3.getFirstRange(), s2 = r2.start.parent, a2 = r2.end.parent;
              if (n2.isLimit(s2) || n2.isLimit(a2))
                return void (o2 || s2 != a2 || e3.deleteContent(i3));
              if (o2) {
                const e4 = vh(t3.model.schema, i3.getAttributes());
                xh(t3, r2.start), t3.setSelectionAttribute(e4);
              } else {
                const n3 = !(r2.start.isAtStart && r2.end.isAtEnd), o3 = s2 == a2;
                e3.deleteContent(i3, { leaveUnmerged: n3 }), n3 && (o3 ? xh(t3, i3.focus) : t3.setSelection(a2, 0));
              }
            }(this.editor.model, i2, t2.selection, e2.schema), this.fire("afterExecute", { writer: i2 });
          });
        }
      }
      function xh(e2, t2) {
        e2.split(t2), e2.setSelection(t2.parent.nextSibling, 0);
      }
      class Ah extends Rr {
        constructor(e2) {
          super(e2);
          const t2 = this.document;
          t2.on("keydown", (e3, i2) => {
            if (this.isEnabled && i2.keyCode == No.enter) {
              const n2 = new fo(t2, "enter", t2.selection.getFirstRange());
              t2.fire(n2, new Xr(t2, i2.domEvent, { isSoft: i2.shiftKey })), n2.stop.called && e3.stop();
            }
          });
        }
        observe() {
        }
      }
      class Ch extends Qe {
        static get pluginName() {
          return "Enter";
        }
        init() {
          const e2 = this.editor, t2 = e2.editing.view, i2 = t2.document;
          t2.addObserver(Ah), e2.commands.add("enter", new yh(e2)), this.listenTo(i2, "enter", (i3, n2) => {
            n2.preventDefault(), n2.isSoft || (e2.execute("enter"), t2.scrollToTheSelection());
          }, { priority: "low" });
        }
      }
      class Th {
        constructor(e2, t2 = 20) {
          this.model = e2, this.size = 0, this.limit = t2, this.isLocked = false, this._changeCallback = (e3, t3) => {
            t3.type != "transparent" && t3 !== this._batch && this._reset(true);
          }, this._selectionChangeCallback = () => {
            this._reset();
          }, this.model.document.on("change", this._changeCallback), this.model.document.selection.on("change:range", this._selectionChangeCallback), this.model.document.selection.on("change:attribute", this._selectionChangeCallback);
        }
        get batch() {
          return this._batch || (this._batch = this.model.createBatch()), this._batch;
        }
        input(e2) {
          this.size += e2, this.size >= this.limit && this._reset(true);
        }
        lock() {
          this.isLocked = true;
        }
        unlock() {
          this.isLocked = false;
        }
        destroy() {
          this.model.document.off("change", this._changeCallback), this.model.document.selection.off("change:range", this._selectionChangeCallback), this.model.document.selection.off("change:attribute", this._selectionChangeCallback);
        }
        _reset(e2) {
          this.isLocked && !e2 || (this._batch = null, this.size = 0);
        }
      }
      class Eh extends Ze {
        constructor(e2, t2) {
          super(e2), this.direction = t2, this._buffer = new Th(e2.model, e2.config.get("typing.undoStep"));
        }
        get buffer() {
          return this._buffer;
        }
        execute(e2 = {}) {
          const t2 = this.editor.model, i2 = t2.document;
          t2.enqueueChange(this._buffer.batch, (n2) => {
            this._buffer.lock();
            const o2 = n2.createSelection(e2.selection || i2.selection), r2 = e2.sequence || 1, s2 = o2.isCollapsed;
            if (o2.isCollapsed && t2.modifySelection(o2, { direction: this.direction, unit: e2.unit }), this._shouldEntireContentBeReplacedWithParagraph(r2))
              return void this._replaceEntireContentWithParagraph(n2);
            if (this._shouldReplaceFirstBlockWithParagraph(o2, r2))
              return void this.editor.execute("paragraph", { selection: o2 });
            if (o2.isCollapsed)
              return;
            let a2 = 0;
            o2.getFirstRange().getMinimalFlatRanges().forEach((e3) => {
              a2 += uo(e3.getWalker({ singleCharacters: true, ignoreElementEnd: true, shallow: true }));
            }), t2.deleteContent(o2, { doNotResetEntireContent: s2, direction: this.direction }), this._buffer.input(a2), n2.setSelection(o2), this._buffer.unlock();
          });
        }
        _shouldEntireContentBeReplacedWithParagraph(e2) {
          if (e2 > 1)
            return false;
          const t2 = this.editor.model, i2 = t2.document.selection, n2 = t2.schema.getLimitElement(i2);
          if (!(i2.isCollapsed && i2.containsEntireContent(n2)))
            return false;
          if (!t2.schema.checkChild(n2, "paragraph"))
            return false;
          const o2 = n2.getChild(0);
          return !o2 || o2.name !== "paragraph";
        }
        _replaceEntireContentWithParagraph(e2) {
          const t2 = this.editor.model, i2 = t2.document.selection, n2 = t2.schema.getLimitElement(i2), o2 = e2.createElement("paragraph");
          e2.remove(e2.createRangeIn(n2)), e2.insert(o2, n2), e2.setSelection(o2, 0);
        }
        _shouldReplaceFirstBlockWithParagraph(e2, t2) {
          const i2 = this.editor.model;
          if (t2 > 1 || this.direction != "backward")
            return false;
          if (!e2.isCollapsed)
            return false;
          const n2 = e2.getFirstPosition(), o2 = i2.schema.getLimitElement(n2), r2 = o2.getChild(0);
          return n2.parent == r2 && (!!e2.containsEntireContent(r2) && (!!i2.schema.checkChild(o2, "paragraph") && r2.name != "paragraph"));
        }
      }
      class Ih extends Rr {
        constructor(e2) {
          super(e2);
          const t2 = e2.document;
          let i2 = 0;
          function n2(e3, i3, n3) {
            const o2 = new fo(t2, "delete", t2.selection.getFirstRange());
            t2.fire(o2, new Xr(t2, i3, n3)), o2.stop.called && e3.stop();
          }
          t2.on("keyup", (e3, t3) => {
            t3.keyCode != No.delete && t3.keyCode != No.backspace || (i2 = 0);
          }), t2.on("keydown", (e3, t3) => {
            const o2 = {};
            if (t3.keyCode == No.delete)
              o2.direction = "forward", o2.unit = "character";
            else {
              if (t3.keyCode != No.backspace)
                return;
              o2.direction = "backward", o2.unit = "codePoint";
            }
            const r2 = So.isMac ? t3.altKey : t3.ctrlKey;
            o2.unit = r2 ? "word" : o2.unit, o2.sequence = ++i2, n2(e3, t3.domEvent, o2);
          }), So.isAndroid && t2.on("beforeinput", (t3, i3) => {
            if (i3.domEvent.inputType != "deleteContentBackward")
              return;
            const o2 = { unit: "codepoint", direction: "backward", sequence: 1 }, r2 = i3.domTarget.ownerDocument.defaultView.getSelection();
            r2.anchorNode == r2.focusNode && r2.anchorOffset + 1 != r2.focusOffset && (o2.selectionToRemove = e2.domConverter.domSelectionToView(r2)), n2(t3, i3.domEvent, o2);
          });
        }
        observe() {
        }
      }
      class Sh extends Qe {
        static get pluginName() {
          return "Delete";
        }
        init() {
          const e2 = this.editor, t2 = e2.editing.view, i2 = t2.document, n2 = e2.model.document;
          t2.addObserver(Ih), this._undoOnBackspace = false;
          const o2 = new Eh(e2, "forward");
          if (e2.commands.add("deleteForward", o2), e2.commands.add("forwardDelete", o2), e2.commands.add("delete", new Eh(e2, "backward")), this.listenTo(i2, "delete", (i3, n3) => {
            const o3 = { unit: n3.unit, sequence: n3.sequence };
            if (n3.selectionToRemove) {
              const t3 = e2.model.createSelection(), i4 = [];
              for (const t4 of n3.selectionToRemove.getRanges())
                i4.push(e2.editing.mapper.toModelRange(t4));
              t3.setTo(i4), o3.selection = t3;
            }
            e2.execute(n3.direction == "forward" ? "deleteForward" : "delete", o3), n3.preventDefault(), t2.scrollToTheSelection();
          }, { priority: "low" }), So.isAndroid) {
            let e3 = null;
            this.listenTo(i2, "delete", (t3, i3) => {
              const n3 = i3.domTarget.ownerDocument.defaultView.getSelection();
              e3 = { anchorNode: n3.anchorNode, anchorOffset: n3.anchorOffset, focusNode: n3.focusNode, focusOffset: n3.focusOffset };
            }, { priority: "lowest" }), this.listenTo(i2, "keyup", (t3, i3) => {
              if (e3) {
                const t4 = i3.domTarget.ownerDocument.defaultView.getSelection();
                t4.collapse(e3.anchorNode, e3.anchorOffset), t4.extend(e3.focusNode, e3.focusOffset), e3 = null;
              }
            });
          }
          this.editor.plugins.has("UndoEditing") && (this.listenTo(i2, "delete", (t3, i3) => {
            this._undoOnBackspace && i3.direction == "backward" && i3.sequence == 1 && i3.unit == "codePoint" && (this._undoOnBackspace = false, e2.execute("undo"), i3.preventDefault(), t3.stop());
          }, { context: "$capture" }), this.listenTo(n2, "change", () => {
            this._undoOnBackspace = false;
          }));
        }
        requestUndoOnBackspace() {
          this.editor.plugins.has("UndoEditing") && (this._undoOnBackspace = true);
        }
      }
      class Ph {
        constructor() {
          this._stack = [];
        }
        add(e2, t2) {
          const i2 = this._stack, n2 = i2[0];
          this._insertDescriptor(e2);
          const o2 = i2[0];
          n2 === o2 || Mh(n2, o2) || this.fire("change:top", { oldDescriptor: n2, newDescriptor: o2, writer: t2 });
        }
        remove(e2, t2) {
          const i2 = this._stack, n2 = i2[0];
          this._removeDescriptor(e2);
          const o2 = i2[0];
          n2 === o2 || Mh(n2, o2) || this.fire("change:top", { oldDescriptor: n2, newDescriptor: o2, writer: t2 });
        }
        _insertDescriptor(e2) {
          const t2 = this._stack, i2 = t2.findIndex((t3) => t3.id === e2.id);
          if (Mh(e2, t2[i2]))
            return;
          i2 > -1 && t2.splice(i2, 1);
          let n2 = 0;
          for (; t2[n2] && Nh(t2[n2], e2); )
            n2++;
          t2.splice(n2, 0, e2);
        }
        _removeDescriptor(e2) {
          const t2 = this._stack, i2 = t2.findIndex((t3) => t3.id === e2);
          i2 > -1 && t2.splice(i2, 1);
        }
      }
      function Mh(e2, t2) {
        return e2 && t2 && e2.priority == t2.priority && Rh(e2.classes) == Rh(t2.classes);
      }
      function Nh(e2, t2) {
        return e2.priority > t2.priority || !(e2.priority < t2.priority) && Rh(e2.classes) > Rh(t2.classes);
      }
      function Rh(e2) {
        return Array.isArray(e2) ? e2.sort().join(",") : e2;
      }
      Ke(Ph, h);
      function Oh(e2) {
        return !!e2.is("element") && !!e2.getCustomProperty("widget");
      }
      function zh(e2, t2, i2 = {}) {
        if (!e2.is("containerElement"))
          throw new c.a("widget-to-widget-wrong-element-type", null, { element: e2 });
        return t2.setAttribute("contenteditable", "false", e2), t2.addClass("ck-widget", e2), t2.setCustomProperty("widget", true, e2), e2.getFillerOffset = Hh, i2.label && function(e3, t3, i3) {
          i3.setCustomProperty("widgetLabel", t3, e3);
        }(e2, i2.label, t2), i2.hasSelectionHandle && function(e3, t3) {
          const i3 = t3.createUIElement("div", { class: "ck ck-widget__selection-handle" }, function(e4) {
            const t4 = this.toDomElement(e4), i4 = new Xl();
            return i4.set("content", '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M4 0v1H1v3H0V.5A.5.5 0 0 1 .5 0H4zm8 0h3.5a.5.5 0 0 1 .5.5V4h-1V1h-3V0zM4 16H.5a.5.5 0 0 1-.5-.5V12h1v3h3v1zm8 0v-1h3v-3h1v3.5a.5.5 0 0 1-.5.5H12z"/><path fill-opacity=".256" d="M1 1h14v14H1z"/><g class="ck-icon__selected-indicator"><path d="M7 0h2v1H7V0zM0 7h1v2H0V7zm15 0h1v2h-1V7zm-8 8h2v1H7v-1z"/><path fill-opacity=".254" d="M1 1h14v14H1z"/></g></svg>'), i4.render(), t4.appendChild(i4.element), t4;
          });
          t3.insert(t3.createPositionAt(e3, 0), i3), t3.addClass(["ck-widget_with-selection-handle"], e3);
        }(e2, t2), Vh(e2, t2), e2;
      }
      function Dh(e2, t2, i2) {
        if (t2.classes && i2.addClass(en(t2.classes), e2), t2.attributes)
          for (const n2 in t2.attributes)
            i2.setAttribute(n2, t2.attributes[n2], e2);
      }
      function Lh(e2, t2, i2) {
        if (t2.classes && i2.removeClass(en(t2.classes), e2), t2.attributes)
          for (const n2 in t2.attributes)
            i2.removeAttribute(n2, e2);
      }
      function Vh(e2, t2, i2 = Dh, n2 = Lh) {
        const o2 = new Ph();
        o2.on("change:top", (t3, o3) => {
          o3.oldDescriptor && n2(e2, o3.oldDescriptor, o3.writer), o3.newDescriptor && i2(e2, o3.newDescriptor, o3.writer);
        }), t2.setCustomProperty("addHighlight", (e3, t3, i3) => o2.add(t3, i3), e2), t2.setCustomProperty("removeHighlight", (e3, t3, i3) => o2.remove(t3, i3), e2);
      }
      function jh(e2) {
        const t2 = e2.getCustomProperty("widgetLabel");
        return t2 ? typeof t2 == "function" ? t2() : t2 : "";
      }
      function Bh(e2, t2) {
        return t2.addClass(["ck-editor__editable", "ck-editor__nested-editable"], e2), t2.setAttribute("contenteditable", e2.isReadOnly ? "false" : "true", e2), e2.on("change:isReadOnly", (i2, n2, o2) => {
          t2.setAttribute("contenteditable", o2 ? "false" : "true", e2);
        }), e2.on("change:isFocused", (i2, n2, o2) => {
          o2 ? t2.addClass("ck-editor__nested-editable_focused", e2) : t2.removeClass("ck-editor__nested-editable_focused", e2);
        }), Vh(e2, t2), e2;
      }
      function Fh(e2, t2) {
        const i2 = e2.getSelectedElement();
        if (i2) {
          const n3 = Wh(e2);
          if (n3)
            return t2.createRange(t2.createPositionAt(i2, n3));
          if (t2.schema.isObject(i2) && !t2.schema.isInline(i2))
            return t2.createRangeOn(i2);
        }
        const n2 = e2.getSelectedBlocks().next().value;
        if (n2) {
          if (n2.isEmpty)
            return t2.createRange(t2.createPositionAt(n2, 0));
          const i3 = t2.createPositionAfter(n2);
          return e2.focus.isTouching(i3) ? t2.createRange(i3) : t2.createRange(t2.createPositionBefore(n2));
        }
        return t2.createRange(e2.focus);
      }
      function Hh() {
        return null;
      }
      function Uh(e2, t2, i2) {
        return e2 && Oh(e2) && !i2.isInline(t2);
      }
      function Wh(e2) {
        return e2.getAttribute("widget-type-around");
      }
      const qh = [Oo("arrowUp"), Oo("arrowRight"), Oo("arrowDown"), Oo("arrowLeft"), 9, 16, 17, 18, 19, 20, 27, 33, 34, 35, 36, 45, 91, 93, 144, 145, 173, 174, 175, 176, 177, 178, 179, 255];
      for (let e2 = 112; e2 <= 135; e2++)
        qh.push(e2);
      function $h(e2) {
        return !(!e2.ctrlKey && !e2.metaKey) || qh.includes(e2.keyCode);
      }
      i(63);
      const Yh = ["before", "after"], Gh = new DOMParser().parseFromString('<svg viewBox="0 0 10 8" xmlns="http://www.w3.org/2000/svg"><path d="M9.055.263v3.972h-6.77M1 4.216l2-2.038m-2 2 2 2.038"/></svg>', "image/svg+xml").firstChild;
      class Kh extends Qe {
        static get pluginName() {
          return "WidgetTypeAround";
        }
        static get requires() {
          return [Ch, Sh];
        }
        constructor(e2) {
          super(e2), this._currentFakeCaretModelElement = null;
        }
        init() {
          const e2 = this.editor, t2 = e2.editing.view;
          this.on("change:isEnabled", (i2, n2, o2) => {
            t2.change((e3) => {
              for (const i3 of t2.document.roots)
                o2 ? e3.removeClass("ck-widget__type-around_disabled", i3) : e3.addClass("ck-widget__type-around_disabled", i3);
            }), o2 || e2.model.change((e3) => {
              e3.removeSelectionAttribute("widget-type-around");
            });
          }), this._enableTypeAroundUIInjection(), this._enableInsertingParagraphsOnButtonClick(), this._enableInsertingParagraphsOnEnterKeypress(), this._enableInsertingParagraphsOnTypingKeystroke(), this._enableTypeAroundFakeCaretActivationUsingKeyboardArrows(), this._enableDeleteIntegration(), this._enableInsertContentIntegration(), this._enableDeleteContentIntegration();
        }
        destroy() {
          this._currentFakeCaretModelElement = null;
        }
        _insertParagraph(e2, t2) {
          const i2 = this.editor, n2 = i2.editing.view;
          i2.execute("insertParagraph", { position: i2.model.createPositionAt(e2, t2) }), n2.focus(), n2.scrollToTheSelection();
        }
        _listenToIfEnabled(e2, t2, i2, n2) {
          this.listenTo(e2, t2, (...e3) => {
            this.isEnabled && i2(...e3);
          }, n2);
        }
        _insertParagraphAccordingToFakeCaretPosition() {
          const e2 = this.editor.model.document.selection, t2 = Wh(e2);
          if (!t2)
            return false;
          const i2 = e2.getSelectedElement();
          return this._insertParagraph(i2, t2), true;
        }
        _enableTypeAroundUIInjection() {
          const e2 = this.editor, t2 = e2.model.schema, i2 = e2.locale.t, n2 = { before: i2("Insert paragraph before block"), after: i2("Insert paragraph after block") };
          e2.editing.downcastDispatcher.on("insert", (e3, i3, o2) => {
            const r2 = o2.mapper.toViewElement(i3.item);
            Uh(r2, i3.item, t2) && function(e4, t3, i4) {
              const n3 = e4.createUIElement("div", { class: "ck ck-reset_all ck-widget__type-around" }, function(e5) {
                const i5 = this.toDomElement(e5);
                return function(e6, t4) {
                  for (const i6 of Yh) {
                    const n4 = new Rl({ tag: "div", attributes: { class: ["ck", "ck-widget__type-around__button", "ck-widget__type-around__button_" + i6], title: t4[i6] }, children: [e6.ownerDocument.importNode(Gh, true)] });
                    e6.appendChild(n4.render());
                  }
                }(i5, t3), function(e6) {
                  const t4 = new Rl({ tag: "div", attributes: { class: ["ck", "ck-widget__type-around__fake-caret"] } });
                  e6.appendChild(t4.render());
                }(i5), i5;
              });
              e4.insert(e4.createPositionAt(i4, "end"), n3);
            }(o2.writer, n2, r2);
          }, { priority: "low" });
        }
        _enableTypeAroundFakeCaretActivationUsingKeyboardArrows() {
          const e2 = this.editor, t2 = e2.model, i2 = t2.document.selection, n2 = t2.schema, o2 = e2.editing.view;
          function r2(e3) {
            return "ck-widget_type-around_show-fake-caret_" + e3;
          }
          this._listenToIfEnabled(o2.document, "arrowKey", (e3, t3) => {
            this._handleArrowKeyPress(e3, t3);
          }, { context: [Oh, "$text"], priority: "high" }), this._listenToIfEnabled(i2, "change:range", (t3, i3) => {
            i3.directChange && e2.model.change((e3) => {
              e3.removeSelectionAttribute("widget-type-around");
            });
          }), this._listenToIfEnabled(t2.document, "change:data", () => {
            const t3 = i2.getSelectedElement();
            if (t3) {
              if (Uh(e2.editing.mapper.toViewElement(t3), t3, n2))
                return;
            }
            e2.model.change((e3) => {
              e3.removeSelectionAttribute("widget-type-around");
            });
          }), this._listenToIfEnabled(e2.editing.downcastDispatcher, "selection", (e3, t3, i3) => {
            const o3 = i3.writer;
            if (this._currentFakeCaretModelElement) {
              const e4 = i3.mapper.toViewElement(this._currentFakeCaretModelElement);
              e4 && (o3.removeClass(Yh.map(r2), e4), this._currentFakeCaretModelElement = null);
            }
            const s2 = t3.selection.getSelectedElement();
            if (!s2)
              return;
            const a2 = i3.mapper.toViewElement(s2);
            if (!Uh(a2, s2, n2))
              return;
            const c2 = Wh(t3.selection);
            c2 && (o3.addClass(r2(c2), a2), this._currentFakeCaretModelElement = s2);
          }), this._listenToIfEnabled(e2.ui.focusTracker, "change:isFocused", (t3, i3, n3) => {
            n3 || e2.model.change((e3) => {
              e3.removeSelectionAttribute("widget-type-around");
            });
          });
        }
        _handleArrowKeyPress(e2, t2) {
          const i2 = this.editor, n2 = i2.model, o2 = n2.document.selection, r2 = n2.schema, s2 = i2.editing.view, a2 = function(e3, t3) {
            const i3 = Lo(e3, t3);
            return i3 === "down" || i3 === "right";
          }(t2.keyCode, i2.locale.contentLanguageDirection), c2 = s2.document.selection.getSelectedElement();
          let l2;
          Uh(c2, i2.editing.mapper.toModelElement(c2), r2) ? l2 = this._handleArrowKeyPressOnSelectedWidget(a2) : o2.isCollapsed ? l2 = this._handleArrowKeyPressWhenSelectionNextToAWidget(a2) : t2.shiftKey || (l2 = this._handleArrowKeyPressWhenNonCollapsedSelection(a2)), l2 && (t2.preventDefault(), e2.stop());
        }
        _handleArrowKeyPressOnSelectedWidget(e2) {
          const t2 = this.editor.model, i2 = Wh(t2.document.selection);
          return t2.change((t3) => {
            if (!i2)
              return t3.setSelectionAttribute("widget-type-around", e2 ? "after" : "before"), true;
            if (!(i2 === (e2 ? "after" : "before")))
              return t3.removeSelectionAttribute("widget-type-around"), true;
            return false;
          });
        }
        _handleArrowKeyPressWhenSelectionNextToAWidget(e2) {
          const t2 = this.editor, i2 = t2.model, n2 = i2.schema, o2 = t2.plugins.get("Widget"), r2 = o2._getObjectElementNextToSelection(e2);
          return !!Uh(t2.editing.mapper.toViewElement(r2), r2, n2) && (i2.change((t3) => {
            o2._setSelectionOverElement(r2), t3.setSelectionAttribute("widget-type-around", e2 ? "before" : "after");
          }), true);
        }
        _handleArrowKeyPressWhenNonCollapsedSelection(e2) {
          const t2 = this.editor, i2 = t2.model, n2 = i2.schema, o2 = t2.editing.mapper, r2 = i2.document.selection, s2 = e2 ? r2.getLastPosition().nodeBefore : r2.getFirstPosition().nodeAfter;
          return !!Uh(o2.toViewElement(s2), s2, n2) && (i2.change((t3) => {
            t3.setSelection(s2, "on"), t3.setSelectionAttribute("widget-type-around", e2 ? "after" : "before");
          }), true);
        }
        _enableInsertingParagraphsOnButtonClick() {
          const e2 = this.editor, t2 = e2.editing.view;
          this._listenToIfEnabled(t2.document, "mousedown", (i2, n2) => {
            const o2 = n2.domTarget.closest(".ck-widget__type-around__button");
            if (!o2)
              return;
            const r2 = function(e3) {
              return e3.classList.contains("ck-widget__type-around__button_before") ? "before" : "after";
            }(o2), s2 = function(e3, t3) {
              const i3 = e3.closest(".ck-widget");
              return t3.mapDomToView(i3);
            }(o2, t2.domConverter), a2 = e2.editing.mapper.toModelElement(s2);
            this._insertParagraph(a2, r2), n2.preventDefault(), i2.stop();
          });
        }
        _enableInsertingParagraphsOnEnterKeypress() {
          const e2 = this.editor, t2 = e2.model.document.selection, i2 = e2.editing.view;
          this._listenToIfEnabled(i2.document, "enter", (i3, n2) => {
            if (i3.eventPhase != "atTarget")
              return;
            const o2 = t2.getSelectedElement(), r2 = e2.editing.mapper.toViewElement(o2), s2 = e2.model.schema;
            let a2;
            this._insertParagraphAccordingToFakeCaretPosition() ? a2 = true : Uh(r2, o2, s2) && (this._insertParagraph(o2, n2.isSoft ? "before" : "after"), a2 = true), a2 && (n2.preventDefault(), i3.stop());
          }, { context: Oh });
        }
        _enableInsertingParagraphsOnTypingKeystroke() {
          const e2 = this.editor.editing.view, t2 = [No.enter, No.delete, No.backspace];
          this._listenToIfEnabled(e2.document, "keydown", (e3, i2) => {
            t2.includes(i2.keyCode) || $h(i2) || this._insertParagraphAccordingToFakeCaretPosition();
          }, { priority: "high" });
        }
        _enableDeleteIntegration() {
          const e2 = this.editor, t2 = e2.editing.view, i2 = e2.model, n2 = i2.schema;
          this._listenToIfEnabled(t2.document, "delete", (t3, o2) => {
            if (t3.eventPhase != "atTarget")
              return;
            const r2 = Wh(i2.document.selection);
            if (!r2)
              return;
            const s2 = o2.direction, a2 = i2.document.selection.getSelectedElement(), c2 = s2 == "forward";
            if (r2 === "before" === c2)
              e2.execute("delete", { selection: i2.createSelection(a2, "on") });
            else {
              const t4 = n2.getNearestSelectionRange(i2.createPositionAt(a2, r2), s2);
              if (t4)
                if (t4.isCollapsed) {
                  const o3 = i2.createSelection(t4.start);
                  if (i2.modifySelection(o3, { direction: s2 }), o3.focus.isEqual(t4.start)) {
                    const e3 = function(e4, t5) {
                      let i3 = t5;
                      for (const n3 of t5.getAncestors({ parentFirst: true })) {
                        if (n3.childCount > 1 || e4.isLimit(n3))
                          break;
                        i3 = n3;
                      }
                      return i3;
                    }(n2, t4.start.parent);
                    i2.deleteContent(i2.createSelection(e3, "on"), { doNotAutoparagraph: true });
                  } else
                    i2.change((i3) => {
                      i3.setSelection(t4), e2.execute(c2 ? "deleteForward" : "delete");
                    });
                } else
                  i2.change((i3) => {
                    i3.setSelection(t4), e2.execute(c2 ? "deleteForward" : "delete");
                  });
            }
            o2.preventDefault(), t3.stop();
          }, { context: Oh });
        }
        _enableInsertContentIntegration() {
          const e2 = this.editor, t2 = this.editor.model, i2 = t2.document.selection;
          this._listenToIfEnabled(e2.model, "insertContent", (e3, [n2, o2]) => {
            if (o2 && !o2.is("documentSelection"))
              return;
            const r2 = Wh(i2);
            return r2 ? (e3.stop(), t2.change((e4) => {
              const o3 = i2.getSelectedElement(), s2 = t2.createPositionAt(o3, r2), a2 = e4.createSelection(s2), c2 = t2.insertContent(n2, a2);
              return e4.setSelection(a2), c2;
            })) : void 0;
          }, { priority: "high" });
        }
        _enableDeleteContentIntegration() {
          const e2 = this.editor, t2 = this.editor.model.document.selection;
          this._listenToIfEnabled(e2.model, "deleteContent", (e3, [i2]) => {
            if (i2 && !i2.is("documentSelection"))
              return;
            Wh(t2) && e3.stop();
          }, { priority: "high" });
        }
      }
      function Qh(e2) {
        const t2 = e2.model;
        return (i2, n2) => {
          const o2 = n2.keyCode == No.arrowup, r2 = n2.keyCode == No.arrowdown, s2 = n2.shiftKey, a2 = t2.document.selection;
          if (!o2 && !r2)
            return;
          const c2 = r2;
          if (s2 && function(e3, t3) {
            return !e3.isCollapsed && e3.isBackward == t3;
          }(a2, c2))
            return;
          const l2 = function(e3, t3, i3) {
            const n3 = e3.model;
            if (i3) {
              const e4 = t3.isCollapsed ? t3.focus : t3.getLastPosition(), i4 = Jh(n3, e4, "forward");
              if (!i4)
                return null;
              const o3 = n3.createRange(e4, i4), r3 = Zh(n3.schema, o3, "backward");
              return r3 ? n3.createRange(e4, r3) : null;
            }
            {
              const e4 = t3.isCollapsed ? t3.focus : t3.getFirstPosition(), i4 = Jh(n3, e4, "backward");
              if (!i4)
                return null;
              const o3 = n3.createRange(i4, e4), r3 = Zh(n3.schema, o3, "forward");
              return r3 ? n3.createRange(r3, e4) : null;
            }
          }(e2, a2, c2);
          if (l2) {
            if (l2.isCollapsed) {
              if (a2.isCollapsed)
                return;
              if (s2)
                return;
            }
            (l2.isCollapsed || function(e3, t3, i3) {
              const n3 = e3.model, o3 = e3.view.domConverter;
              if (i3) {
                const e4 = n3.createSelection(t3.start);
                n3.modifySelection(e4), e4.focus.isAtEnd || t3.start.isEqual(e4.focus) || (t3 = n3.createRange(e4.focus, t3.end));
              }
              const r3 = e3.mapper.toViewRange(t3), s3 = o3.viewRangeToDom(r3), a3 = Cs.getDomRangeRects(s3);
              let c3;
              for (const e4 of a3)
                if (c3 !== void 0) {
                  if (Math.round(e4.top) >= c3)
                    return false;
                  c3 = Math.max(c3, Math.round(e4.bottom));
                } else
                  c3 = Math.round(e4.bottom);
              return true;
            }(e2, l2, c2)) && (t2.change((e3) => {
              const i3 = c2 ? l2.end : l2.start;
              if (s2) {
                const n3 = t2.createSelection(a2.anchor);
                n3.setFocus(i3), e3.setSelection(n3);
              } else
                e3.setSelection(i3);
            }), i2.stop(), n2.preventDefault(), n2.stopPropagation());
          }
        };
      }
      function Jh(e2, t2, i2) {
        const n2 = e2.schema, o2 = e2.createRangeIn(t2.root), r2 = i2 == "forward" ? "elementStart" : "elementEnd";
        for (const { previousPosition: e3, item: s2, type: a2 } of o2.getWalker({ startPosition: t2, direction: i2 })) {
          if (n2.isLimit(s2) && !n2.isInline(s2))
            return e3;
          if (a2 == r2 && n2.isBlock(s2))
            return null;
        }
        return null;
      }
      function Zh(e2, t2, i2) {
        const n2 = i2 == "backward" ? t2.end : t2.start;
        if (e2.checkChild(n2, "$text"))
          return n2;
        for (const { nextPosition: n3 } of t2.getWalker({ direction: i2 }))
          if (e2.checkChild(n3, "$text"))
            return n3;
        return null;
      }
      i(65);
      class Xh extends Qe {
        static get pluginName() {
          return "Widget";
        }
        static get requires() {
          return [Kh, Sh];
        }
        init() {
          const e2 = this.editor, t2 = e2.editing.view, i2 = t2.document;
          this._previouslySelected = new Set(), this.editor.editing.downcastDispatcher.on("selection", (t3, i3, n2) => {
            const o2 = n2.writer, r2 = i3.selection;
            if (r2.isCollapsed)
              return;
            const s2 = r2.getSelectedElement();
            if (!s2)
              return;
            const a2 = e2.editing.mapper.toViewElement(s2);
            Oh(a2) && n2.consumable.consume(r2, "selection") && o2.setSelection(o2.createRangeOn(a2), { fake: true, label: jh(a2) });
          }), this.editor.editing.downcastDispatcher.on("selection", (e3, t3, i3) => {
            this._clearPreviouslySelectedWidgets(i3.writer);
            const n2 = i3.writer, o2 = n2.document.selection;
            let r2 = null;
            for (const e4 of o2.getRanges())
              for (const t4 of e4) {
                const e5 = t4.item;
                Oh(e5) && !eu(e5, r2) && (n2.addClass("ck-widget_selected", e5), this._previouslySelected.add(e5), r2 = e5);
              }
          }, { priority: "low" }), t2.addObserver(uh), this.listenTo(i2, "mousedown", (...e3) => this._onMousedown(...e3)), this.listenTo(i2, "arrowKey", (...e3) => {
            this._handleSelectionChangeOnArrowKeyPress(...e3);
          }, { context: [Oh, "$text"] }), this.listenTo(i2, "arrowKey", (...e3) => {
            this._preventDefaultOnArrowKeyPress(...e3);
          }, { context: "$root" }), this.listenTo(i2, "arrowKey", Qh(this.editor.editing), { context: "$text" }), this.listenTo(i2, "delete", (e3, t3) => {
            this._handleDelete(t3.direction == "forward") && (t3.preventDefault(), e3.stop());
          }, { context: "$root" });
        }
        _onMousedown(e2, t2) {
          const i2 = this.editor, n2 = i2.editing.view, o2 = n2.document;
          let r2 = t2.target;
          if (function(e3) {
            for (; e3; ) {
              if (e3.is("editableElement") && !e3.is("rootElement"))
                return true;
              if (Oh(e3))
                return false;
              e3 = e3.parent;
            }
            return false;
          }(r2)) {
            if ((So.isSafari || So.isGecko) && t2.domEvent.detail >= 3) {
              const e3 = i2.editing.mapper, n3 = r2.is("attributeElement") ? r2.findAncestor((e4) => !e4.is("attributeElement")) : r2, o3 = e3.toModelElement(n3);
              t2.preventDefault(), this.editor.model.change((e4) => {
                e4.setSelection(o3, "in");
              });
            }
            return;
          }
          if (!Oh(r2) && (r2 = r2.findAncestor(Oh), !r2))
            return;
          So.isAndroid && t2.preventDefault(), o2.isFocused || n2.focus();
          const s2 = i2.editing.mapper.toModelElement(r2);
          this._setSelectionOverElement(s2);
        }
        _handleSelectionChangeOnArrowKeyPress(e2, t2) {
          const i2 = t2.keyCode, n2 = this.editor.model, o2 = n2.schema, r2 = n2.document.selection, s2 = r2.getSelectedElement(), a2 = Lo(i2, this.editor.locale.contentLanguageDirection), c2 = a2 == "down" || a2 == "right", l2 = a2 == "up" || a2 == "down";
          if (s2 && o2.isObject(s2)) {
            const i3 = c2 ? r2.getLastPosition() : r2.getFirstPosition(), s3 = o2.getNearestSelectionRange(i3, c2 ? "forward" : "backward");
            return void (s3 && (n2.change((e3) => {
              e3.setSelection(s3);
            }), t2.preventDefault(), e2.stop()));
          }
          if (!r2.isCollapsed && !t2.shiftKey) {
            const i3 = r2.getFirstPosition(), s3 = r2.getLastPosition(), a3 = i3.nodeAfter, l3 = s3.nodeBefore;
            return void ((a3 && o2.isObject(a3) || l3 && o2.isObject(l3)) && (n2.change((e3) => {
              e3.setSelection(c2 ? s3 : i3);
            }), t2.preventDefault(), e2.stop()));
          }
          if (!r2.isCollapsed)
            return;
          const d2 = this._getObjectElementNextToSelection(c2);
          if (d2 && o2.isObject(d2)) {
            if (o2.isInline(d2) && l2)
              return;
            this._setSelectionOverElement(d2), t2.preventDefault(), e2.stop();
          }
        }
        _preventDefaultOnArrowKeyPress(e2, t2) {
          const i2 = this.editor.model, n2 = i2.schema, o2 = i2.document.selection.getSelectedElement();
          o2 && n2.isObject(o2) && (t2.preventDefault(), e2.stop());
        }
        _handleDelete(e2) {
          if (this.editor.isReadOnly)
            return;
          const t2 = this.editor.model.document.selection;
          if (!t2.isCollapsed)
            return;
          const i2 = this._getObjectElementNextToSelection(e2);
          return i2 ? (this.editor.model.change((e3) => {
            let n2 = t2.anchor.parent;
            for (; n2.isEmpty; ) {
              const t3 = n2;
              n2 = t3.parent, e3.remove(t3);
            }
            this._setSelectionOverElement(i2);
          }), true) : void 0;
        }
        _setSelectionOverElement(e2) {
          this.editor.model.change((t2) => {
            t2.setSelection(t2.createRangeOn(e2));
          });
        }
        _getObjectElementNextToSelection(e2) {
          const t2 = this.editor.model, i2 = t2.schema, n2 = t2.document.selection, o2 = t2.createSelection(n2);
          if (t2.modifySelection(o2, { direction: e2 ? "forward" : "backward" }), o2.isEqual(n2))
            return null;
          const r2 = e2 ? o2.focus.nodeBefore : o2.focus.nodeAfter;
          return r2 && i2.isObject(r2) ? r2 : null;
        }
        _clearPreviouslySelectedWidgets(e2) {
          for (const t2 of this._previouslySelected)
            e2.removeClass("ck-widget_selected", t2);
          this._previouslySelected.clear();
        }
      }
      function eu(e2, t2) {
        return !!t2 && Array.from(e2.getAncestors()).includes(t2);
      }
      var tu = function(e2, t2, i2) {
        var n2 = true, o2 = true;
        if (typeof e2 != "function")
          throw new TypeError("Expected a function");
        return w(i2) && (n2 = "leading" in i2 ? !!i2.leading : n2, o2 = "trailing" in i2 ? !!i2.trailing : o2), ms(e2, t2, { leading: n2, maxWait: t2, trailing: o2 });
      };
      i(67);
      class iu extends Qe {
        static get pluginName() {
          return "DragDrop";
        }
        static get requires() {
          return [_h, Xh];
        }
        init() {
          const e2 = this.editor, t2 = e2.editing.view;
          this._draggedRange = null, this._draggingUid = "", this._draggableElement = null, this._updateDropMarkerThrottled = tu((e3) => this._updateDropMarker(e3), 40), this._removeDropMarkerDelayed = ru(() => this._removeDropMarker(), 40), this._clearDraggableAttributesDelayed = ru(() => this._clearDraggableAttributes(), 40), t2.addObserver(wh), t2.addObserver(uh), this._setupDragging(), this._setupContentInsertionIntegration(), this._setupClipboardInputIntegration(), this._setupDropMarker(), this._setupDraggableAttributeHandling(), this.listenTo(e2, "change:isReadOnly", (e3, t3, i2) => {
            i2 ? this.forceDisabled("readOnlyMode") : this.clearForceDisabled("readOnlyMode");
          }), this.on("change:isEnabled", (e3, t3, i2) => {
            i2 || this._finalizeDragging(false);
          }), So.isAndroid && this.forceDisabled("noAndroidSupport");
        }
        destroy() {
          return this._draggedRange && (this._draggedRange.detach(), this._draggedRange = null), this._updateDropMarkerThrottled.cancel(), this._removeDropMarkerDelayed.cancel(), this._clearDraggableAttributesDelayed.cancel(), super.destroy();
        }
        _setupDragging() {
          const e2 = this.editor, t2 = e2.model, i2 = t2.document, n2 = e2.editing.view, o2 = n2.document;
          this.listenTo(o2, "dragstart", (n3, r2) => {
            const a2 = i2.selection;
            if (r2.target && r2.target.is("editableElement"))
              return void r2.preventDefault();
            const c2 = r2.target ? su(r2.target) : null;
            if (c2) {
              const i3 = e2.editing.mapper.toModelElement(c2);
              this._draggedRange = pa.fromRange(t2.createRangeOn(i3)), e2.plugins.has("WidgetToolbarRepository") && e2.plugins.get("WidgetToolbarRepository").forceDisabled("dragDrop");
            } else if (!o2.selection.isCollapsed) {
              const e3 = o2.selection.getSelectedElement();
              e3 && Oh(e3) || (this._draggedRange = pa.fromRange(a2.getFirstRange()));
            }
            if (!this._draggedRange)
              return void r2.preventDefault();
            this._draggingUid = s(), r2.dataTransfer.effectAllowed = this.isEnabled ? "copyMove" : "copy", r2.dataTransfer.setData("application/ckeditor5-dragging-uid", this._draggingUid);
            const l2 = t2.createSelection(this._draggedRange.toRange()), d2 = e2.data.toView(t2.getSelectedContent(l2));
            o2.fire("clipboardOutput", { dataTransfer: r2.dataTransfer, content: d2, method: n3.name }), this.isEnabled || (this._draggedRange.detach(), this._draggedRange = null, this._draggingUid = "");
          }, { priority: "low" }), this.listenTo(o2, "dragend", (e3, t3) => {
            this._finalizeDragging(!t3.dataTransfer.isCanceled && t3.dataTransfer.dropEffect == "move");
          }, { priority: "low" }), this.listenTo(o2, "dragenter", () => {
            this.isEnabled && n2.focus();
          }), this.listenTo(o2, "dragleave", () => {
            this._removeDropMarkerDelayed();
          }), this.listenTo(o2, "dragging", (t3, i3) => {
            if (!this.isEnabled)
              return void (i3.dataTransfer.dropEffect = "none");
            this._removeDropMarkerDelayed.cancel();
            const n3 = nu(e2, i3.targetRanges, i3.target);
            this._draggedRange || (i3.dataTransfer.dropEffect = "copy"), So.isGecko || (i3.dataTransfer.effectAllowed == "copy" ? i3.dataTransfer.dropEffect = "copy" : ["all", "copyMove"].includes(i3.dataTransfer.effectAllowed) && (i3.dataTransfer.dropEffect = "move")), n3 && this._updateDropMarkerThrottled(n3);
          }, { priority: "low" });
        }
        _setupClipboardInputIntegration() {
          const e2 = this.editor, t2 = e2.editing.view.document;
          this.listenTo(t2, "clipboardInput", (t3, i2) => {
            if (i2.method != "drop")
              return;
            const n2 = nu(e2, i2.targetRanges, i2.target);
            if (this._removeDropMarker(), !n2)
              return this._finalizeDragging(false), void t3.stop();
            this._draggedRange && this._draggingUid != i2.dataTransfer.getData("application/ckeditor5-dragging-uid") && (this._draggedRange.detach(), this._draggedRange = null, this._draggingUid = "");
            if (ou(i2.dataTransfer) == "move" && this._draggedRange && this._draggedRange.containsRange(n2, true))
              return this._finalizeDragging(false), void t3.stop();
            i2.targetRanges = [e2.editing.mapper.toViewRange(n2)];
          }, { priority: "high" });
        }
        _setupContentInsertionIntegration() {
          const e2 = this.editor.plugins.get(_h);
          e2.on("contentInsertion", (e3, t2) => {
            if (!this.isEnabled || t2.method !== "drop")
              return;
            const i2 = t2.targetRanges.map((e4) => this.editor.editing.mapper.toModelRange(e4));
            this.editor.model.change((e4) => e4.setSelection(i2));
          }, { priority: "high" }), e2.on("contentInsertion", (e3, t2) => {
            if (!this.isEnabled || t2.method !== "drop")
              return;
            const i2 = ou(t2.dataTransfer) == "move", n2 = !t2.resultRange || !t2.resultRange.isCollapsed;
            this._finalizeDragging(n2 && i2);
          }, { priority: "lowest" });
        }
        _setupDraggableAttributeHandling() {
          const e2 = this.editor, t2 = e2.editing.view, i2 = t2.document;
          this.listenTo(i2, "mousedown", (n2, o2) => {
            if (So.isAndroid || !o2)
              return;
            this._clearDraggableAttributesDelayed.cancel();
            let r2 = su(o2.target);
            if (So.isBlink && !e2.isReadOnly && !r2 && !i2.selection.isCollapsed) {
              const e3 = i2.selection.getSelectedElement();
              e3 && Oh(e3) || (r2 = i2.selection.editableElement);
            }
            r2 && (t2.change((e3) => {
              e3.setAttribute("draggable", "true", r2);
            }), this._draggableElement = e2.editing.mapper.toModelElement(r2));
          }), this.listenTo(i2, "mouseup", () => {
            So.isAndroid || this._clearDraggableAttributesDelayed();
          });
        }
        _clearDraggableAttributes() {
          const e2 = this.editor.editing;
          e2.view.change((t2) => {
            this._draggableElement && this._draggableElement.root.rootName != "$graveyard" && t2.removeAttribute("draggable", e2.mapper.toViewElement(this._draggableElement)), this._draggableElement = null;
          });
        }
        _setupDropMarker() {
          const e2 = this.editor;
          e2.conversion.for("editingDowncast").markerToHighlight({ model: "drop-target", view: { classes: ["ck-clipboard-drop-target-range"] } }), e2.conversion.for("editingDowncast").markerToElement({ model: "drop-target", view: (t2, { writer: i2 }) => {
            if (e2.model.schema.checkChild(t2.markerRange.start, "$text"))
              return i2.createUIElement("span", { class: "ck ck-clipboard-drop-target-position" }, function(e3) {
                const t3 = this.toDomElement(e3);
                return t3.innerHTML = "&NoBreak;<span></span>&NoBreak;", t3;
              });
          } });
        }
        _updateDropMarker(e2) {
          const t2 = this.editor, i2 = t2.model.markers;
          t2.model.change((t3) => {
            i2.has("drop-target") ? i2.get("drop-target").getRange().isEqual(e2) || t3.updateMarker("drop-target", { range: e2 }) : t3.addMarker("drop-target", { range: e2, usingOperation: false, affectsData: false });
          });
        }
        _removeDropMarker() {
          const e2 = this.editor.model;
          this._removeDropMarkerDelayed.cancel(), this._updateDropMarkerThrottled.cancel(), e2.markers.has("drop-target") && e2.change((e3) => {
            e3.removeMarker("drop-target");
          });
        }
        _finalizeDragging(e2) {
          const t2 = this.editor, i2 = t2.model;
          this._removeDropMarker(), this._clearDraggableAttributes(), t2.plugins.has("WidgetToolbarRepository") && t2.plugins.get("WidgetToolbarRepository").clearForceDisabled("dragDrop"), this._draggingUid = "", this._draggedRange && (e2 && this.isEnabled && i2.deleteContent(i2.createSelection(this._draggedRange), { doNotAutoparagraph: true }), this._draggedRange.detach(), this._draggedRange = null);
        }
      }
      function nu(e2, t2, i2) {
        const n2 = e2.model, o2 = e2.editing.mapper;
        let r2 = null;
        const s2 = t2 ? t2[0].start : null;
        if (i2.is("uiElement") && (i2 = i2.parent), r2 = function(e3, t3) {
          const i3 = e3.model, n3 = e3.editing.mapper;
          if (Oh(t3))
            return i3.createRangeOn(n3.toModelElement(t3));
          if (!t3.is("editableElement")) {
            const e4 = t3.findAncestor((e5) => Oh(e5) || e5.is("editableElement"));
            if (Oh(e4))
              return i3.createRangeOn(n3.toModelElement(e4));
          }
          return null;
        }(e2, i2), r2)
          return r2;
        const a2 = function(e3, t3) {
          const i3 = e3.editing.mapper, n3 = e3.editing.view, o3 = i3.toModelElement(t3);
          if (o3)
            return o3;
          const r3 = n3.createPositionBefore(t3), s3 = i3.findMappedViewAncestor(r3);
          return i3.toModelElement(s3);
        }(e2, i2), c2 = s2 ? o2.toModelPosition(s2) : null;
        return c2 ? (r2 = function(e3, t3, i3) {
          const n3 = e3.model;
          if (!n3.schema.checkChild(i3, "$block"))
            return null;
          const o3 = n3.createPositionAt(i3, 0), r3 = t3.path.slice(0, o3.path.length), s3 = n3.createPositionFromPath(t3.root, r3).nodeAfter;
          if (s3 && n3.schema.isObject(s3))
            return n3.createRangeOn(s3);
          return null;
        }(e2, c2, a2), r2 || (r2 = n2.schema.getNearestSelectionRange(c2, So.isGecko ? "forward" : "backward"), r2 || function(e3, t3) {
          const i3 = e3.model;
          for (; t3; ) {
            if (i3.schema.isObject(t3))
              return i3.createRangeOn(t3);
            t3 = t3.parent;
          }
        }(e2, c2.parent))) : function(e3, t3) {
          const i3 = e3.model, n3 = i3.schema, o3 = i3.createPositionAt(t3, 0);
          return n3.getNearestSelectionRange(o3, "forward");
        }(e2, a2);
      }
      function ou(e2) {
        return So.isGecko ? e2.dropEffect : ["all", "copyMove"].includes(e2.effectAllowed) ? "move" : "copy";
      }
      function ru(e2, t2) {
        let i2;
        function n2(...o2) {
          n2.cancel(), i2 = setTimeout(() => e2(...o2), t2);
        }
        return n2.cancel = () => {
          clearTimeout(i2);
        }, n2;
      }
      function su(e2) {
        if (e2.is("editableElement"))
          return null;
        if (e2.hasClass("ck-widget__selection-handle"))
          return e2.findAncestor(Oh);
        if (Oh(e2))
          return e2;
        const t2 = e2.findAncestor((e3) => Oh(e3) || e3.is("editableElement"));
        return Oh(t2) ? t2 : null;
      }
      class au extends Qe {
        static get pluginName() {
          return "PastePlainText";
        }
        static get requires() {
          return [_h];
        }
        init() {
          const e2 = this.editor, t2 = e2.model, i2 = e2.editing.view, n2 = i2.document, o2 = t2.document.selection;
          let r2 = false;
          i2.addObserver(wh), this.listenTo(n2, "keydown", (e3, t3) => {
            r2 = t3.shiftKey;
          }), e2.plugins.get(_h).on("contentInsertion", (e3, i3) => {
            (r2 || function(e4, t3) {
              if (e4.childCount > 1)
                return false;
              const i4 = e4.getChild(0);
              if (t3.isObject(i4))
                return false;
              return [...i4.getAttributeKeys()].length == 0;
            }(i3.content, t2.schema)) && t2.change((e4) => {
              const n3 = Array.from(o2.getAttributes()).filter(([e5]) => t2.schema.getAttributeProperties(e5).isFormatting);
              o2.isCollapsed || t2.deleteContent(o2, { doNotAutoparagraph: true }), n3.push(...o2.getAttributes());
              const r3 = e4.createRangeIn(i3.content);
              for (const t3 of r3.getItems())
                t3.is("$textProxy") && e4.setAttributes(n3, t3);
            });
          });
        }
      }
      class cu extends Qe {
        static get pluginName() {
          return "Clipboard";
        }
        static get requires() {
          return [_h, iu, au];
        }
      }
      class lu extends Ze {
        execute() {
          const e2 = this.editor.model, t2 = e2.document;
          e2.change((i2) => {
            !function(e3, t3, i3) {
              const n2 = i3.isCollapsed, o2 = i3.getFirstRange(), r2 = o2.start.parent, s2 = o2.end.parent, a2 = r2 == s2;
              if (n2) {
                const n3 = vh(e3.schema, i3.getAttributes());
                du(e3, t3, o2.end), t3.removeSelectionAttribute(i3.getAttributeKeys()), t3.setSelectionAttribute(n3);
              } else {
                const n3 = !(o2.start.isAtStart && o2.end.isAtEnd);
                e3.deleteContent(i3, { leaveUnmerged: n3 }), a2 ? du(e3, t3, i3.focus) : n3 && t3.setSelection(s2, 0);
              }
            }(e2, i2, t2.selection), this.fire("afterExecute", { writer: i2 });
          });
        }
        refresh() {
          const e2 = this.editor.model, t2 = e2.document;
          this.isEnabled = function(e3, t3) {
            if (t3.rangeCount > 1)
              return false;
            const i2 = t3.anchor;
            if (!i2 || !e3.checkChild(i2, "softBreak"))
              return false;
            const n2 = t3.getFirstRange(), o2 = n2.start.parent, r2 = n2.end.parent;
            if ((hu(o2, e3) || hu(r2, e3)) && o2 !== r2)
              return false;
            return true;
          }(e2.schema, t2.selection);
        }
      }
      function du(e2, t2, i2) {
        const n2 = t2.createElement("softBreak");
        e2.insertContent(n2, i2), t2.setSelection(n2, "after");
      }
      function hu(e2, t2) {
        return !e2.is("rootElement") && (t2.isLimit(e2) || hu(e2.parent, t2));
      }
      class uu extends Qe {
        static get pluginName() {
          return "ShiftEnter";
        }
        init() {
          const e2 = this.editor, t2 = e2.model.schema, i2 = e2.conversion, n2 = e2.editing.view, o2 = n2.document;
          t2.register("softBreak", { allowWhere: "$text", isInline: true }), i2.for("upcast").elementToElement({ model: "softBreak", view: "br" }), i2.for("downcast").elementToElement({ model: "softBreak", view: (e3, { writer: t3 }) => t3.createEmptyElement("br") }), n2.addObserver(Ah), e2.commands.add("shiftEnter", new lu(e2)), this.listenTo(o2, "enter", (t3, i3) => {
            i3.preventDefault(), i3.isSoft && (e2.execute("shiftEnter"), n2.scrollToTheSelection());
          }, { priority: "low" });
        }
      }
      class gu extends Ze {
        execute() {
          const e2 = this.editor.model, t2 = e2.document.selection;
          let i2 = e2.schema.getLimitElement(t2);
          if (t2.containsEntireContent(i2) || !mu(e2.schema, i2))
            do {
              if (i2 = i2.parent, !i2)
                return;
            } while (!mu(e2.schema, i2));
          e2.change((e3) => {
            e3.setSelection(i2, "in");
          });
        }
      }
      function mu(e2, t2) {
        return e2.isLimit(t2) && (e2.checkChild(t2, "$text") || e2.checkChild(t2, "paragraph"));
      }
      const fu = zo("Ctrl+A");
      class pu extends Qe {
        static get pluginName() {
          return "SelectAllEditing";
        }
        init() {
          const e2 = this.editor, t2 = e2.editing.view.document;
          e2.commands.add("selectAll", new gu(e2)), this.listenTo(t2, "keydown", (t3, i2) => {
            Oo(i2) === fu && (e2.execute("selectAll"), i2.preventDefault());
          });
        }
      }
      class bu extends Qe {
        static get pluginName() {
          return "SelectAllUI";
        }
        init() {
          const e2 = this.editor;
          e2.ui.componentFactory.add("selectAll", (t2) => {
            const i2 = e2.commands.get("selectAll"), n2 = new td(t2), o2 = t2.t;
            return n2.set({ label: o2("Select all"), icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M.75 15.5a.75.75 0 0 1 .75.75V18l.008.09A.5.5 0 0 0 2 18.5h1.75a.75.75 0 1 1 0 1.5H1.5l-.144-.007a1.5 1.5 0 0 1-1.35-1.349L0 18.5v-2.25a.75.75 0 0 1 .75-.75zm18.5 0a.75.75 0 0 1 .75.75v2.25l-.007.144a1.5 1.5 0 0 1-1.349 1.35L18.5 20h-2.25a.75.75 0 1 1 0-1.5H18a.5.5 0 0 0 .492-.41L18.5 18v-1.75a.75.75 0 0 1 .75-.75zm-10.45 3c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm.45-5.5a.75.75 0 1 1 0 1.5h-8.5a.75.75 0 1 1 0-1.5h8.5zM1.3 11c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM1.3 7c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5h-2.5a.75.75 0 1 1 0-1.5h2.5zm-5 0a.75.75 0 1 1 0 1.5h-5.5a.75.75 0 0 1 0-1.5h5.5zm-6.5-5a.75.75 0 0 1 0 1.5H2a.5.5 0 0 0-.492.41L1.5 2v1.75a.75.75 0 0 1-1.5 0V1.5l.007-.144A1.5 1.5 0 0 1 1.356.006L1.5 0h2.25zM18.5 0l.144.007a1.5 1.5 0 0 1 1.35 1.349L20 1.5v2.25a.75.75 0 1 1-1.5 0V2l-.008-.09A.5.5 0 0 0 18 1.5h-1.75a.75.75 0 1 1 0-1.5h2.25zM8.8 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6z"/></svg>', keystroke: "Ctrl+A", tooltip: true }), n2.bind("isOn", "isEnabled").to(i2, "value", "isEnabled"), this.listenTo(n2, "execute", () => {
              e2.execute("selectAll"), e2.editing.view.focus();
            }), n2;
          });
        }
      }
      class wu extends Qe {
        static get requires() {
          return [pu, bu];
        }
        static get pluginName() {
          return "SelectAll";
        }
      }
      class ku extends Ze {
        constructor(e2, t2) {
          super(e2), this._buffer = new Th(e2.model, t2), this._batches = new WeakSet();
        }
        get buffer() {
          return this._buffer;
        }
        destroy() {
          super.destroy(), this._buffer.destroy();
        }
        execute(e2 = {}) {
          const t2 = this.editor.model, i2 = t2.document, n2 = e2.text || "", o2 = n2.length, r2 = e2.range ? t2.createSelection(e2.range) : i2.selection, s2 = e2.resultRange;
          t2.enqueueChange(this._buffer.batch, (e3) => {
            this._buffer.lock(), this._batches.add(this._buffer.batch), t2.deleteContent(r2), n2 && t2.insertContent(e3.createText(n2, i2.selection.getAttributes()), r2), s2 ? e3.setSelection(s2) : r2.is("documentSelection") || e3.setSelection(r2), this._buffer.unlock(), this._buffer.input(o2);
          });
        }
      }
      function _u(e2) {
        if (e2.newChildren.length - e2.oldChildren.length != 1)
          return;
        const t2 = function(e3, t3) {
          const i3 = [];
          let n2, o2 = 0;
          return e3.forEach((e4) => {
            e4 == "equal" ? (r2(), o2++) : e4 == "insert" ? (s2("insert") ? n2.values.push(t3[o2]) : (r2(), n2 = { type: "insert", index: o2, values: [t3[o2]] }), o2++) : s2("delete") ? n2.howMany++ : (r2(), n2 = { type: "delete", index: o2, howMany: 1 });
          }), r2(), i3;
          function r2() {
            n2 && (i3.push(n2), n2 = null);
          }
          function s2(e4) {
            return n2 && n2.type == e4;
          }
        }(ur(e2.oldChildren, e2.newChildren, vu), e2.newChildren);
        if (t2.length > 1)
          return;
        const i2 = t2[0];
        return i2.values[0] && i2.values[0].is("$text") ? i2 : void 0;
      }
      function vu(e2, t2) {
        return e2 && e2.is("$text") && t2 && t2.is("$text") ? e2.data === t2.data : e2 === t2;
      }
      class yu {
        constructor(e2) {
          this.editor = e2, this.editing = this.editor.editing;
        }
        handle(e2, t2) {
          if (function(e3) {
            if (e3.length == 0)
              return false;
            for (const t3 of e3)
              if (t3.type === "children" && !_u(t3))
                return true;
            return false;
          }(e2))
            this._handleContainerChildrenMutations(e2, t2);
          else
            for (const i2 of e2)
              this._handleTextMutation(i2, t2), this._handleTextNodeInsertion(i2);
        }
        _handleContainerChildrenMutations(e2, t2) {
          const i2 = function(e3) {
            const t3 = e3.map((e4) => e4.node).reduce((e4, t4) => e4.getCommonAncestor(t4, { includeSelf: true }));
            if (!t3)
              return;
            return t3.getAncestors({ includeSelf: true, parentFirst: true }).find((e4) => e4.is("containerElement") || e4.is("rootElement"));
          }(e2);
          if (!i2)
            return;
          const n2 = this.editor.editing.view.domConverter.mapViewToDom(i2), o2 = new Tr(this.editor.editing.view.document), r2 = this.editor.data.toModel(o2.domToView(n2)).getChild(0), s2 = this.editor.editing.mapper.toModelElement(i2);
          if (!s2)
            return;
          const a2 = Array.from(r2.getChildren()), c2 = Array.from(s2.getChildren()), l2 = a2[a2.length - 1], d2 = c2[c2.length - 1], h2 = l2 && l2.is("element", "softBreak"), u2 = d2 && !d2.is("element", "softBreak");
          h2 && u2 && a2.pop();
          const g2 = this.editor.model.schema;
          if (!xu(a2, g2) || !xu(c2, g2))
            return;
          const m2 = a2.map((e3) => e3.is("$text") ? e3.data : "@").join("").replace(/\u00A0/g, " "), f2 = c2.map((e3) => e3.is("$text") ? e3.data : "@").join("").replace(/\u00A0/g, " ");
          if (f2 === m2)
            return;
          const p2 = ur(f2, m2), { firstChangeAt: b2, insertions: w2, deletions: k2 } = Au(p2);
          let _2 = null;
          t2 && (_2 = this.editing.mapper.toModelRange(t2.getFirstRange()));
          const v2 = m2.substr(b2, w2), y2 = this.editor.model.createRange(this.editor.model.createPositionAt(s2, b2), this.editor.model.createPositionAt(s2, b2 + k2));
          this.editor.execute("input", { text: v2, range: y2, resultRange: _2 });
        }
        _handleTextMutation(e2, t2) {
          if (e2.type != "text")
            return;
          const i2 = e2.newText.replace(/\u00A0/g, " "), n2 = e2.oldText.replace(/\u00A0/g, " ");
          if (n2 === i2)
            return;
          const o2 = ur(n2, i2), { firstChangeAt: r2, insertions: s2, deletions: a2 } = Au(o2);
          let c2 = null;
          t2 && (c2 = this.editing.mapper.toModelRange(t2.getFirstRange()));
          const l2 = this.editing.view.createPositionAt(e2.node, r2), d2 = this.editing.mapper.toModelPosition(l2), h2 = this.editor.model.createRange(d2, d2.getShiftedBy(a2)), u2 = i2.substr(r2, s2);
          this.editor.execute("input", { text: u2, range: h2, resultRange: c2 });
        }
        _handleTextNodeInsertion(e2) {
          if (e2.type != "children")
            return;
          const t2 = _u(e2), i2 = this.editing.view.createPositionAt(e2.node, t2.index), n2 = this.editing.mapper.toModelPosition(i2), o2 = t2.values[0].data;
          this.editor.execute("input", { text: o2.replace(/\u00A0/g, " "), range: this.editor.model.createRange(n2) });
        }
      }
      function xu(e2, t2) {
        return e2.every((e3) => t2.isInline(e3));
      }
      function Au(e2) {
        let t2 = null, i2 = null;
        for (let n3 = 0; n3 < e2.length; n3++) {
          e2[n3] != "equal" && (t2 = t2 === null ? n3 : t2, i2 = n3);
        }
        let n2 = 0, o2 = 0;
        for (let r2 = t2; r2 <= i2; r2++)
          e2[r2] != "insert" && n2++, e2[r2] != "delete" && o2++;
        return { insertions: o2, deletions: n2, firstChangeAt: t2 };
      }
      class Cu extends Qe {
        static get pluginName() {
          return "Input";
        }
        init() {
          const e2 = this.editor, t2 = new ku(e2, e2.config.get("typing.undoStep") || 20);
          e2.commands.add("input", t2), function(e3) {
            let t3 = null;
            const i2 = e3.model, n2 = e3.editing.view, o2 = e3.commands.get("input");
            function r2(e4) {
              const r3 = i2.document, a2 = n2.document.isComposing, c2 = t3 && t3.isEqual(r3.selection);
              t3 = null, o2.isEnabled && ($h(e4) || r3.selection.isCollapsed || a2 && e4.keyCode === 229 || !a2 && e4.keyCode === 229 && c2 || s2());
            }
            function s2() {
              const e4 = o2.buffer;
              e4.lock();
              const t4 = e4.batch;
              o2._batches.add(t4), i2.enqueueChange(t4, () => {
                i2.deleteContent(i2.document.selection);
              }), e4.unlock();
            }
            So.isAndroid ? n2.document.on("beforeinput", (e4, t4) => r2(t4), { priority: "lowest" }) : n2.document.on("keydown", (e4, t4) => r2(t4), { priority: "lowest" }), n2.document.on("compositionstart", function() {
              const e4 = i2.document, t4 = e4.selection.rangeCount !== 1 || e4.selection.getFirstRange().isFlat;
              if (e4.selection.isCollapsed || t4)
                return;
              s2();
            }, { priority: "lowest" }), n2.document.on("compositionend", () => {
              t3 = i2.createSelection(i2.document.selection);
            }, { priority: "lowest" });
          }(e2), function(e3) {
            e3.editing.view.document.on("mutations", (t3, i2, n2) => {
              new yu(e3).handle(i2, n2);
            });
          }(e2);
        }
        isInput(e2) {
          return this.editor.commands.get("input")._batches.has(e2);
        }
      }
      class Tu extends Qe {
        static get requires() {
          return [Cu, Sh];
        }
        static get pluginName() {
          return "Typing";
        }
      }
      function Eu(e2, t2) {
        let i2 = e2.start;
        return { text: Array.from(e2.getItems()).reduce((e3, n2) => n2.is("$text") || n2.is("$textProxy") ? e3 + n2.data : (i2 = t2.createPositionAfter(n2), ""), ""), range: t2.createRange(i2, e2.end) };
      }
      class Iu {
        constructor(e2, t2) {
          this.model = e2, this.testCallback = t2, this.hasMatch = false, this.set("isEnabled", true), this.on("change:isEnabled", () => {
            this.isEnabled ? this._startListening() : (this.stopListening(e2.document.selection), this.stopListening(e2.document));
          }), this._startListening();
        }
        _startListening() {
          const e2 = this.model.document;
          this.listenTo(e2.selection, "change:range", (t2, { directChange: i2 }) => {
            i2 && (e2.selection.isCollapsed ? this._evaluateTextBeforeSelection("selection") : this.hasMatch && (this.fire("unmatched"), this.hasMatch = false));
          }), this.listenTo(e2, "change:data", (e3, t2) => {
            t2.type != "transparent" && this._evaluateTextBeforeSelection("data", { batch: t2 });
          });
        }
        _evaluateTextBeforeSelection(e2, t2 = {}) {
          const i2 = this.model, n2 = i2.document.selection, o2 = i2.createRange(i2.createPositionAt(n2.focus.parent, 0), n2.focus), { text: r2, range: s2 } = Eu(o2, i2), a2 = this.testCallback(r2);
          if (!a2 && this.hasMatch && this.fire("unmatched"), this.hasMatch = !!a2, a2) {
            const i3 = Object.assign(t2, { text: r2, range: s2 });
            typeof a2 == "object" && Object.assign(i3, a2), this.fire("matched:" + e2, i3);
          }
        }
      }
      Ke(Iu, Ue);
      class Su extends Qe {
        static get pluginName() {
          return "TwoStepCaretMovement";
        }
        constructor(e2) {
          super(e2), this.attributes = new Set(), this._overrideUid = null;
        }
        init() {
          const e2 = this.editor, t2 = e2.model, i2 = e2.editing.view, n2 = e2.locale, o2 = t2.document.selection;
          this.listenTo(i2.document, "arrowKey", (e3, t3) => {
            if (!o2.isCollapsed)
              return;
            if (t3.shiftKey || t3.altKey || t3.ctrlKey)
              return;
            const i3 = t3.keyCode == No.arrowright, r2 = t3.keyCode == No.arrowleft;
            if (!i3 && !r2)
              return;
            const s2 = n2.contentLanguageDirection;
            let a2 = false;
            a2 = s2 === "ltr" && i3 || s2 === "rtl" && r2 ? this._handleForwardMovement(t3) : this._handleBackwardMovement(t3), a2 === true && e3.stop();
          }, { context: "$text", priority: "highest" }), this._isNextGravityRestorationSkipped = false, this.listenTo(o2, "change:range", (e3, t3) => {
            this._isNextGravityRestorationSkipped ? this._isNextGravityRestorationSkipped = false : this._isGravityOverridden && (!t3.directChange && Ru(o2.getFirstPosition(), this.attributes) || this._restoreGravity());
          });
        }
        registerAttribute(e2) {
          this.attributes.add(e2);
        }
        _handleForwardMovement(e2) {
          const t2 = this.attributes, i2 = this.editor.model.document.selection, n2 = i2.getFirstPosition();
          return !this._isGravityOverridden && ((!n2.isAtStart || !Pu(i2, t2)) && (Ru(n2, t2) ? (Nu(e2), this._overrideGravity(), true) : void 0));
        }
        _handleBackwardMovement(e2) {
          const t2 = this.attributes, i2 = this.editor.model, n2 = i2.document.selection, o2 = n2.getFirstPosition();
          return this._isGravityOverridden ? (Nu(e2), this._restoreGravity(), Mu(i2, t2, o2), true) : o2.isAtStart ? !!Pu(n2, t2) && (Nu(e2), Mu(i2, t2, o2), true) : function(e3, t3) {
            return Ru(e3.getShiftedBy(-1), t3);
          }(o2, t2) ? o2.isAtEnd && !Pu(n2, t2) && Ru(o2, t2) ? (Nu(e2), Mu(i2, t2, o2), true) : (this._isNextGravityRestorationSkipped = true, this._overrideGravity(), false) : void 0;
        }
        get _isGravityOverridden() {
          return !!this._overrideUid;
        }
        _overrideGravity() {
          this._overrideUid = this.editor.model.change((e2) => e2.overrideSelectionGravity());
        }
        _restoreGravity() {
          this.editor.model.change((e2) => {
            e2.restoreSelectionGravity(this._overrideUid), this._overrideUid = null;
          });
        }
      }
      function Pu(e2, t2) {
        for (const i2 of t2)
          if (e2.hasAttribute(i2))
            return true;
        return false;
      }
      function Mu(e2, t2, i2) {
        const n2 = i2.nodeBefore;
        e2.change((e3) => {
          n2 ? e3.setSelectionAttribute(n2.getAttributes()) : e3.removeSelectionAttribute(t2);
        });
      }
      function Nu(e2) {
        e2.preventDefault();
      }
      function Ru(e2, t2) {
        const { nodeBefore: i2, nodeAfter: n2 } = e2;
        for (const e3 of t2) {
          const t3 = i2 ? i2.getAttribute(e3) : void 0;
          if ((n2 ? n2.getAttribute(e3) : void 0) !== t3)
            return true;
        }
        return false;
      }
      var Ou = /[\\^$.*+?()[\]{}|]/g, zu = RegExp(Ou.source);
      var Du = function(e2) {
        return (e2 = Pn(e2)) && zu.test(e2) ? e2.replace(Ou, "\\$&") : e2;
      };
      const Lu = { copyright: { from: "(c)", to: "\xA9" }, registeredTrademark: { from: "(r)", to: "\xAE" }, trademark: { from: "(tm)", to: "\u2122" }, oneHalf: { from: /(^|[^/a-z0-9])(1\/2)([^/a-z0-9])$/i, to: [null, "\xBD", null] }, oneThird: { from: /(^|[^/a-z0-9])(1\/3)([^/a-z0-9])$/i, to: [null, "\u2153", null] }, twoThirds: { from: /(^|[^/a-z0-9])(2\/3)([^/a-z0-9])$/i, to: [null, "\u2154", null] }, oneForth: { from: /(^|[^/a-z0-9])(1\/4)([^/a-z0-9])$/i, to: [null, "\xBC", null] }, threeQuarters: { from: /(^|[^/a-z0-9])(3\/4)([^/a-z0-9])$/i, to: [null, "\xBE", null] }, lessThanOrEqual: { from: "<=", to: "\u2264" }, greaterThanOrEqual: { from: ">=", to: "\u2265" }, notEqual: { from: "!=", to: "\u2260" }, arrowLeft: { from: "<-", to: "\u2190" }, arrowRight: { from: "->", to: "\u2192" }, horizontalEllipsis: { from: "...", to: "\u2026" }, enDash: { from: /(^| )(--)( )$/, to: [null, "\u2013", null] }, emDash: { from: /(^| )(---)( )$/, to: [null, "\u2014", null] }, quotesPrimary: { from: Uu('"'), to: [null, "\u201C", null, "\u201D"] }, quotesSecondary: { from: Uu("'"), to: [null, "\u2018", null, "\u2019"] }, quotesPrimaryEnGb: { from: Uu("'"), to: [null, "\u2018", null, "\u2019"] }, quotesSecondaryEnGb: { from: Uu('"'), to: [null, "\u201C", null, "\u201D"] }, quotesPrimaryPl: { from: Uu('"'), to: [null, "\u201E", null, "\u201D"] }, quotesSecondaryPl: { from: Uu("'"), to: [null, "\u201A", null, "\u2019"] } }, Vu = { symbols: ["copyright", "registeredTrademark", "trademark"], mathematical: ["oneHalf", "oneThird", "twoThirds", "oneForth", "threeQuarters", "lessThanOrEqual", "greaterThanOrEqual", "notEqual", "arrowLeft", "arrowRight"], typography: ["horizontalEllipsis", "enDash", "emDash"], quotes: ["quotesPrimary", "quotesSecondary"] }, ju = ["symbols", "mathematical", "typography", "quotes"];
      function Bu(e2) {
        return typeof e2 == "string" ? new RegExp(`(${Du(e2)})$`) : e2;
      }
      function Fu(e2) {
        return typeof e2 == "string" ? () => [e2] : e2 instanceof Array ? () => e2 : e2;
      }
      function Hu(e2) {
        return (e2.textNode ? e2.textNode : e2.nodeAfter).getAttributes();
      }
      function Uu(e2) {
        return new RegExp(`(^|\\s)(${e2})([^${e2}]*)(${e2})$`);
      }
      function Wu(e2, t2, i2, n2) {
        return n2.createRange(qu(e2, t2, i2, true, n2), qu(e2, t2, i2, false, n2));
      }
      function qu(e2, t2, i2, n2, o2) {
        let r2 = e2.textNode || (n2 ? e2.nodeBefore : e2.nodeAfter), s2 = null;
        for (; r2 && r2.getAttribute(t2) == i2; )
          s2 = r2, r2 = n2 ? r2.previousSibling : r2.nextSibling;
        return s2 ? o2.createPositionAt(s2, n2 ? "before" : "after") : e2;
      }
      class $u extends Ze {
        constructor(e2) {
          super(e2), this._stack = [], this._createdBatches = new WeakSet(), this.refresh(), this.listenTo(e2.data, "set", (e3, t2) => {
            t2[1] = __spreadValues({}, t2[1]);
            const i2 = t2[1];
            i2.batchType || (i2.batchType = "transparent");
          }, { priority: "high" }), this.listenTo(e2.data, "set", (e3, t2) => {
            t2[1].batchType === "transparent" && this.clearStack();
          });
        }
        refresh() {
          this.isEnabled = this._stack.length > 0;
        }
        addBatch(e2) {
          const t2 = this.editor.model.document.selection, i2 = { ranges: t2.hasOwnRange ? Array.from(t2.getRanges()) : [], isBackward: t2.isBackward };
          this._stack.push({ batch: e2, selection: i2 }), this.refresh();
        }
        clearStack() {
          this._stack = [], this.refresh();
        }
        _restoreSelection(e2, t2, i2) {
          const n2 = this.editor.model, o2 = n2.document, r2 = [], s2 = e2.map((e3) => e3.getTransformedByOperations(i2)), a2 = s2.flat();
          for (const e3 of s2) {
            const t3 = e3.filter((e4) => e4.root != o2.graveyard).filter((e4) => !Gu(e4, a2));
            t3.length && (Yu(t3), r2.push(t3[0]));
          }
          r2.length && n2.change((e3) => {
            e3.setSelection(r2, { backward: t2 });
          });
        }
        _undo(e2, t2) {
          const i2 = this.editor.model, n2 = i2.document;
          this._createdBatches.add(t2);
          const o2 = e2.operations.slice().filter((e3) => e3.isDocumentOperation);
          o2.reverse();
          for (const e3 of o2) {
            const o3 = e3.baseVersion + 1, r2 = Array.from(n2.history.getOperations(o3)), s2 = oh([e3.getReversed()], r2, { useRelations: true, document: this.editor.model.document, padWithNoOps: false, forceWeakRemove: true }).operationsA;
            for (const o4 of s2)
              t2.addOperation(o4), i2.applyOperation(o4), n2.history.setOperationAsUndone(e3, o4);
          }
        }
      }
      function Yu(e2) {
        e2.sort((e3, t2) => e3.start.isBefore(t2.start) ? -1 : 1);
        for (let t2 = 1; t2 < e2.length; t2++) {
          const i2 = e2[t2 - 1].getJoined(e2[t2], true);
          i2 && (t2--, e2.splice(t2, 2, i2));
        }
      }
      function Gu(e2, t2) {
        return t2.some((t3) => t3 !== e2 && t3.containsRange(e2, true));
      }
      class Ku extends $u {
        execute(e2 = null) {
          const t2 = e2 ? this._stack.findIndex((t3) => t3.batch == e2) : this._stack.length - 1, i2 = this._stack.splice(t2, 1)[0], n2 = this.editor.model.createBatch("transparent");
          this.editor.model.enqueueChange(n2, () => {
            this._undo(i2.batch, n2);
            const e3 = this.editor.model.document.history.getOperations(i2.batch.baseVersion);
            this._restoreSelection(i2.selection.ranges, i2.selection.isBackward, e3), this.fire("revert", i2.batch, n2);
          }), this.refresh();
        }
      }
      class Qu extends $u {
        execute() {
          const e2 = this._stack.pop(), t2 = this.editor.model.createBatch("transparent");
          this.editor.model.enqueueChange(t2, () => {
            const i2 = e2.batch.operations[e2.batch.operations.length - 1].baseVersion + 1, n2 = this.editor.model.document.history.getOperations(i2);
            this._restoreSelection(e2.selection.ranges, e2.selection.isBackward, n2), this._undo(e2.batch, t2);
          }), this.refresh();
        }
      }
      class Ju extends Qe {
        static get pluginName() {
          return "UndoEditing";
        }
        constructor(e2) {
          super(e2), this._batchRegistry = new WeakSet();
        }
        init() {
          const e2 = this.editor;
          this._undoCommand = new Ku(e2), this._redoCommand = new Qu(e2), e2.commands.add("undo", this._undoCommand), e2.commands.add("redo", this._redoCommand), this.listenTo(e2.model, "applyOperation", (e3, t2) => {
            const i2 = t2[0];
            if (!i2.isDocumentOperation)
              return;
            const n2 = i2.batch, o2 = this._redoCommand._createdBatches.has(n2), r2 = this._undoCommand._createdBatches.has(n2);
            this._batchRegistry.has(n2) || n2.type == "transparent" && !o2 && !r2 || (o2 ? this._undoCommand.addBatch(n2) : r2 || (this._undoCommand.addBatch(n2), this._redoCommand.clearStack()), this._batchRegistry.add(n2));
          }, { priority: "highest" }), this.listenTo(this._undoCommand, "revert", (e3, t2, i2) => {
            this._redoCommand.addBatch(i2);
          }), e2.keystrokes.set("CTRL+Z", "undo"), e2.keystrokes.set("CTRL+Y", "redo"), e2.keystrokes.set("CTRL+SHIFT+Z", "redo");
        }
      }
      var Zu = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m5.042 9.367 2.189 1.837a.75.75 0 0 1-.965 1.149l-3.788-3.18a.747.747 0 0 1-.21-.284.75.75 0 0 1 .17-.945L6.23 4.762a.75.75 0 1 1 .964 1.15L4.863 7.866h8.917A.75.75 0 0 1 14 7.9a4 4 0 1 1-1.477 7.718l.344-1.489a2.5 2.5 0 1 0 1.094-4.73l.008-.032H5.042z"/></svg>', Xu = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m14.958 9.367-2.189 1.837a.75.75 0 0 0 .965 1.149l3.788-3.18a.747.747 0 0 0 .21-.284.75.75 0 0 0-.17-.945L13.77 4.762a.75.75 0 1 0-.964 1.15l2.331 1.955H6.22A.75.75 0 0 0 6 7.9a4 4 0 1 0 1.477 7.718l-.344-1.489A2.5 2.5 0 1 1 6.039 9.4l-.008-.032h8.927z"/></svg>';
      class eg extends Qe {
        static get pluginName() {
          return "UndoUI";
        }
        init() {
          const e2 = this.editor, t2 = e2.locale, i2 = e2.t, n2 = t2.uiLanguageDirection == "ltr" ? Zu : Xu, o2 = t2.uiLanguageDirection == "ltr" ? Xu : Zu;
          this._addButton("undo", i2("Undo"), "CTRL+Z", n2), this._addButton("redo", i2("Redo"), "CTRL+Y", o2);
        }
        _addButton(e2, t2, i2, n2) {
          const o2 = this.editor;
          o2.ui.componentFactory.add(e2, (r2) => {
            const s2 = o2.commands.get(e2), a2 = new td(r2);
            return a2.set({ label: t2, icon: n2, keystroke: i2, tooltip: true }), a2.bind("isEnabled").to(s2, "isEnabled"), this.listenTo(a2, "execute", () => {
              o2.execute(e2), o2.editing.view.focus();
            }), a2;
          });
        }
      }
      class tg extends Qe {
        static get requires() {
          return [Ju, eg];
        }
        static get pluginName() {
          return "Undo";
        }
      }
      class ig {
        constructor() {
          const e2 = new window.FileReader();
          this._reader = e2, this._data = void 0, this.set("loaded", 0), e2.onprogress = (e3) => {
            this.loaded = e3.loaded;
          };
        }
        get error() {
          return this._reader.error;
        }
        get data() {
          return this._data;
        }
        read(e2) {
          const t2 = this._reader;
          return this.total = e2.size, new Promise((i2, n2) => {
            t2.onload = () => {
              const e3 = t2.result;
              this._data = e3, i2(e3);
            }, t2.onerror = () => {
              n2("error");
            }, t2.onabort = () => {
              n2("aborted");
            }, this._reader.readAsDataURL(e2);
          });
        }
        abort() {
          this._reader.abort();
        }
      }
      Ke(ig, Ue);
      class ng extends Qe {
        static get pluginName() {
          return "FileRepository";
        }
        static get requires() {
          return [Al];
        }
        init() {
          this.loaders = new Zi(), this.loaders.on("add", () => this._updatePendingAction()), this.loaders.on("remove", () => this._updatePendingAction()), this._loadersMap = new Map(), this._pendingAction = null, this.set("uploaded", 0), this.set("uploadTotal", null), this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", (e2, t2) => t2 ? e2 / t2 * 100 : 0);
        }
        getLoader(e2) {
          return this._loadersMap.get(e2) || null;
        }
        createLoader(e2) {
          if (!this.createUploadAdapter)
            return Object(c.b)("filerepository-no-upload-adapter"), null;
          const t2 = new og(Promise.resolve(e2), this.createUploadAdapter);
          return this.loaders.add(t2), this._loadersMap.set(e2, t2), e2 instanceof Promise && t2.file.then((e3) => {
            this._loadersMap.set(e3, t2);
          }).catch(() => {
          }), t2.on("change:uploaded", () => {
            let e3 = 0;
            for (const t3 of this.loaders)
              e3 += t3.uploaded;
            this.uploaded = e3;
          }), t2.on("change:uploadTotal", () => {
            let e3 = 0;
            for (const t3 of this.loaders)
              t3.uploadTotal && (e3 += t3.uploadTotal);
            this.uploadTotal = e3;
          }), t2;
        }
        destroyLoader(e2) {
          const t2 = e2 instanceof og ? e2 : this.getLoader(e2);
          t2._destroy(), this.loaders.remove(t2), this._loadersMap.forEach((e3, i2) => {
            e3 === t2 && this._loadersMap.delete(i2);
          });
        }
        _updatePendingAction() {
          const e2 = this.editor.plugins.get(Al);
          if (this.loaders.length) {
            if (!this._pendingAction) {
              const t2 = this.editor.t, i2 = (e3) => `${t2("Upload in progress")} ${parseInt(e3)}%.`;
              this._pendingAction = e2.add(i2(this.uploadedPercent)), this._pendingAction.bind("message").to(this, "uploadedPercent", i2);
            }
          } else
            e2.remove(this._pendingAction), this._pendingAction = null;
        }
      }
      Ke(ng, Ue);
      class og {
        constructor(e2, t2) {
          this.id = s(), this._filePromiseWrapper = this._createFilePromiseWrapper(e2), this._adapter = t2(this), this._reader = new ig(), this.set("status", "idle"), this.set("uploaded", 0), this.set("uploadTotal", null), this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", (e3, t3) => t3 ? e3 / t3 * 100 : 0), this.set("uploadResponse", null);
        }
        get file() {
          return this._filePromiseWrapper ? this._filePromiseWrapper.promise.then((e2) => this._filePromiseWrapper ? e2 : null) : Promise.resolve(null);
        }
        get data() {
          return this._reader.data;
        }
        read() {
          if (this.status != "idle")
            throw new c.a("filerepository-read-wrong-status", this);
          return this.status = "reading", this.file.then((e2) => this._reader.read(e2)).then((e2) => {
            if (this.status !== "reading")
              throw this.status;
            return this.status = "idle", e2;
          }).catch((e2) => {
            if (e2 === "aborted")
              throw this.status = "aborted", "aborted";
            throw this.status = "error", this._reader.error ? this._reader.error : e2;
          });
        }
        upload() {
          if (this.status != "idle")
            throw new c.a("filerepository-upload-wrong-status", this);
          return this.status = "uploading", this.file.then(() => this._adapter.upload()).then((e2) => (this.uploadResponse = e2, this.status = "idle", e2)).catch((e2) => {
            if (this.status === "aborted")
              throw "aborted";
            throw this.status = "error", e2;
          });
        }
        abort() {
          const e2 = this.status;
          this.status = "aborted", this._filePromiseWrapper.isFulfilled ? e2 == "reading" ? this._reader.abort() : e2 == "uploading" && this._adapter.abort && this._adapter.abort() : (this._filePromiseWrapper.promise.catch(() => {
          }), this._filePromiseWrapper.rejecter("aborted")), this._destroy();
        }
        _destroy() {
          this._filePromiseWrapper = void 0, this._reader = void 0, this._adapter = void 0, this.uploadResponse = void 0;
        }
        _createFilePromiseWrapper(e2) {
          const t2 = {};
          return t2.promise = new Promise((i2, n2) => {
            t2.rejecter = n2, t2.isFulfilled = false, e2.then((e3) => {
              t2.isFulfilled = true, i2(e3);
            }).catch((e3) => {
              t2.isFulfilled = true, n2(e3);
            });
          }), t2;
        }
      }
      Ke(og, Ue);
      class rg extends Nl {
        constructor(e2) {
          super(e2), this.buttonView = new td(e2), this._fileInputView = new sg(e2), this._fileInputView.bind("acceptedType").to(this), this._fileInputView.bind("allowMultipleFiles").to(this), this._fileInputView.delegate("done").to(this), this.setTemplate({ tag: "span", attributes: { class: "ck-file-dialog-button" }, children: [this.buttonView, this._fileInputView] }), this.buttonView.on("execute", () => {
            this._fileInputView.open();
          });
        }
        focus() {
          this.buttonView.focus();
        }
      }
      class sg extends Nl {
        constructor(e2) {
          super(e2), this.set("acceptedType"), this.set("allowMultipleFiles", false);
          const t2 = this.bindTemplate;
          this.setTemplate({ tag: "input", attributes: { class: ["ck-hidden"], type: "file", tabindex: "-1", accept: t2.to("acceptedType"), multiple: t2.to("allowMultipleFiles") }, on: { change: t2.to(() => {
            this.element && this.element.files && this.element.files.length && this.fire("done", this.element.files), this.element.value = "";
          }) } });
        }
        open() {
          this.element.click();
        }
      }
      function ag() {
        let e2 = function(e3) {
          e3 = e3.toLowerCase();
          const t3 = document.cookie.split(";");
          for (const i3 of t3) {
            const t4 = i3.split("=");
            if (decodeURIComponent(t4[0].trim().toLowerCase()) === e3)
              return decodeURIComponent(t4[1]);
          }
          return null;
        }("ckCsrfToken");
        var t2, i2;
        return e2 && e2.length == 40 || (e2 = function(e3) {
          let t3 = "";
          const i3 = new Uint8Array(e3);
          window.crypto.getRandomValues(i3);
          for (let e4 = 0; e4 < i3.length; e4++) {
            const n2 = "abcdefghijklmnopqrstuvwxyz0123456789".charAt(i3[e4] % "abcdefghijklmnopqrstuvwxyz0123456789".length);
            t3 += Math.random() > 0.5 ? n2.toUpperCase() : n2;
          }
          return t3;
        }(40), t2 = "ckCsrfToken", i2 = e2, document.cookie = encodeURIComponent(t2) + "=" + encodeURIComponent(i2) + ";path=/"), e2;
      }
      class cg {
        constructor(e2, t2, i2) {
          this.loader = e2, this.url = t2, this.t = i2;
        }
        upload() {
          return this.loader.file.then((e2) => new Promise((t2, i2) => {
            this._initRequest(), this._initListeners(t2, i2, e2), this._sendRequest(e2);
          }));
        }
        abort() {
          this.xhr && this.xhr.abort();
        }
        _initRequest() {
          const e2 = this.xhr = new XMLHttpRequest();
          e2.open("POST", this.url, true), e2.responseType = "json";
        }
        _initListeners(e2, t2, i2) {
          const n2 = this.xhr, o2 = this.loader, r2 = (0, this.t)("Cannot upload file:") + ` ${i2.name}.`;
          n2.addEventListener("error", () => t2(r2)), n2.addEventListener("abort", () => t2()), n2.addEventListener("load", () => {
            const i3 = n2.response;
            if (!i3 || !i3.uploaded)
              return t2(i3 && i3.error && i3.error.message ? i3.error.message : r2);
            e2({ default: i3.url });
          }), n2.upload && n2.upload.addEventListener("progress", (e3) => {
            e3.lengthComputable && (o2.uploadTotal = e3.total, o2.uploaded = e3.loaded);
          });
        }
        _sendRequest(e2) {
          const t2 = new FormData();
          t2.append("upload", e2), t2.append("ckCsrfToken", ag()), this.xhr.send(t2);
        }
      }
      function lg(e2, t2, i2, n2) {
        let o2, r2 = null;
        typeof n2 == "function" ? o2 = n2 : (r2 = e2.commands.get(n2), o2 = () => {
          e2.execute(n2);
        }), e2.model.document.on("change:data", (s2, a2) => {
          if (r2 && !r2.isEnabled || !t2.isEnabled)
            return;
          const c2 = Ms(e2.model.document.selection.getRanges());
          if (!c2.isCollapsed)
            return;
          if (a2.type == "transparent")
            return;
          const l2 = Array.from(e2.model.document.differ.getChanges()), d2 = l2[0];
          if (l2.length != 1 || d2.type !== "insert" || d2.name != "$text" || d2.length != 1)
            return;
          const h2 = d2.position.parent;
          if (h2.is("element", "codeBlock"))
            return;
          if (h2.is("element", "listItem") && typeof n2 != "function" && !["numberedList", "bulletedList", "todoList"].includes(n2))
            return;
          if (r2 && r2.value === true)
            return;
          const u2 = h2.getChild(0), g2 = e2.model.createRangeOn(u2);
          if (!g2.containsRange(c2) && !c2.end.isEqual(g2.end))
            return;
          const m2 = i2.exec(u2.data.substr(0, c2.end.offset));
          m2 && e2.model.enqueueChange((t3) => {
            const i3 = t3.createPositionAt(h2, 0), n3 = t3.createPositionAt(h2, m2[0].length), r3 = new pa(i3, n3);
            if (o2({ match: m2 }) !== false) {
              t3.remove(r3);
              const i4 = e2.model.document.selection.getFirstRange(), n4 = t3.createRangeIn(h2);
              !h2.isEmpty || n4.isEqual(i4) || n4.containsRange(i4, true) || t3.remove(h2);
            }
            r3.detach(), e2.model.enqueueChange(() => {
              e2.plugins.get("Delete").requestUndoOnBackspace();
            });
          });
        });
      }
      function dg(e2, t2, i2, n2) {
        let o2, r2;
        i2 instanceof RegExp ? o2 = i2 : r2 = i2, r2 = r2 || ((e3) => {
          let t3;
          const i3 = [], n3 = [];
          for (; (t3 = o2.exec(e3)) !== null && !(t3 && t3.length < 4); ) {
            let { index: e4, 1: o3, 2: r3, 3: s2 } = t3;
            const a2 = o3 + r3 + s2;
            e4 += t3[0].length - a2.length;
            const c2 = [e4, e4 + o3.length], l2 = [e4 + o3.length + r3.length, e4 + o3.length + r3.length + s2.length];
            i3.push(c2), i3.push(l2), n3.push([e4 + o3.length, e4 + o3.length + r3.length]);
          }
          return { remove: i3, format: n3 };
        }), e2.model.document.on("change:data", (i3, o3) => {
          if (o3.type == "transparent" || !t2.isEnabled)
            return;
          const s2 = e2.model, a2 = s2.document.selection;
          if (!a2.isCollapsed)
            return;
          const c2 = Array.from(s2.document.differ.getChanges()), l2 = c2[0];
          if (c2.length != 1 || l2.type !== "insert" || l2.name != "$text" || l2.length != 1)
            return;
          const d2 = a2.focus, h2 = d2.parent, { text: u2, range: g2 } = function(e3, t3) {
            let i4 = e3.start;
            return { text: Array.from(e3.getItems()).reduce((e4, n3) => !n3.is("$text") && !n3.is("$textProxy") || n3.getAttribute("code") ? (i4 = t3.createPositionAfter(n3), "") : e4 + n3.data, ""), range: t3.createRange(i4, e3.end) };
          }(s2.createRange(s2.createPositionAt(h2, 0), d2), s2), m2 = r2(u2), f2 = hg(g2.start, m2.format, s2), p2 = hg(g2.start, m2.remove, s2);
          f2.length && p2.length && s2.enqueueChange((t3) => {
            if (n2(t3, f2) !== false) {
              for (const e3 of p2.reverse())
                t3.remove(e3);
              s2.enqueueChange(() => {
                e2.plugins.get("Delete").requestUndoOnBackspace();
              });
            }
          });
        });
      }
      function hg(e2, t2, i2) {
        return t2.filter((e3) => e3[0] !== void 0 && e3[1] !== void 0).map((t3) => i2.createRange(e2.getShiftedBy(t3[0]), e2.getShiftedBy(t3[1])));
      }
      function ug(e2, t2) {
        return (i2, n2) => {
          if (!e2.commands.get(t2).isEnabled)
            return false;
          const o2 = e2.model.schema.getValidRanges(n2, t2);
          for (const e3 of o2)
            i2.setAttribute(t2, true, e3);
          i2.removeSelectionAttribute(t2);
        };
      }
      class gg extends Ze {
        constructor(e2, t2) {
          super(e2), this.attributeKey = t2;
        }
        refresh() {
          const e2 = this.editor.model, t2 = e2.document;
          this.value = this._getValueFromFirstAllowedNode(), this.isEnabled = e2.schema.checkAttributeInSelection(t2.selection, this.attributeKey);
        }
        execute(e2 = {}) {
          const t2 = this.editor.model, i2 = t2.document.selection, n2 = e2.forceValue === void 0 ? !this.value : e2.forceValue;
          t2.change((e3) => {
            if (i2.isCollapsed)
              n2 ? e3.setSelectionAttribute(this.attributeKey, true) : e3.removeSelectionAttribute(this.attributeKey);
            else {
              const o2 = t2.schema.getValidRanges(i2.getRanges(), this.attributeKey);
              for (const t3 of o2)
                n2 ? e3.setAttribute(this.attributeKey, n2, t3) : e3.removeAttribute(this.attributeKey, t3);
            }
          });
        }
        _getValueFromFirstAllowedNode() {
          const e2 = this.editor.model, t2 = e2.schema, i2 = e2.document.selection;
          if (i2.isCollapsed)
            return i2.hasAttribute(this.attributeKey);
          for (const e3 of i2.getRanges())
            for (const i3 of e3.getItems())
              if (t2.checkAttribute(i3, this.attributeKey))
                return i3.hasAttribute(this.attributeKey);
          return false;
        }
      }
      class mg extends Qe {
        static get pluginName() {
          return "BoldEditing";
        }
        init() {
          const e2 = this.editor;
          e2.model.schema.extend("$text", { allowAttributes: "bold" }), e2.model.schema.setAttributeProperties("bold", { isFormatting: true, copyOnEnter: true }), e2.conversion.attributeToElement({ model: "bold", view: "strong", upcastAlso: ["b", (e3) => {
            const t2 = e3.getStyle("font-weight");
            return t2 ? t2 == "bold" || Number(t2) >= 600 ? { name: true, styles: ["font-weight"] } : void 0 : null;
          }] }), e2.commands.add("bold", new gg(e2, "bold")), e2.keystrokes.set("CTRL+B", "bold");
        }
      }
      class fg extends Qe {
        static get pluginName() {
          return "BoldUI";
        }
        init() {
          const e2 = this.editor, t2 = e2.t;
          e2.ui.componentFactory.add("bold", (i2) => {
            const n2 = e2.commands.get("bold"), o2 = new td(i2);
            return o2.set({ label: t2("Bold"), icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.187 17H5.773c-.637 0-1.092-.138-1.364-.415-.273-.277-.409-.718-.409-1.323V4.738c0-.617.14-1.062.419-1.332.279-.27.73-.406 1.354-.406h4.68c.69 0 1.288.041 1.793.124.506.083.96.242 1.36.478.341.197.644.447.906.75a3.262 3.262 0 0 1 .808 2.162c0 1.401-.722 2.426-2.167 3.075C15.05 10.175 16 11.315 16 13.01a3.756 3.756 0 0 1-2.296 3.504 6.1 6.1 0 0 1-1.517.377c-.571.073-1.238.11-2 .11zm-.217-6.217H7v4.087h3.069c1.977 0 2.965-.69 2.965-2.072 0-.707-.256-1.22-.768-1.537-.512-.319-1.277-.478-2.296-.478zM7 5.13v3.619h2.606c.729 0 1.292-.067 1.69-.2a1.6 1.6 0 0 0 .91-.765c.165-.267.247-.566.247-.897 0-.707-.26-1.176-.778-1.409-.519-.232-1.31-.348-2.375-.348H7z"/></svg>', keystroke: "CTRL+B", tooltip: true, isToggleable: true }), o2.bind("isOn", "isEnabled").to(n2, "value", "isEnabled"), this.listenTo(o2, "execute", () => {
              e2.execute("bold"), e2.editing.view.focus();
            }), o2;
          });
        }
      }
      class pg extends Qe {
        static get pluginName() {
          return "ItalicEditing";
        }
        init() {
          const e2 = this.editor;
          e2.model.schema.extend("$text", { allowAttributes: "italic" }), e2.model.schema.setAttributeProperties("italic", { isFormatting: true, copyOnEnter: true }), e2.conversion.attributeToElement({ model: "italic", view: "i", upcastAlso: ["em", { styles: { "font-style": "italic" } }] }), e2.commands.add("italic", new gg(e2, "italic")), e2.keystrokes.set("CTRL+I", "italic");
        }
      }
      class bg extends Qe {
        static get pluginName() {
          return "ItalicUI";
        }
        init() {
          const e2 = this.editor, t2 = e2.t;
          e2.ui.componentFactory.add("italic", (i2) => {
            const n2 = e2.commands.get("italic"), o2 = new td(i2);
            return o2.set({ label: t2("Italic"), icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.586 14.633.021.004c-.036.335.095.655.393.962.082.083.173.15.274.201h1.474a.6.6 0 1 1 0 1.2H5.304a.6.6 0 0 1 0-1.2h1.15c.474-.07.809-.182 1.005-.334.157-.122.291-.32.404-.597l2.416-9.55a1.053 1.053 0 0 0-.281-.823 1.12 1.12 0 0 0-.442-.296H8.15a.6.6 0 0 1 0-1.2h6.443a.6.6 0 1 1 0 1.2h-1.195c-.376.056-.65.155-.823.296-.215.175-.423.439-.623.79l-2.366 9.347z"/></svg>', keystroke: "CTRL+I", tooltip: true, isToggleable: true }), o2.bind("isOn", "isEnabled").to(n2, "value", "isEnabled"), this.listenTo(o2, "execute", () => {
              e2.execute("italic"), e2.editing.view.focus();
            }), o2;
          });
        }
      }
      class wg extends Ze {
        refresh() {
          this.value = this._getValue(), this.isEnabled = this._checkEnabled();
        }
        execute(e2 = {}) {
          const t2 = this.editor.model, i2 = t2.schema, n2 = t2.document.selection, o2 = Array.from(n2.getSelectedBlocks()), r2 = e2.forceValue === void 0 ? !this.value : e2.forceValue;
          t2.change((e3) => {
            if (r2) {
              const t3 = o2.filter((e4) => kg(e4) || vg(i2, e4));
              this._applyQuote(e3, t3);
            } else
              this._removeQuote(e3, o2.filter(kg));
          });
        }
        _getValue() {
          const e2 = Ms(this.editor.model.document.selection.getSelectedBlocks());
          return !(!e2 || !kg(e2));
        }
        _checkEnabled() {
          if (this.value)
            return true;
          const e2 = this.editor.model.document.selection, t2 = this.editor.model.schema, i2 = Ms(e2.getSelectedBlocks());
          return !!i2 && vg(t2, i2);
        }
        _removeQuote(e2, t2) {
          _g(e2, t2).reverse().forEach((t3) => {
            if (t3.start.isAtStart && t3.end.isAtEnd)
              return void e2.unwrap(t3.start.parent);
            if (t3.start.isAtStart) {
              const i3 = e2.createPositionBefore(t3.start.parent);
              return void e2.move(t3, i3);
            }
            t3.end.isAtEnd || e2.split(t3.end);
            const i2 = e2.createPositionAfter(t3.end.parent);
            e2.move(t3, i2);
          });
        }
        _applyQuote(e2, t2) {
          const i2 = [];
          _g(e2, t2).reverse().forEach((t3) => {
            let n2 = kg(t3.start);
            n2 || (n2 = e2.createElement("blockQuote"), e2.wrap(t3, n2)), i2.push(n2);
          }), i2.reverse().reduce((t3, i3) => t3.nextSibling == i3 ? (e2.merge(e2.createPositionAfter(t3)), t3) : i3);
        }
      }
      function kg(e2) {
        return e2.parent.name == "blockQuote" ? e2.parent : null;
      }
      function _g(e2, t2) {
        let i2, n2 = 0;
        const o2 = [];
        for (; n2 < t2.length; ) {
          const r2 = t2[n2], s2 = t2[n2 + 1];
          i2 || (i2 = e2.createPositionBefore(r2)), s2 && r2.nextSibling == s2 || (o2.push(e2.createRange(i2, e2.createPositionAfter(r2))), i2 = null), n2++;
        }
        return o2;
      }
      function vg(e2, t2) {
        const i2 = e2.checkChild(t2.parent, "blockQuote"), n2 = e2.checkChild(["$root", "blockQuote"], t2);
        return i2 && n2;
      }
      class yg extends Qe {
        static get pluginName() {
          return "BlockQuoteEditing";
        }
        static get requires() {
          return [Ch, Sh];
        }
        init() {
          const e2 = this.editor, t2 = e2.model.schema;
          e2.commands.add("blockQuote", new wg(e2)), t2.register("blockQuote", { allowWhere: "$block", allowContentOf: "$root" }), e2.conversion.elementToElement({ model: "blockQuote", view: "blockquote" }), e2.model.document.registerPostFixer((i3) => {
            const n3 = e2.model.document.differ.getChanges();
            for (const e3 of n3)
              if (e3.type == "insert") {
                const n4 = e3.position.nodeAfter;
                if (!n4)
                  continue;
                if (n4.is("element", "blockQuote") && n4.isEmpty)
                  return i3.remove(n4), true;
                if (n4.is("element", "blockQuote") && !t2.checkChild(e3.position, n4))
                  return i3.unwrap(n4), true;
                if (n4.is("element")) {
                  const e4 = i3.createRangeIn(n4);
                  for (const n5 of e4.getItems())
                    if (n5.is("element", "blockQuote") && !t2.checkChild(i3.createPositionBefore(n5), n5))
                      return i3.unwrap(n5), true;
                }
              } else if (e3.type == "remove") {
                const t3 = e3.position.parent;
                if (t3.is("element", "blockQuote") && t3.isEmpty)
                  return i3.remove(t3), true;
              }
            return false;
          });
          const i2 = this.editor.editing.view.document, n2 = e2.model.document.selection, o2 = e2.commands.get("blockQuote");
          this.listenTo(i2, "enter", (t3, i3) => {
            if (!n2.isCollapsed || !o2.value)
              return;
            n2.getLastPosition().parent.isEmpty && (e2.execute("blockQuote"), e2.editing.view.scrollToTheSelection(), i3.preventDefault(), t3.stop());
          }, { context: "blockquote" }), this.listenTo(i2, "delete", (t3, i3) => {
            if (i3.direction != "backward" || !n2.isCollapsed || !o2.value)
              return;
            const r2 = n2.getLastPosition().parent;
            r2.isEmpty && !r2.previousSibling && (e2.execute("blockQuote"), e2.editing.view.scrollToTheSelection(), i3.preventDefault(), t3.stop());
          }, { context: "blockquote" });
        }
      }
      i(69);
      class xg extends Qe {
        static get pluginName() {
          return "BlockQuoteUI";
        }
        init() {
          const e2 = this.editor, t2 = e2.t;
          e2.ui.componentFactory.add("blockQuote", (i2) => {
            const n2 = e2.commands.get("blockQuote"), o2 = new td(i2);
            return o2.set({ label: t2("Block quote"), icon: El.quote, tooltip: true, isToggleable: true }), o2.bind("isOn", "isEnabled").to(n2, "value", "isEnabled"), this.listenTo(o2, "execute", () => {
              e2.execute("blockQuote"), e2.editing.view.focus();
            }), o2;
          });
        }
      }
      class Ag extends Qe {
        static get pluginName() {
          return "CKFinderUI";
        }
        init() {
          const e2 = this.editor, t2 = e2.ui.componentFactory, i2 = e2.t;
          t2.add("ckfinder", (t3) => {
            const n2 = e2.commands.get("ckfinder"), o2 = new td(t3);
            return o2.set({ label: i2("Insert image or file"), icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.627 16.5zm5.873-.196zm0-7.001V8h-13v8.5h4.341c.191.54.457 1.044.785 1.5H2a1.5 1.5 0 0 1-1.5-1.5v-13A1.5 1.5 0 0 1 2 2h4.5a1.5 1.5 0 0 1 1.06.44L9.122 4H16a1.5 1.5 0 0 1 1.5 1.5v1A1.5 1.5 0 0 1 19 8v2.531a6.027 6.027 0 0 0-1.5-1.228zM16 6.5v-1H8.5l-2-2H2v13h1V8a1.5 1.5 0 0 1 1.5-1.5H16z"/><path d="M14.5 19.5a5 5 0 1 1 0-10 5 5 0 0 1 0 10zM15 14v-2h-1v2h-2v1h2v2h1v-2h2v-1h-2z"/></svg>', tooltip: true }), o2.bind("isEnabled").to(n2), o2.on("execute", () => {
              e2.execute("ckfinder"), e2.editing.view.focus();
            }), o2;
          });
        }
      }
      class Cg extends Ze {
        constructor(e2) {
          super(e2), this.stopListening(this.editor.model.document, "change"), this.listenTo(this.editor.model.document, "change", () => this.refresh(), { priority: "low" });
        }
        refresh() {
          const e2 = this.editor.commands.get("insertImage"), t2 = this.editor.commands.get("link");
          this.isEnabled = e2.isEnabled || t2.isEnabled;
        }
        execute() {
          const e2 = this.editor, t2 = this.editor.config.get("ckfinder.openerMethod") || "modal";
          if (t2 != "popup" && t2 != "modal")
            throw new c.a("ckfinder-unknown-openermethod", e2);
          const i2 = this.editor.config.get("ckfinder.options") || {};
          i2.chooseFiles = true;
          const n2 = i2.onInit;
          i2.language || (i2.language = e2.locale.uiLanguage), i2.onInit = (t3) => {
            n2 && n2(t3), t3.on("files:choose", (i3) => {
              const n3 = i3.data.files.toArray(), o2 = n3.filter((e3) => !e3.isImage()), r2 = n3.filter((e3) => e3.isImage());
              for (const t4 of o2)
                e2.execute("link", t4.getUrl());
              const s2 = [];
              for (const e3 of r2) {
                const i4 = e3.getUrl();
                s2.push(i4 || t3.request("file:getProxyUrl", { file: e3 }));
              }
              s2.length && Tg(e2, s2);
            }), t3.on("file:choose:resizedImage", (t4) => {
              const i3 = t4.data.resizedUrl;
              if (i3)
                Tg(e2, [i3]);
              else {
                const t5 = e2.plugins.get("Notification"), i4 = e2.locale.t;
                t5.showWarning(i4("Could not obtain resized image URL."), { title: i4("Selecting resized image failed"), namespace: "ckfinder" });
              }
            });
          }, window.CKFinder[t2](i2);
        }
      }
      function Tg(e2, t2) {
        if (e2.commands.get("insertImage").isEnabled)
          e2.execute("insertImage", { source: t2 });
        else {
          const t3 = e2.plugins.get("Notification"), i2 = e2.locale.t;
          t3.showWarning(i2("Could not insert image at the current position."), { title: i2("Inserting image failed"), namespace: "ckfinder" });
        }
      }
      class Eg extends Qe {
        static get pluginName() {
          return "CKFinderEditing";
        }
        static get requires() {
          return [Od, "LinkEditing"];
        }
        init() {
          const e2 = this.editor;
          if (!e2.plugins.has("ImageBlockEditing") && !e2.plugins.has("ImageInlineEditing"))
            throw new c.a("ckfinder-missing-image-plugin", e2);
          e2.commands.add("ckfinder", new Cg(e2));
        }
      }
      class Ig extends Qe {
        static get pluginName() {
          return "CloudServicesUploadAdapter";
        }
        static get requires() {
          return ["CloudServices", ng];
        }
        init() {
          const e2 = this.editor, t2 = e2.plugins.get("CloudServices"), i2 = t2.token, n2 = t2.uploadUrl;
          i2 && (this._uploadGateway = e2.plugins.get("CloudServicesCore").createUploadGateway(i2, n2), e2.plugins.get(ng).createUploadAdapter = (e3) => new Sg(this._uploadGateway, e3));
        }
      }
      class Sg {
        constructor(e2, t2) {
          this.uploadGateway = e2, this.loader = t2;
        }
        upload() {
          return this.loader.file.then((e2) => (this.fileUploader = this.uploadGateway.upload(e2), this.fileUploader.on("progress", (e3, t2) => {
            this.loader.uploadTotal = t2.total, this.loader.uploaded = t2.uploaded;
          }), this.fileUploader.send()));
        }
        abort() {
          this.fileUploader.abort();
        }
      }
      class Pg extends Ze {
        refresh() {
          const e2 = this.editor.model, t2 = Ms(e2.document.selection.getSelectedBlocks());
          this.value = !!t2 && t2.is("element", "paragraph"), this.isEnabled = !!t2 && Mg(t2, e2.schema);
        }
        execute(e2 = {}) {
          const t2 = this.editor.model, i2 = t2.document;
          t2.change((n2) => {
            const o2 = (e2.selection || i2.selection).getSelectedBlocks();
            for (const e3 of o2)
              !e3.is("element", "paragraph") && Mg(e3, t2.schema) && n2.rename(e3, "paragraph");
          });
        }
      }
      function Mg(e2, t2) {
        return t2.checkChild(e2.parent, "paragraph") && !t2.isObject(e2);
      }
      class Ng extends Ze {
        execute(e2) {
          const t2 = this.editor.model;
          let i2 = e2.position;
          t2.change((e3) => {
            const n2 = e3.createElement("paragraph");
            if (!t2.schema.checkChild(i2.parent, n2)) {
              const o2 = t2.schema.findAllowedParent(i2, n2);
              if (!o2)
                return;
              i2 = e3.split(i2, o2).position;
            }
            t2.insertContent(n2, i2), e3.setSelection(n2, "in");
          });
        }
      }
      class Rg extends Qe {
        static get pluginName() {
          return "Paragraph";
        }
        init() {
          const e2 = this.editor, t2 = e2.model;
          e2.commands.add("paragraph", new Pg(e2)), e2.commands.add("insertParagraph", new Ng(e2)), t2.schema.register("paragraph", { inheritAllFrom: "$block" }), e2.conversion.elementToElement({ model: "paragraph", view: "p" }), e2.conversion.for("upcast").elementToElement({ model: (e3, { writer: t3 }) => Rg.paragraphLikeElements.has(e3.name) ? e3.isEmpty ? null : t3.createElement("paragraph") : null, view: /.+/, converterPriority: "low" });
        }
      }
      Rg.paragraphLikeElements = new Set(["blockquote", "dd", "div", "dt", "h1", "h2", "h3", "h4", "h5", "h6", "li", "p", "td", "th"]);
      class Og extends Ze {
        constructor(e2, t2) {
          super(e2), this.modelElements = t2;
        }
        refresh() {
          const e2 = Ms(this.editor.model.document.selection.getSelectedBlocks());
          this.value = !!e2 && this.modelElements.includes(e2.name) && e2.name, this.isEnabled = !!e2 && this.modelElements.some((t2) => zg(e2, t2, this.editor.model.schema));
        }
        execute(e2) {
          const t2 = this.editor.model, i2 = t2.document, n2 = e2.value;
          t2.change((e3) => {
            const o2 = Array.from(i2.selection.getSelectedBlocks()).filter((e4) => zg(e4, n2, t2.schema));
            for (const t3 of o2)
              t3.is("element", n2) || e3.rename(t3, n2);
          });
        }
      }
      function zg(e2, t2, i2) {
        return i2.checkChild(e2.parent, t2) && !i2.isObject(e2);
      }
      class Dg extends Qe {
        static get pluginName() {
          return "HeadingEditing";
        }
        constructor(e2) {
          super(e2), e2.config.define("heading", { options: [{ model: "paragraph", title: "Paragraph", class: "ck-heading_paragraph" }, { model: "heading1", view: "h2", title: "Heading 1", class: "ck-heading_heading1" }, { model: "heading2", view: "h3", title: "Heading 2", class: "ck-heading_heading2" }, { model: "heading3", view: "h4", title: "Heading 3", class: "ck-heading_heading3" }] });
        }
        static get requires() {
          return [Rg];
        }
        init() {
          const e2 = this.editor, t2 = e2.config.get("heading.options"), i2 = [];
          for (const n2 of t2)
            n2.model !== "paragraph" && (e2.model.schema.register(n2.model, { inheritAllFrom: "$block" }), e2.conversion.elementToElement(n2), i2.push(n2.model));
          this._addDefaultH1Conversion(e2), e2.commands.add("heading", new Og(e2, i2));
        }
        afterInit() {
          const e2 = this.editor, t2 = e2.commands.get("enter"), i2 = e2.config.get("heading.options");
          t2 && this.listenTo(t2, "afterExecute", (t3, n2) => {
            const o2 = e2.model.document.selection.getFirstPosition().parent;
            i2.some((e3) => o2.is("element", e3.model)) && !o2.is("element", "paragraph") && o2.childCount === 0 && n2.writer.rename(o2, "paragraph");
          });
        }
        _addDefaultH1Conversion(e2) {
          e2.conversion.for("upcast").elementToElement({ model: "heading1", view: "h1", converterPriority: a.get("low") + 1 });
        }
      }
      i(13);
      class Lg extends Qe {
        static get pluginName() {
          return "HeadingUI";
        }
        init() {
          const e2 = this.editor, t2 = e2.t, i2 = function(e3) {
            const t3 = e3.t, i3 = { Paragraph: t3("Paragraph"), "Heading 1": t3("Heading 1"), "Heading 2": t3("Heading 2"), "Heading 3": t3("Heading 3"), "Heading 4": t3("Heading 4"), "Heading 5": t3("Heading 5"), "Heading 6": t3("Heading 6") };
            return e3.config.get("heading.options").map((e4) => {
              const t4 = i3[e4.title];
              return t4 && t4 != e4.title && (e4.title = t4), e4;
            });
          }(e2), n2 = t2("Choose heading"), o2 = t2("Heading");
          e2.ui.componentFactory.add("heading", (t3) => {
            const r2 = {}, s2 = new Zi(), a2 = e2.commands.get("heading"), c2 = e2.commands.get("paragraph"), l2 = [a2];
            for (const e3 of i2) {
              const t4 = { type: "button", model: new zd({ label: e3.title, class: e3.class, withText: true }) };
              e3.model === "paragraph" ? (t4.model.bind("isOn").to(c2, "value"), t4.model.set("commandName", "paragraph"), l2.push(c2)) : (t4.model.bind("isOn").to(a2, "value", (t5) => t5 === e3.model), t4.model.set({ commandName: "heading", commandValue: e3.model })), s2.add(t4), r2[e3.model] = e3.title;
            }
            const d2 = xd(t3);
            return Cd(d2, s2), d2.buttonView.set({ isOn: false, withText: true, tooltip: o2 }), d2.extendTemplate({ attributes: { class: ["ck-heading-dropdown"] } }), d2.bind("isEnabled").toMany(l2, "isEnabled", (...e3) => e3.some((e4) => e4)), d2.buttonView.bind("label").to(a2, "value", c2, "value", (e3, t4) => {
              const i3 = e3 || t4 && "paragraph";
              return r2[i3] ? r2[i3] : n2;
            }), this.listenTo(d2, "execute", (t4) => {
              e2.execute(t4.source.commandName, t4.source.commandValue ? { value: t4.source.commandValue } : void 0), e2.editing.view.focus();
            }), d2;
          });
        }
      }
      class Vg extends Qe {
        static get requires() {
          return [Ud];
        }
        static get pluginName() {
          return "WidgetToolbarRepository";
        }
        init() {
          const e2 = this.editor;
          if (e2.plugins.has("BalloonToolbar")) {
            const t2 = e2.plugins.get("BalloonToolbar");
            this.listenTo(t2, "show", (t3) => {
              (function(e3) {
                const t4 = e3.getSelectedElement();
                return !(!t4 || !Oh(t4));
              })(e2.editing.view.document.selection) && t3.stop();
            }, { priority: "high" });
          }
          this._toolbarDefinitions = new Map(), this._balloon = this.editor.plugins.get("ContextualBalloon"), this.on("change:isEnabled", () => {
            this._updateToolbarsVisibility();
          }), this.listenTo(e2.ui, "update", () => {
            this._updateToolbarsVisibility();
          }), this.listenTo(e2.ui.focusTracker, "change:isFocused", () => {
            this._updateToolbarsVisibility();
          }, { priority: "low" });
        }
        destroy() {
          super.destroy();
          for (const e2 of this._toolbarDefinitions.values())
            e2.view.destroy();
        }
        register(e2, { ariaLabel: t2, items: i2, getRelatedElement: n2, balloonClassName: o2 = "ck-toolbar-container" }) {
          if (!i2.length)
            return void Object(c.b)("widget-toolbar-no-items", { toolbarId: e2 });
          const r2 = this.editor, s2 = r2.t, a2 = new pd(r2.locale);
          if (a2.ariaLabel = t2 || s2("Widget toolbar"), this._toolbarDefinitions.has(e2))
            throw new c.a("widget-toolbar-duplicated", this, { toolbarId: e2 });
          a2.fillFromConfig(i2, r2.ui.componentFactory), this._toolbarDefinitions.set(e2, { view: a2, getRelatedElement: n2, balloonClassName: o2 });
        }
        _updateToolbarsVisibility() {
          let e2 = 0, t2 = null, i2 = null;
          for (const n2 of this._toolbarDefinitions.values()) {
            const o2 = n2.getRelatedElement(this.editor.editing.view.document.selection);
            if (this.isEnabled && o2)
              if (this.editor.ui.focusTracker.isFocused) {
                const r2 = o2.getAncestors().length;
                r2 > e2 && (e2 = r2, t2 = o2, i2 = n2);
              } else
                this._isToolbarVisible(n2) && this._hideToolbar(n2);
            else
              this._isToolbarInBalloon(n2) && this._hideToolbar(n2);
          }
          i2 && this._showToolbar(i2, t2);
        }
        _hideToolbar(e2) {
          this._balloon.remove(e2.view), this.stopListening(this._balloon, "change:visibleView");
        }
        _showToolbar(e2, t2) {
          this._isToolbarVisible(e2) ? jg(this.editor, t2) : this._isToolbarInBalloon(e2) || (this._balloon.add({ view: e2.view, position: Bg(this.editor, t2), balloonClassName: e2.balloonClassName }), this.listenTo(this._balloon, "change:visibleView", () => {
            for (const e3 of this._toolbarDefinitions.values())
              if (this._isToolbarVisible(e3)) {
                const t3 = e3.getRelatedElement(this.editor.editing.view.document.selection);
                jg(this.editor, t3);
              }
          }));
        }
        _isToolbarVisible(e2) {
          return this._balloon.visibleView === e2.view;
        }
        _isToolbarInBalloon(e2) {
          return this._balloon.hasView(e2.view);
        }
      }
      function jg(e2, t2) {
        const i2 = e2.plugins.get("ContextualBalloon"), n2 = Bg(e2, t2);
        i2.updatePosition(n2);
      }
      function Bg(e2, t2) {
        const i2 = e2.editing.view, n2 = Vd.defaultPositions;
        return { target: i2.domConverter.mapViewToDom(t2), positions: [n2.northArrowSouth, n2.northArrowSouthWest, n2.northArrowSouthEast, n2.southArrowNorth, n2.southArrowNorthWest, n2.southArrowNorthEast, n2.viewportStickyNorth] };
      }
      class Fg {
        constructor(e2) {
          this.set("activeHandlePosition", null), this.set("proposedWidthPercents", null), this.set("proposedWidth", null), this.set("proposedHeight", null), this.set("proposedHandleHostWidth", null), this.set("proposedHandleHostHeight", null), this._options = e2, this._referenceCoordinates = null;
        }
        begin(e2, t2, i2) {
          const n2 = new Cs(t2);
          this.activeHandlePosition = function(e3) {
            const t3 = ["top-left", "top-right", "bottom-right", "bottom-left"];
            for (const i3 of t3)
              if (e3.classList.contains("ck-widget__resizer__handle-" + i3))
                return i3;
          }(e2), this._referenceCoordinates = function(e3, t3) {
            const i3 = new Cs(e3), n3 = t3.split("-"), o3 = { x: n3[1] == "right" ? i3.right : i3.left, y: n3[0] == "bottom" ? i3.bottom : i3.top };
            return o3.x += e3.ownerDocument.defaultView.scrollX, o3.y += e3.ownerDocument.defaultView.scrollY, o3;
          }(t2, function(e3) {
            const t3 = e3.split("-"), i3 = { top: "bottom", bottom: "top", left: "right", right: "left" };
            return `${i3[t3[0]]}-${i3[t3[1]]}`;
          }(this.activeHandlePosition)), this.originalWidth = n2.width, this.originalHeight = n2.height, this.aspectRatio = n2.width / n2.height;
          const o2 = i2.style.width;
          o2 && o2.match(/^\d+(\.\d*)?%$/) ? this.originalWidthPercents = parseFloat(o2) : this.originalWidthPercents = function(e3, t3) {
            const i3 = e3.parentElement, n3 = parseFloat(i3.ownerDocument.defaultView.getComputedStyle(i3).width);
            return t3.width / n3 * 100;
          }(i2, n2);
        }
        update(e2) {
          this.proposedWidth = e2.width, this.proposedHeight = e2.height, this.proposedWidthPercents = e2.widthPercents, this.proposedHandleHostWidth = e2.handleHostWidth, this.proposedHandleHostHeight = e2.handleHostHeight;
        }
      }
      Ke(Fg, Ue);
      class Hg extends Nl {
        constructor() {
          super();
          const e2 = this.bindTemplate;
          this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-size-view", e2.to("_viewPosition", (e3) => e3 ? "ck-orientation-" + e3 : "")], style: { display: e2.if("_isVisible", "none", (e3) => !e3) } }, children: [{ text: e2.to("_label") }] });
        }
        _bindToState(e2, t2) {
          this.bind("_isVisible").to(t2, "proposedWidth", t2, "proposedHeight", (e3, t3) => e3 !== null && t3 !== null), this.bind("_label").to(t2, "proposedHandleHostWidth", t2, "proposedHandleHostHeight", t2, "proposedWidthPercents", (t3, i2, n2) => e2.unit === "px" ? `${t3}\xD7${i2}` : n2 + "%"), this.bind("_viewPosition").to(t2, "activeHandlePosition", t2, "proposedHandleHostWidth", t2, "proposedHandleHostHeight", (e3, t3, i2) => t3 < 50 || i2 < 50 ? "above-center" : e3);
        }
        _dismiss() {
          this.unbind(), this._isVisible = false;
        }
      }
      class Ug {
        constructor(e2) {
          this._options = e2, this._viewResizerWrapper = null, this.set("isEnabled", true), this.decorate("begin"), this.decorate("cancel"), this.decorate("commit"), this.decorate("updateSize"), this.on("commit", (e3) => {
            this.state.proposedWidth || this.state.proposedWidthPercents || (this._cleanup(), e3.stop());
          }, { priority: "high" }), this.on("change:isEnabled", () => {
            this.isEnabled && this.redraw();
          });
        }
        attach() {
          const e2 = this, t2 = this._options.viewElement;
          this._options.editor.editing.view.change((i2) => {
            const n2 = i2.createUIElement("div", { class: "ck ck-reset_all ck-widget__resizer" }, function(t3) {
              const i3 = this.toDomElement(t3);
              return e2._appendHandles(i3), e2._appendSizeUI(i3), e2.on("change:isEnabled", (e3, t4, n3) => {
                i3.style.display = n3 ? "" : "none";
              }), i3.style.display = e2.isEnabled ? "" : "none", i3;
            });
            i2.insert(i2.createPositionAt(t2, "end"), n2), i2.addClass("ck-widget_with-resizer", t2), this._viewResizerWrapper = n2;
          });
        }
        begin(e2) {
          this.state = new Fg(this._options), this._sizeView._bindToState(this._options, this.state), this._initialViewWidth = this._options.viewElement.getStyle("width"), this.state.begin(e2, this._getHandleHost(), this._getResizeHost());
        }
        updateSize(e2) {
          const t2 = this._proposeNewSize(e2);
          this._options.editor.editing.view.change((e3) => {
            const i3 = this._options.unit || "%", n3 = (i3 === "%" ? t2.widthPercents : t2.width) + i3;
            e3.setStyle("width", n3, this._options.viewElement);
          });
          const i2 = this._getHandleHost(), n2 = new Cs(i2);
          t2.handleHostWidth = Math.round(n2.width), t2.handleHostHeight = Math.round(n2.height);
          const o2 = new Cs(i2);
          t2.width = Math.round(o2.width), t2.height = Math.round(o2.height), this.redraw(n2), this.state.update(t2);
        }
        commit() {
          const e2 = this._options.unit || "%", t2 = (e2 === "%" ? this.state.proposedWidthPercents : this.state.proposedWidth) + e2;
          this._options.editor.editing.view.change(() => {
            this._cleanup(), this._options.onCommit(t2);
          });
        }
        cancel() {
          this._cleanup();
        }
        destroy() {
          this.cancel();
        }
        redraw(e2) {
          const t2 = this._domResizerWrapper;
          if (!((i2 = t2) && i2.ownerDocument && i2.ownerDocument.contains(i2)))
            return;
          var i2;
          const n2 = t2.parentElement, o2 = this._getHandleHost(), r2 = this._viewResizerWrapper, s2 = [r2.getStyle("width"), r2.getStyle("height"), r2.getStyle("left"), r2.getStyle("top")];
          let a2;
          if (n2.isSameNode(o2)) {
            const t3 = e2 || new Cs(o2);
            a2 = [t3.width + "px", t3.height + "px", void 0, void 0];
          } else
            a2 = [o2.offsetWidth + "px", o2.offsetHeight + "px", o2.offsetLeft + "px", o2.offsetTop + "px"];
          cn(s2, a2) !== "same" && this._options.editor.editing.view.change((e3) => {
            e3.setStyle({ width: a2[0], height: a2[1], left: a2[2], top: a2[3] }, r2);
          });
        }
        containsHandle(e2) {
          return this._domResizerWrapper.contains(e2);
        }
        static isResizeHandle(e2) {
          return e2.classList.contains("ck-widget__resizer__handle");
        }
        _cleanup() {
          this._sizeView._dismiss();
          this._options.editor.editing.view.change((e2) => {
            e2.setStyle("width", this._initialViewWidth, this._options.viewElement);
          });
        }
        _proposeNewSize(e2) {
          const t2 = this.state, i2 = { x: (n2 = e2).pageX, y: n2.pageY };
          var n2;
          const o2 = !this._options.isCentered || this._options.isCentered(this), r2 = { x: t2._referenceCoordinates.x - (i2.x + t2.originalWidth), y: i2.y - t2.originalHeight - t2._referenceCoordinates.y };
          o2 && t2.activeHandlePosition.endsWith("-right") && (r2.x = i2.x - (t2._referenceCoordinates.x + t2.originalWidth)), o2 && (r2.x *= 2);
          const s2 = { width: Math.abs(t2.originalWidth + r2.x), height: Math.abs(t2.originalHeight + r2.y) };
          s2.dominant = s2.width / t2.aspectRatio > s2.height ? "width" : "height", s2.max = s2[s2.dominant];
          const a2 = { width: s2.width, height: s2.height };
          return s2.dominant == "width" ? a2.height = a2.width / t2.aspectRatio : a2.width = a2.height * t2.aspectRatio, { width: Math.round(a2.width), height: Math.round(a2.height), widthPercents: Math.min(Math.round(t2.originalWidthPercents / t2.originalWidth * a2.width * 100) / 100, 100) };
        }
        _getResizeHost() {
          const e2 = this._domResizerWrapper.parentElement;
          return this._options.getResizeHost(e2);
        }
        _getHandleHost() {
          const e2 = this._domResizerWrapper.parentElement;
          return this._options.getHandleHost(e2);
        }
        get _domResizerWrapper() {
          return this._options.editor.editing.view.domConverter.mapViewToDom(this._viewResizerWrapper);
        }
        _appendHandles(e2) {
          const t2 = ["top-left", "top-right", "bottom-right", "bottom-left"];
          for (const n2 of t2)
            e2.appendChild(new Rl({ tag: "div", attributes: { class: "ck-widget__resizer__handle " + (i2 = n2, "ck-widget__resizer__handle-" + i2) } }).render());
          var i2;
        }
        _appendSizeUI(e2) {
          this._sizeView = new Hg(), this._sizeView.render(), e2.appendChild(this._sizeView.element);
        }
      }
      Ke(Ug, Ue);
      i(72);
      Ke(class extends Qe {
        static get pluginName() {
          return "WidgetResize";
        }
        init() {
          const e2 = this.editor.editing, t2 = _r.window.document;
          this.set("visibleResizer", null), this.set("_activeResizer", null), this._resizers = new Map(), e2.view.addObserver(uh), this._observer = Object.create(Pr), this.listenTo(e2.view.document, "mousedown", this._mouseDownListener.bind(this), { priority: "high" }), this._observer.listenTo(t2, "mousemove", this._mouseMoveListener.bind(this)), this._observer.listenTo(t2, "mouseup", this._mouseUpListener.bind(this));
          const i2 = () => {
            this.visibleResizer && this.visibleResizer.redraw();
          };
          this._redrawFocusedResizerThrottled = tu(i2, 200), this.on("change:visibleResizer", i2), this.editor.ui.on("update", this._redrawFocusedResizerThrottled), this.editor.model.document.on("change", () => {
            for (const [e3, t3] of this._resizers)
              e3.isAttached() || (this._resizers.delete(e3), t3.destroy());
          }, { priority: "lowest" }), this._observer.listenTo(_r.window, "resize", this._redrawFocusedResizerThrottled);
          const n2 = this.editor.editing.view.document.selection;
          n2.on("change", () => {
            const e3 = n2.getSelectedElement();
            this.visibleResizer = this.getResizerByViewElement(e3) || null;
          });
        }
        destroy() {
          this._observer.stopListening();
          for (const e2 of this._resizers.values())
            e2.destroy();
          this._redrawFocusedResizerThrottled.cancel();
        }
        attachTo(e2) {
          const t2 = new Ug(e2), i2 = this.editor.plugins;
          if (t2.attach(), i2.has("WidgetToolbarRepository")) {
            const e3 = i2.get("WidgetToolbarRepository");
            t2.on("begin", () => {
              e3.forceDisabled("resize");
            }, { priority: "lowest" }), t2.on("cancel", () => {
              e3.clearForceDisabled("resize");
            }, { priority: "highest" }), t2.on("commit", () => {
              e3.clearForceDisabled("resize");
            }, { priority: "highest" });
          }
          this._resizers.set(e2.viewElement, t2);
          const n2 = this.editor.editing.view.document.selection.getSelectedElement();
          return this.getResizerByViewElement(n2) == t2 && (this.visibleResizer = t2), t2;
        }
        getResizerByViewElement(e2) {
          return this._resizers.get(e2);
        }
        _getResizerByHandle(e2) {
          for (const t2 of this._resizers.values())
            if (t2.containsHandle(e2))
              return t2;
        }
        _mouseDownListener(e2, t2) {
          const i2 = t2.domTarget;
          Ug.isResizeHandle(i2) && (this._activeResizer = this._getResizerByHandle(i2), this._activeResizer && (this._activeResizer.begin(i2), e2.stop(), t2.preventDefault()));
        }
        _mouseMoveListener(e2, t2) {
          this._activeResizer && this._activeResizer.updateSize(t2);
        }
        _mouseUpListener() {
          this._activeResizer && (this._activeResizer.commit(), this._activeResizer = null);
        }
      }, Ue);
      class Wg extends Ze {
        refresh() {
          const e2 = this.editor.plugins.get("ImageUtils").getClosestSelectedImageElement(this.editor.model.document.selection);
          this.isEnabled = !!e2, this.isEnabled && e2.hasAttribute("alt") ? this.value = e2.getAttribute("alt") : this.value = false;
        }
        execute(e2) {
          const t2 = this.editor, i2 = t2.plugins.get("ImageUtils"), n2 = t2.model, o2 = i2.getClosestSelectedImageElement(n2.document.selection);
          n2.change((t3) => {
            t3.setAttribute("alt", e2.newValue, o2);
          });
        }
      }
      function qg(e2, t2) {
        const i2 = e2.createEmptyElement("img"), n2 = t2 === "imageBlock" ? e2.createContainerElement("figure", { class: "image" }) : e2.createContainerElement("span", { class: "image-inline" }, { isAllowedInsideAttributeElement: true });
        return e2.insert(e2.createPositionAt(n2, 0), i2), n2;
      }
      function $g(e2, t2) {
        if (e2.plugins.has("ImageInlineEditing") !== e2.plugins.has("ImageBlockEditing"))
          return { name: "img" };
        const i2 = e2.plugins.get("ImageUtils");
        return (e3) => {
          if (!i2.isInlineImageView(e3))
            return null;
          return (e3.findAncestor(i2.isBlockImageView) ? "imageBlock" : "imageInline") !== t2 ? null : { name: true };
        };
      }
      function Yg(e2, t2) {
        const i2 = Ms(t2.getSelectedBlocks());
        return !i2 || e2.isObject(i2) || i2.isEmpty && i2.name != "listItem" ? "imageBlock" : "imageInline";
      }
      class Gg extends Qe {
        static get pluginName() {
          return "ImageUtils";
        }
        isImage(e2) {
          return this.isInlineImage(e2) || this.isBlockImage(e2);
        }
        isInlineImageView(e2) {
          return !!e2 && e2.is("element", "img");
        }
        isBlockImageView(e2) {
          return !!e2 && e2.is("element", "figure") && e2.hasClass("image");
        }
        insertImage(e2 = {}, t2 = null, i2 = null) {
          const n2 = this.editor, o2 = n2.model, r2 = o2.document.selection;
          i2 = Kg(n2, t2 || r2, i2), e2 = __spreadValues(__spreadValues({}, Object.fromEntries(r2.getAttributes())), e2);
          for (const t3 in e2)
            o2.schema.checkAttribute(i2, t3) || delete e2[t3];
          return o2.change((n3) => {
            const s2 = n3.createElement(i2, e2);
            return t2 || i2 == "imageInline" || (t2 = Fh(r2, o2)), o2.insertContent(s2, t2), s2.parent ? (n3.setSelection(s2, "on"), s2) : null;
          });
        }
        getClosestSelectedImageWidget(e2) {
          const t2 = e2.getSelectedElement();
          if (t2 && this.isImageWidget(t2))
            return t2;
          let i2 = e2.getFirstPosition().parent;
          for (; i2; ) {
            if (i2.is("element") && this.isImageWidget(i2))
              return i2;
            i2 = i2.parent;
          }
          return null;
        }
        getClosestSelectedImageElement(e2) {
          const t2 = e2.getSelectedElement();
          return this.isImage(t2) ? t2 : e2.getFirstPosition().findAncestor("imageBlock");
        }
        isImageAllowed() {
          const e2 = this.editor.model.document.selection;
          return function(e3, t2) {
            if (Kg(e3, t2) == "imageBlock") {
              const i2 = function(e4, t3) {
                const i3 = Fh(e4, t3).start.parent;
                if (i3.isEmpty && !i3.is("element", "$root"))
                  return i3.parent;
                return i3;
              }(t2, e3.model);
              if (e3.model.schema.checkChild(i2, "imageBlock"))
                return true;
            } else if (e3.model.schema.checkChild(t2.focus, "imageInline"))
              return true;
            return false;
          }(this.editor, e2) && function(e3) {
            return [...e3.focus.getAncestors()].every((e4) => !e4.is("element", "imageBlock"));
          }(e2);
        }
        toImageWidget(e2, t2, i2) {
          t2.setCustomProperty("image", true, e2);
          return zh(e2, t2, { label: () => {
            const t3 = this.findViewImgElement(e2).getAttribute("alt");
            return t3 ? `${t3} ${i2}` : i2;
          } });
        }
        isImageWidget(e2) {
          return !!e2.getCustomProperty("image") && Oh(e2);
        }
        isBlockImage(e2) {
          return !!e2 && e2.is("element", "imageBlock");
        }
        isInlineImage(e2) {
          return !!e2 && e2.is("element", "imageInline");
        }
        findViewImgElement(e2) {
          if (this.isInlineImageView(e2))
            return e2;
          const t2 = this.editor.editing.view;
          for (const { item: i2 } of t2.createRangeIn(e2))
            if (this.isInlineImageView(i2))
              return i2;
        }
      }
      function Kg(e2, t2, i2) {
        const n2 = e2.model.schema, o2 = e2.config.get("image.insert.type");
        return e2.plugins.has("ImageBlockEditing") ? e2.plugins.has("ImageInlineEditing") ? i2 || (o2 === "inline" ? "imageInline" : o2 === "block" ? "imageBlock" : t2.is("selection") ? Yg(n2, t2) : n2.checkChild(t2, "imageInline") ? "imageInline" : "imageBlock") : "imageBlock" : "imageInline";
      }
      class Qg extends Qe {
        static get requires() {
          return [Gg];
        }
        static get pluginName() {
          return "ImageTextAlternativeEditing";
        }
        init() {
          this.editor.commands.add("imageTextAlternative", new Wg(this.editor));
        }
      }
      i(74), i(7);
      class Jg extends Nl {
        constructor(e2) {
          super(e2);
          const t2 = this.locale.t;
          this.focusTracker = new Ns(), this.keystrokes = new Rs(), this.labeledInput = this._createLabeledInputView(), this.saveButtonView = this._createButton(t2("Save"), El.check, "ck-button-save"), this.saveButtonView.type = "submit", this.cancelButtonView = this._createButton(t2("Cancel"), El.cancel, "ck-button-cancel", "cancel"), this._focusables = new Ml(), this._focusCycler = new nd({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }), this.setTemplate({ tag: "form", attributes: { class: ["ck", "ck-text-alternative-form", "ck-responsive-form"], tabindex: "-1" }, children: [this.labeledInput, this.saveButtonView, this.cancelButtonView] }), Sl(this);
        }
        render() {
          super.render(), this.keystrokes.listenTo(this.element), Pl({ view: this }), [this.labeledInput, this.saveButtonView, this.cancelButtonView].forEach((e2) => {
            this._focusables.add(e2), this.focusTracker.add(e2.element);
          });
        }
        _createButton(e2, t2, i2, n2) {
          const o2 = new td(this.locale);
          return o2.set({ label: e2, icon: t2, tooltip: true }), o2.extendTemplate({ attributes: { class: i2 } }), n2 && o2.delegate("execute").to(this, n2), o2;
        }
        _createLabeledInputView() {
          const e2 = this.locale.t, t2 = new Nd(this.locale, Rd);
          return t2.label = e2("Text alternative"), t2;
        }
      }
      function Zg(e2) {
        const t2 = e2.editing.view, i2 = Vd.defaultPositions, n2 = e2.plugins.get("ImageUtils");
        return { target: t2.domConverter.viewToDom(n2.getClosestSelectedImageWidget(t2.document.selection)), positions: [i2.northArrowSouth, i2.northArrowSouthWest, i2.northArrowSouthEast, i2.southArrowNorth, i2.southArrowNorthWest, i2.southArrowNorthEast, i2.viewportStickyNorth] };
      }
      class Xg extends Qe {
        static get requires() {
          return [Ud];
        }
        static get pluginName() {
          return "ImageTextAlternativeUI";
        }
        init() {
          this._createButton(), this._createForm();
        }
        destroy() {
          super.destroy(), this._form.destroy();
        }
        _createButton() {
          const e2 = this.editor, t2 = e2.t;
          e2.ui.componentFactory.add("imageTextAlternative", (i2) => {
            const n2 = e2.commands.get("imageTextAlternative"), o2 = new td(i2);
            return o2.set({ label: t2("Change image text alternative"), icon: El.lowVision, tooltip: true }), o2.bind("isEnabled").to(n2, "isEnabled"), this.listenTo(o2, "execute", () => {
              this._showForm();
            }), o2;
          });
        }
        _createForm() {
          const e2 = this.editor, t2 = e2.editing.view.document, i2 = e2.plugins.get("ImageUtils");
          this._balloon = this.editor.plugins.get("ContextualBalloon"), this._form = new Jg(e2.locale), this._form.render(), this.listenTo(this._form, "submit", () => {
            e2.execute("imageTextAlternative", { newValue: this._form.labeledInput.fieldView.element.value }), this._hideForm(true);
          }), this.listenTo(this._form, "cancel", () => {
            this._hideForm(true);
          }), this._form.keystrokes.set("Esc", (e3, t3) => {
            this._hideForm(true), t3();
          }), this.listenTo(e2.ui, "update", () => {
            i2.getClosestSelectedImageWidget(t2.selection) ? this._isVisible && function(e3) {
              const t3 = e3.plugins.get("ContextualBalloon");
              if (e3.plugins.get("ImageUtils").getClosestSelectedImageWidget(e3.editing.view.document.selection)) {
                const i3 = Zg(e3);
                t3.updatePosition(i3);
              }
            }(e2) : this._hideForm(true);
          }), Il({ emitter: this._form, activator: () => this._isVisible, contextElements: [this._balloon.view.element], callback: () => this._hideForm() });
        }
        _showForm() {
          if (this._isVisible)
            return;
          const e2 = this.editor, t2 = e2.commands.get("imageTextAlternative"), i2 = this._form.labeledInput;
          this._form.disableCssTransitions(), this._isInBalloon || this._balloon.add({ view: this._form, position: Zg(e2) }), i2.fieldView.value = i2.fieldView.element.value = t2.value || "", this._form.labeledInput.fieldView.select(), this._form.enableCssTransitions();
        }
        _hideForm(e2) {
          this._isInBalloon && (this._form.focusTracker.isFocused && this._form.saveButtonView.focus(), this._balloon.remove(this._form), e2 && this.editor.editing.view.focus());
        }
        get _isVisible() {
          return this._balloon.visibleView === this._form;
        }
        get _isInBalloon() {
          return this._balloon.hasView(this._form);
        }
      }
      class em extends Qe {
        static get requires() {
          return [Qg, Xg];
        }
        static get pluginName() {
          return "ImageTextAlternative";
        }
      }
      function tm(e2, t2) {
        return (e3) => {
          e3.on("attribute:srcset:" + t2, i2);
        };
        function i2(t3, i3, n2) {
          if (!n2.consumable.consume(i3.item, t3.name))
            return;
          const o2 = n2.writer, r2 = n2.mapper.toViewElement(i3.item), s2 = e2.findViewImgElement(r2);
          if (i3.attributeNewValue === null) {
            const e3 = i3.attributeOldValue;
            e3.data && (o2.removeAttribute("srcset", s2), o2.removeAttribute("sizes", s2), e3.width && o2.removeAttribute("width", s2));
          } else {
            const e3 = i3.attributeNewValue;
            e3.data && (o2.setAttribute("srcset", e3.data, s2), o2.setAttribute("sizes", "100vw", s2), e3.width && o2.setAttribute("width", e3.width, s2));
          }
        }
      }
      function im(e2, t2, i2) {
        return (e3) => {
          e3.on(`attribute:${i2}:${t2}`, n2);
        };
        function n2(t3, i3, n3) {
          if (!n3.consumable.consume(i3.item, t3.name))
            return;
          const o2 = n3.writer, r2 = n3.mapper.toViewElement(i3.item), s2 = e2.findViewImgElement(r2);
          o2.setAttribute(i3.attributeKey, i3.attributeNewValue || "", s2);
        }
      }
      class nm extends Rr {
        observe(e2) {
          this.listenTo(e2, "load", (e3, t2) => {
            const i2 = t2.target;
            this.checkShouldIgnoreEventFromTarget(i2) || i2.tagName == "IMG" && this._fireEvents(t2);
          }, { useCapture: true });
        }
        _fireEvents(e2) {
          this.isEnabled && (this.document.fire("layoutChanged"), this.document.fire("imageLoaded", e2));
        }
      }
      class om extends Ze {
        constructor(e2) {
          super(e2);
          const t2 = e2.config.get("image.insert.type");
          e2.plugins.has("ImageBlockEditing") || t2 === "block" && Object(c.b)("image-block-plugin-required"), e2.plugins.has("ImageInlineEditing") || t2 === "inline" && Object(c.b)("image-inline-plugin-required");
        }
        refresh() {
          this.isEnabled = this.editor.plugins.get("ImageUtils").isImageAllowed();
        }
        execute(e2) {
          const t2 = en(e2.source), i2 = this.editor.model.document.selection, n2 = this.editor.plugins.get("ImageUtils"), o2 = Object.fromEntries(i2.getAttributes());
          t2.forEach((e3, t3) => {
            const r2 = i2.getSelectedElement();
            if (typeof e3 == "string" && (e3 = { src: e3 }), t3 && r2 && n2.isImage(r2)) {
              const t4 = this.editor.model.createPositionAfter(r2);
              n2.insertImage(__spreadValues(__spreadValues({}, e3), o2), t4);
            } else
              n2.insertImage(__spreadValues(__spreadValues({}, e3), o2));
          });
        }
      }
      class rm extends Qe {
        static get requires() {
          return [Gg];
        }
        static get pluginName() {
          return "ImageEditing";
        }
        init() {
          const e2 = this.editor, t2 = e2.conversion;
          e2.editing.view.addObserver(nm), t2.for("upcast").attributeToAttribute({ view: { name: "img", key: "alt" }, model: "alt" }).attributeToAttribute({ view: { name: "img", key: "srcset" }, model: { key: "srcset", value: (e3) => {
            const t3 = { data: e3.getAttribute("srcset") };
            return e3.hasAttribute("width") && (t3.width = e3.getAttribute("width")), t3;
          } } });
          const i2 = new om(e2);
          e2.commands.add("insertImage", i2), e2.commands.add("imageInsert", i2);
        }
      }
      class sm extends Ze {
        constructor(e2, t2) {
          super(e2), this._modelElementName = t2;
        }
        refresh() {
          const e2 = this.editor.plugins.get("ImageUtils"), t2 = e2.getClosestSelectedImageElement(this.editor.model.document.selection);
          this._modelElementName === "imageBlock" ? this.isEnabled = e2.isInlineImage(t2) : this.isEnabled = e2.isBlockImage(t2);
        }
        execute() {
          const e2 = this.editor, t2 = this.editor.model, i2 = e2.plugins.get("ImageUtils"), n2 = i2.getClosestSelectedImageElement(t2.document.selection), o2 = Object.fromEntries(n2.getAttributes());
          return o2.src || o2.uploadId ? t2.change((e3) => {
            const r2 = Array.from(t2.markers).filter((e4) => e4.getRange().containsItem(n2)), s2 = i2.insertImage(o2, t2.createSelection(n2, "on"), this._modelElementName);
            if (!s2)
              return null;
            const a2 = e3.createRangeOn(s2);
            for (const t3 of r2) {
              const i3 = t3.getRange(), n3 = i3.root.rootName != "$graveyard" ? i3.getJoined(a2, true) : a2;
              e3.updateMarker(t3, { range: n3 });
            }
            return { oldElement: n2, newElement: s2 };
          }) : null;
        }
      }
      class am extends Qe {
        static get requires() {
          return [rm, Gg, _h];
        }
        static get pluginName() {
          return "ImageBlockEditing";
        }
        init() {
          const e2 = this.editor;
          e2.model.schema.register("imageBlock", { isObject: true, isBlock: true, allowWhere: "$block", allowAttributes: ["alt", "src", "srcset"] }), this._setupConversion(), e2.plugins.has("ImageInlineEditing") && (e2.commands.add("imageTypeBlock", new sm(this.editor, "imageBlock")), this._setupClipboardIntegration());
        }
        _setupConversion() {
          const e2 = this.editor, t2 = e2.t, i2 = e2.conversion, n2 = e2.plugins.get("ImageUtils");
          i2.for("dataDowncast").elementToElement({ model: "imageBlock", view: (e3, { writer: t3 }) => qg(t3, "imageBlock") }), i2.for("editingDowncast").elementToElement({ model: "imageBlock", view: (e3, { writer: i3 }) => n2.toImageWidget(qg(i3, "imageBlock"), i3, t2("image widget")) }), i2.for("downcast").add(im(n2, "imageBlock", "src")).add(im(n2, "imageBlock", "alt")).add(tm(n2, "imageBlock")), i2.for("upcast").elementToElement({ view: $g(e2, "imageBlock"), model: (e3, { writer: t3 }) => t3.createElement("imageBlock", e3.hasAttribute("src") ? { src: e3.getAttribute("src") } : null) }).add(function(e3) {
            return (e4) => {
              e4.on("element:figure", t3);
            };
            function t3(t4, i3, n3) {
              if (!n3.consumable.test(i3.viewItem, { name: true, classes: "image" }))
                return;
              const o2 = e3.findViewImgElement(i3.viewItem);
              if (!o2 || !n3.consumable.test(o2, { name: true }))
                return;
              const r2 = Ms(n3.convertItem(o2, i3.modelCursor).modelRange.getItems());
              r2 && (n3.consumable.consume(i3.viewItem, { name: true, classes: "image" }), n3.convertChildren(i3.viewItem, r2), n3.updateConversionResult(r2, i3));
            }
          }(n2));
        }
        _setupClipboardIntegration() {
          const e2 = this.editor, t2 = e2.model, i2 = e2.editing.view, n2 = e2.plugins.get("ImageUtils");
          this.listenTo(e2.plugins.get("ClipboardPipeline"), "inputTransformation", (o2, r2) => {
            const s2 = Array.from(r2.content.getChildren());
            let a2;
            if (!s2.every(n2.isInlineImageView))
              return;
            a2 = r2.targetRanges ? e2.editing.mapper.toModelRange(r2.targetRanges[0]) : t2.document.selection.getFirstRange();
            const c2 = t2.createSelection(a2);
            if (Yg(t2.schema, c2) === "imageBlock") {
              const e3 = new gh(i2.document), t3 = s2.map((t4) => e3.createElement("figure", { class: "image" }, t4));
              r2.content = e3.createDocumentFragment(t3);
            }
          });
        }
      }
      i(11);
      class cm extends Qe {
        static get requires() {
          return [am, Xh, em];
        }
        static get pluginName() {
          return "ImageBlock";
        }
      }
      class lm extends Qe {
        static get requires() {
          return [rm, Gg, _h];
        }
        static get pluginName() {
          return "ImageInlineEditing";
        }
        init() {
          const e2 = this.editor, t2 = e2.model.schema;
          t2.register("imageInline", { isObject: true, isInline: true, allowWhere: "$text", allowAttributes: ["alt", "src", "srcset"] }), t2.addChildCheck((e3, t3) => {
            if (e3.endsWith("caption") && t3.name === "imageInline")
              return false;
          }), this._setupConversion(), e2.plugins.has("ImageBlockEditing") && (e2.commands.add("imageTypeInline", new sm(this.editor, "imageInline")), this._setupClipboardIntegration());
        }
        _setupConversion() {
          const e2 = this.editor, t2 = e2.t, i2 = e2.conversion, n2 = e2.plugins.get("ImageUtils");
          i2.for("dataDowncast").elementToElement({ model: "imageInline", view: (e3, { writer: t3 }) => t3.createEmptyElement("img") }), i2.for("editingDowncast").elementToElement({ model: "imageInline", view: (e3, { writer: i3 }) => n2.toImageWidget(qg(i3, "imageInline"), i3, t2("image widget")) }), i2.for("downcast").add(im(n2, "imageInline", "src")).add(im(n2, "imageInline", "alt")).add(tm(n2, "imageInline")), i2.for("upcast").elementToElement({ view: $g(e2, "imageInline"), model: (e3, { writer: t3 }) => t3.createElement("imageInline", e3.hasAttribute("src") ? { src: e3.getAttribute("src") } : null) });
        }
        _setupClipboardIntegration() {
          const e2 = this.editor, t2 = e2.model, i2 = e2.editing.view, n2 = e2.plugins.get("ImageUtils");
          this.listenTo(e2.plugins.get("ClipboardPipeline"), "inputTransformation", (o2, r2) => {
            const s2 = Array.from(r2.content.getChildren());
            let a2;
            if (!s2.every(n2.isBlockImageView))
              return;
            a2 = r2.targetRanges ? e2.editing.mapper.toModelRange(r2.targetRanges[0]) : t2.document.selection.getFirstRange();
            const c2 = t2.createSelection(a2);
            if (Yg(t2.schema, c2) === "imageInline") {
              const e3 = new gh(i2.document), t3 = s2.map((t4) => t4.childCount === 1 ? (Array.from(t4.getAttributes()).forEach((i3) => e3.setAttribute(...i3, n2.findViewImgElement(t4))), t4.getChild(0)) : t4);
              r2.content = e3.createDocumentFragment(t3);
            }
          });
        }
      }
      class dm extends Qe {
        static get requires() {
          return [lm, Xh, em];
        }
        static get pluginName() {
          return "ImageInline";
        }
      }
      function hm(e2) {
        for (const t2 of e2.getChildren())
          if (t2 && t2.is("element", "caption"))
            return t2;
        return null;
      }
      function um(e2, t2) {
        const i2 = t2.getFirstPosition().findAncestor("caption");
        return i2 && e2.isBlockImage(i2.parent) ? i2 : null;
      }
      class gm extends Ze {
        refresh() {
          const e2 = this.editor, t2 = e2.plugins.get("ImageUtils");
          if (!e2.plugins.has(am))
            return this.isEnabled = false, void (this.value = false);
          const i2 = e2.model.document.selection, n2 = i2.getSelectedElement();
          if (!n2) {
            const e3 = um(t2, i2);
            return this.isEnabled = !!e3, void (this.value = !!e3);
          }
          this.isEnabled = this.editor.plugins.get("ImageUtils").isImage(n2), this.isEnabled ? this.value = !!hm(n2) : this.value = false;
        }
        execute(e2 = {}) {
          const { focusCaptionOnShow: t2 } = e2;
          this.editor.model.change((e3) => {
            this.value ? this._hideImageCaption(e3) : this._showImageCaption(e3, t2);
          });
        }
        _showImageCaption(e2, t2) {
          const i2 = this.editor.model.document.selection, n2 = this.editor.plugins.get("ImageCaptionEditing");
          let o2 = i2.getSelectedElement();
          const r2 = n2._getSavedCaption(o2);
          this.editor.plugins.get("ImageUtils").isInlineImage(o2) && (this.editor.execute("imageTypeBlock"), o2 = i2.getSelectedElement());
          const s2 = r2 || e2.createElement("caption");
          e2.append(s2, o2), t2 && e2.setSelection(s2, "in");
        }
        _hideImageCaption(e2) {
          const t2 = this.editor, i2 = t2.model.document.selection, n2 = t2.plugins.get("ImageCaptionEditing"), o2 = t2.plugins.get("ImageUtils");
          let r2, s2 = i2.getSelectedElement();
          s2 ? r2 = hm(s2) : (r2 = um(o2, i2), s2 = r2.parent), n2._saveCaption(s2, r2), e2.setSelection(s2, "on"), e2.remove(r2);
        }
      }
      class mm extends Qe {
        static get requires() {
          return [Gg];
        }
        static get pluginName() {
          return "ImageCaptionEditing";
        }
        constructor(e2) {
          super(e2), this._savedCaptionsMap = new WeakMap();
        }
        init() {
          const e2 = this.editor, t2 = e2.model.schema;
          t2.isRegistered("caption") ? t2.extend("caption", { allowIn: "imageBlock" }) : t2.register("caption", { allowIn: "imageBlock", allowContentOf: "$block", isLimit: true }), e2.commands.add("toggleImageCaption", new gm(this.editor)), this._setupConversion(), this._setupImageTypeCommandsIntegration();
        }
        _setupConversion() {
          const e2 = this.editor, t2 = e2.editing.view, i2 = e2.plugins.get("ImageUtils"), n2 = e2.t;
          e2.conversion.for("upcast").elementToElement({ view: (e3) => function(e4, t3) {
            return t3.name == "figcaption" && e4.isBlockImageView(t3.parent) ? { name: true } : null;
          }(i2, e3), model: "caption" }), e2.conversion.for("dataDowncast").elementToElement({ model: "caption", view: (e3, { writer: t3 }) => i2.isBlockImage(e3.parent) ? t3.createContainerElement("figcaption") : null }), e2.conversion.for("editingDowncast").elementToElement({ model: "caption", view: (e3, { writer: o2 }) => {
            if (!i2.isBlockImage(e3.parent))
              return null;
            const r2 = o2.createEditableElement("figcaption");
            return o2.setCustomProperty("imageCaption", true, r2), Kd({ view: t2, element: r2, text: n2("Enter image caption"), keepOnFocus: true }), Bh(r2, o2);
          } }), e2.editing.mapper.on("modelToViewPosition", fm(t2)), e2.data.mapper.on("modelToViewPosition", fm(t2));
        }
        _setupImageTypeCommandsIntegration() {
          const e2 = this.editor, t2 = e2.plugins.get("ImageUtils"), i2 = e2.commands.get("imageTypeInline"), n2 = e2.commands.get("imageTypeBlock"), o2 = (e3) => {
            if (!e3.return)
              return;
            const { oldElement: i3, newElement: n3 } = e3.return;
            if (!i3)
              return;
            if (t2.isBlockImage(i3)) {
              const e4 = hm(i3);
              if (e4)
                return void this._saveCaption(n3, e4);
            }
            const o3 = this._getSavedCaption(i3);
            o3 && this._saveCaption(n3, o3);
          };
          i2 && this.listenTo(i2, "execute", o2, { priority: "low" }), n2 && this.listenTo(n2, "execute", o2, { priority: "low" });
        }
        _getSavedCaption(e2) {
          const t2 = this._savedCaptionsMap.get(e2);
          return t2 ? Qs.fromJSON(t2) : null;
        }
        _saveCaption(e2, t2) {
          this._savedCaptionsMap.set(e2, t2.toJSON());
        }
      }
      function fm(e2) {
        return (t2, i2) => {
          const n2 = i2.modelPosition, o2 = n2.parent;
          if (!o2.is("element", "imageBlock"))
            return;
          const r2 = i2.mapper.toViewElement(o2);
          i2.viewPosition = e2.createPositionAt(r2, n2.offset + 1);
        };
      }
      class pm extends Qe {
        static get requires() {
          return [Gg];
        }
        static get pluginName() {
          return "ImageCaptionUI";
        }
        init() {
          const e2 = this.editor, t2 = e2.editing.view, i2 = e2.plugins.get("ImageUtils"), n2 = e2.t;
          e2.ui.componentFactory.add("toggleImageCaption", (o2) => {
            const r2 = e2.commands.get("toggleImageCaption"), s2 = new td(o2);
            return s2.set({ icon: El.caption, tooltip: true, isToggleable: true }), s2.bind("isOn", "isEnabled").to(r2, "value", "isEnabled"), s2.bind("label").to(r2, "value", (e3) => n2(e3 ? "Toggle caption off" : "Toggle caption on")), this.listenTo(s2, "execute", () => {
              e2.execute("toggleImageCaption", { focusCaptionOnShow: true });
              const n3 = um(i2, e2.model.document.selection);
              if (n3) {
                const i3 = e2.editing.mapper.toViewElement(n3);
                t2.scrollToTheSelection(), t2.change((e3) => {
                  e3.addClass("image__caption_highlighted", i3);
                });
              }
            }), s2;
          });
        }
      }
      i(78);
      class bm extends Ze {
        constructor(e2, t2) {
          super(e2), this._defaultStyles = { imageBlock: false, imageInline: false }, this._styles = new Map(t2.map((e3) => {
            if (e3.isDefault)
              for (const t3 of e3.modelElements)
                this._defaultStyles[t3] = e3.name;
            return [e3.name, e3];
          }));
        }
        refresh() {
          const e2 = this.editor.plugins.get("ImageUtils").getClosestSelectedImageElement(this.editor.model.document.selection);
          this.isEnabled = !!e2, this.isEnabled ? e2.hasAttribute("imageStyle") ? this.value = e2.getAttribute("imageStyle") : this.value = this._defaultStyles[e2.name] : this.value = false;
        }
        execute(e2 = {}) {
          const t2 = this.editor, i2 = t2.model, n2 = t2.plugins.get("ImageUtils");
          i2.change((t3) => {
            const o2 = e2.value;
            let r2 = n2.getClosestSelectedImageElement(i2.document.selection);
            o2 && this.shouldConvertImageType(o2, r2) && (this.editor.execute(n2.isBlockImage(r2) ? "imageTypeInline" : "imageTypeBlock"), r2 = n2.getClosestSelectedImageElement(i2.document.selection)), !o2 || this._styles.get(o2).isDefault ? t3.removeAttribute("imageStyle", r2) : t3.setAttribute("imageStyle", o2, r2);
          });
        }
        shouldConvertImageType(e2, t2) {
          return !this._styles.get(e2).modelElements.includes(t2.name);
        }
      }
      const { objectFullWidth: wm, objectInline: km, objectLeft: _m, objectRight: vm, objectCenter: ym, objectBlockLeft: xm, objectBlockRight: Am } = El, Cm = { inline: { name: "inline", title: "In line", icon: km, modelElements: ["imageInline"], isDefault: true }, alignLeft: { name: "alignLeft", title: "Left aligned image", icon: _m, modelElements: ["imageBlock", "imageInline"], className: "image-style-align-left" }, alignBlockLeft: { name: "alignBlockLeft", title: "Left aligned image", icon: xm, modelElements: ["imageBlock"], className: "image-style-block-align-left" }, alignCenter: { name: "alignCenter", title: "Centered image", icon: ym, modelElements: ["imageBlock"], className: "image-style-align-center" }, alignRight: { name: "alignRight", title: "Right aligned image", icon: vm, modelElements: ["imageBlock", "imageInline"], className: "image-style-align-right" }, alignBlockRight: { name: "alignBlockRight", title: "Right aligned image", icon: Am, modelElements: ["imageBlock"], className: "image-style-block-align-right" }, block: { name: "block", title: "Centered image", icon: ym, modelElements: ["imageBlock"], isDefault: true }, side: { name: "side", title: "Side image", icon: vm, modelElements: ["imageBlock"], className: "image-style-side" } }, Tm = { full: wm, left: xm, right: Am, center: ym, inlineLeft: _m, inlineRight: vm, inline: km }, Em = [{ name: "imageStyle:wrapText", title: "Wrap text", defaultItem: "imageStyle:alignLeft", items: ["imageStyle:alignLeft", "imageStyle:alignRight"] }, { name: "imageStyle:breakText", title: "Break text", defaultItem: "imageStyle:block", items: ["imageStyle:alignBlockLeft", "imageStyle:block", "imageStyle:alignBlockRight"] }];
      function Im(e2) {
        Object(c.b)("image-style-configuration-definition-invalid", e2);
      }
      var Sm = { normalizeStyles: function(e2) {
        return (e2.configuredStyles.options || []).map((e3) => function(e4) {
          e4 = typeof e4 == "string" ? Cm[e4] ? __spreadValues({}, Cm[e4]) : { name: e4 } : function(e5, t2) {
            const i2 = __spreadValues({}, t2);
            for (const n2 in e5)
              Object.prototype.hasOwnProperty.call(t2, n2) || (i2[n2] = e5[n2]);
            return i2;
          }(Cm[e4.name], e4);
          typeof e4.icon == "string" && (e4.icon = Tm[e4.icon] || e4.icon);
          return e4;
        }(e3)).filter((t2) => function(e3, { isBlockPluginLoaded: t3, isInlinePluginLoaded: i2 }) {
          const { modelElements: n2, name: o2 } = e3;
          if (!(n2 && n2.length && o2))
            return Im({ style: e3 }), false;
          {
            const o3 = [t3 ? "imageBlock" : null, i2 ? "imageInline" : null];
            if (!n2.some((e4) => o3.includes(e4)))
              return Object(c.b)("image-style-missing-dependency", { style: e3, missingPlugins: n2.map((e4) => e4 === "imageBlock" ? "ImageBlockEditing" : "ImageInlineEditing") }), false;
          }
          return true;
        }(t2, e2));
      }, getDefaultStylesConfiguration: function(e2, t2) {
        return e2 && t2 ? { options: ["inline", "alignLeft", "alignRight", "alignCenter", "alignBlockLeft", "alignBlockRight", "block", "side"] } : e2 ? { options: ["block", "side"] } : t2 ? { options: ["inline", "alignLeft", "alignRight"] } : {};
      }, getDefaultDropdownDefinitions: function(e2) {
        return e2.has("ImageBlockEditing") && e2.has("ImageInlineEditing") ? [...Em] : [];
      }, warnInvalidStyle: Im, DEFAULT_OPTIONS: Cm, DEFAULT_ICONS: Tm, DEFAULT_DROPDOWN_DEFINITIONS: Em };
      function Pm(e2, t2) {
        for (const i2 of t2)
          if (i2.name === e2)
            return i2;
      }
      class Mm extends Qe {
        static get pluginName() {
          return "ImageStyleEditing";
        }
        static get requires() {
          return [Gg];
        }
        init() {
          const { normalizeStyles: e2, getDefaultStylesConfiguration: t2 } = Sm, i2 = this.editor, n2 = i2.plugins.has("ImageBlockEditing"), o2 = i2.plugins.has("ImageInlineEditing");
          i2.config.define("image.styles", t2(n2, o2)), this.normalizedStyles = e2({ configuredStyles: i2.config.get("image.styles"), isBlockPluginLoaded: n2, isInlinePluginLoaded: o2 }), this._setupConversion(n2, o2), this._setupPostFixer(), i2.commands.add("imageStyle", new bm(i2, this.normalizedStyles));
        }
        _setupConversion(e2, t2) {
          const i2 = this.editor, n2 = i2.model.schema, o2 = (r2 = this.normalizedStyles, (e3, t3, i3) => {
            if (!i3.consumable.consume(t3.item, e3.name))
              return;
            const n3 = Pm(t3.attributeNewValue, r2), o3 = Pm(t3.attributeOldValue, r2), s3 = i3.mapper.toViewElement(t3.item), a2 = i3.writer;
            o3 && a2.removeClass(o3.className, s3), n3 && a2.addClass(n3.className, s3);
          });
          var r2;
          const s2 = function(e3) {
            const t3 = { imageInline: e3.filter((e4) => !e4.isDefault && e4.modelElements.includes("imageInline")), imageBlock: e3.filter((e4) => !e4.isDefault && e4.modelElements.includes("imageBlock")) };
            return (e4, i3, n3) => {
              if (!i3.modelRange)
                return;
              const o3 = i3.viewItem, r3 = Ms(i3.modelRange.getItems());
              if (r3 && n3.schema.checkAttribute(r3, "imageStyle"))
                for (const e5 of t3[r3.name])
                  n3.consumable.consume(o3, { classes: e5.className }) && n3.writer.setAttribute("imageStyle", e5.name, r3);
            };
          }(this.normalizedStyles);
          i2.editing.downcastDispatcher.on("attribute:imageStyle", o2), i2.data.downcastDispatcher.on("attribute:imageStyle", o2), e2 && (n2.extend("imageBlock", { allowAttributes: "imageStyle" }), i2.data.upcastDispatcher.on("element:figure", s2, { priority: "low" })), t2 && (n2.extend("imageInline", { allowAttributes: "imageStyle" }), i2.data.upcastDispatcher.on("element:img", s2, { priority: "low" }));
        }
        _setupPostFixer() {
          const e2 = this.editor, t2 = e2.model.document, i2 = e2.plugins.get(Gg), n2 = new Map(this.normalizedStyles.map((e3) => [e3.name, e3]));
          t2.registerPostFixer((e3) => {
            let o2 = false;
            for (const r2 of t2.differ.getChanges())
              if (r2.type == "insert" || r2.type == "attribute" && r2.attributeKey == "imageStyle") {
                let t3 = r2.type == "insert" ? r2.position.nodeAfter : r2.range.start.nodeAfter;
                if (t3 && t3.is("element", "paragraph") && t3.childCount > 0 && (t3 = t3.getChild(0)), !i2.isImage(t3))
                  continue;
                const s2 = t3.getAttribute("imageStyle");
                if (!s2)
                  continue;
                const a2 = n2.get(s2);
                a2 && a2.modelElements.includes(t3.name) || (e3.removeAttribute("imageStyle", t3), o2 = true);
              }
            return o2;
          });
        }
      }
      i(80);
      class Nm extends Qe {
        static get requires() {
          return [Mm];
        }
        static get pluginName() {
          return "ImageStyleUI";
        }
        get localizedDefaultStylesTitles() {
          const e2 = this.editor.t;
          return { "Wrap text": e2("Wrap text"), "Break text": e2("Break text"), "In line": e2("In line"), "Full size image": e2("Full size image"), "Side image": e2("Side image"), "Left aligned image": e2("Left aligned image"), "Centered image": e2("Centered image"), "Right aligned image": e2("Right aligned image") };
        }
        init() {
          const e2 = this.editor.plugins, t2 = this.editor.config.get("image.toolbar") || [], i2 = Rm(e2.get("ImageStyleEditing").normalizedStyles, this.localizedDefaultStylesTitles);
          for (const e3 of i2)
            this._createButton(e3);
          const n2 = Rm([...t2.filter(w), ...Sm.getDefaultDropdownDefinitions(e2)], this.localizedDefaultStylesTitles);
          for (const e3 of n2)
            this._createDropdown(e3, i2);
        }
        _createDropdown(e2, t2) {
          const i2 = this.editor.ui.componentFactory;
          i2.add(e2.name, (n2) => {
            let o2;
            const { defaultItem: r2, items: s2, title: a2 } = e2, c2 = s2.filter((e3) => t2.find(({ name: t3 }) => Om(t3) === e3)).map((e3) => {
              const t3 = i2.create(e3);
              return e3 === r2 && (o2 = t3), t3;
            });
            s2.length !== c2.length && Sm.warnInvalidStyle({ dropdown: e2 });
            const l2 = xd(n2, ad), d2 = l2.buttonView;
            return Ad(l2, c2), d2.set({ label: zm(a2, o2.label), class: null, tooltip: true }), d2.bind("icon").toMany(c2, "isOn", (...e3) => {
              const t3 = e3.findIndex(Z);
              return t3 < 0 ? o2.icon : c2[t3].icon;
            }), d2.bind("label").toMany(c2, "isOn", (...e3) => {
              const t3 = e3.findIndex(Z);
              return zm(a2, t3 < 0 ? o2.label : c2[t3].label);
            }), d2.bind("isOn").toMany(c2, "isOn", (...e3) => e3.some(Z)), d2.bind("class").toMany(c2, "isOn", (...e3) => e3.some(Z) ? "ck-splitbutton_flatten" : null), d2.on("execute", () => {
              c2.some(({ isOn: e3 }) => e3) ? l2.isOpen = !l2.isOpen : o2.fire("execute");
            }), l2.bind("isEnabled").toMany(c2, "isEnabled", (...e3) => e3.some(Z)), l2;
          });
        }
        _createButton(e2) {
          const t2 = e2.name;
          this.editor.ui.componentFactory.add(Om(t2), (i2) => {
            const n2 = this.editor.commands.get("imageStyle"), o2 = new td(i2);
            return o2.set({ label: e2.title, icon: e2.icon, tooltip: true, isToggleable: true }), o2.bind("isEnabled").to(n2, "isEnabled"), o2.bind("isOn").to(n2, "value", (e3) => e3 === t2), o2.on("execute", this._executeCommand.bind(this, t2)), o2;
          });
        }
        _executeCommand(e2) {
          this.editor.execute("imageStyle", { value: e2 }), this.editor.editing.view.focus();
        }
      }
      function Rm(e2, t2) {
        for (const i2 of e2)
          t2[i2.title] && (i2.title = t2[i2.title]);
        return e2;
      }
      function Om(e2) {
        return "imageStyle:" + e2;
      }
      function zm(e2, t2) {
        return (e2 ? e2 + ": " : "") + t2;
      }
      function Dm(e2) {
        const t2 = e2.map((e3) => e3.replace("+", "\\+"));
        return new RegExp(`^image\\/(${t2.join("|")})$`);
      }
      function Lm(e2) {
        return new Promise((t2, i2) => {
          const n2 = e2.getAttribute("src");
          fetch(n2).then((e3) => e3.blob()).then((e3) => {
            const i3 = Vm(e3, n2), o2 = i3.replace("image/", ""), r2 = new File([e3], "image." + o2, { type: i3 });
            t2(r2);
          }).catch((e3) => e3 && e3.name === "TypeError" ? function(e4) {
            return function(e5) {
              return new Promise((t3, i3) => {
                const n3 = _r.document.createElement("img");
                n3.addEventListener("load", () => {
                  const e6 = _r.document.createElement("canvas");
                  e6.width = n3.width, e6.height = n3.height;
                  e6.getContext("2d").drawImage(n3, 0, 0), e6.toBlob((e7) => e7 ? t3(e7) : i3());
                }), n3.addEventListener("error", () => i3()), n3.src = e5;
              });
            }(e4).then((t3) => {
              const i3 = Vm(t3, e4), n3 = i3.replace("image/", "");
              return new File([t3], "image." + n3, { type: i3 });
            });
          }(n2).then(t2).catch(i2) : i2(e3));
        });
      }
      function Vm(e2, t2) {
        return e2.type ? e2.type : t2.match(/data:(image\/\w+);base64/) ? t2.match(/data:(image\/\w+);base64/)[1].toLowerCase() : "image/jpeg";
      }
      class jm extends Qe {
        static get pluginName() {
          return "ImageUploadUI";
        }
        init() {
          const e2 = this.editor, t2 = e2.t, i2 = (i3) => {
            const n2 = new rg(i3), o2 = e2.commands.get("uploadImage"), r2 = e2.config.get("image.upload.types"), s2 = Dm(r2);
            return n2.set({ acceptedType: r2.map((e3) => "image/" + e3).join(","), allowMultipleFiles: true }), n2.buttonView.set({ label: t2("Insert image"), icon: El.image, tooltip: true }), n2.buttonView.bind("isEnabled").to(o2), n2.on("done", (t3, i4) => {
              const n3 = Array.from(i4).filter((e3) => s2.test(e3.type));
              n3.length && e2.execute("uploadImage", { file: n3 });
            }), n2;
          };
          e2.ui.componentFactory.add("uploadImage", i2), e2.ui.componentFactory.add("imageUpload", i2);
        }
      }
      i(82), i(84), i(86);
      class Bm extends Qe {
        static get pluginName() {
          return "ImageUploadProgress";
        }
        constructor(e2) {
          super(e2), this.placeholder = "data:image/svg+xml;utf8," + encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 700 250"><rect rx="4"/></svg>');
        }
        init() {
          const e2 = this.editor;
          e2.plugins.has("ImageBlockEditing") && e2.editing.downcastDispatcher.on("attribute:uploadStatus:imageBlock", (...e3) => this.uploadStatusChange(...e3)), e2.plugins.has("ImageInlineEditing") && e2.editing.downcastDispatcher.on("attribute:uploadStatus:imageInline", (...e3) => this.uploadStatusChange(...e3));
        }
        uploadStatusChange(e2, t2, i2) {
          const n2 = this.editor, o2 = t2.item, r2 = o2.getAttribute("uploadId");
          if (!i2.consumable.consume(t2.item, e2.name))
            return;
          const s2 = n2.plugins.get("ImageUtils"), a2 = n2.plugins.get(ng), c2 = r2 ? t2.attributeNewValue : null, l2 = this.placeholder, d2 = n2.editing.mapper.toViewElement(o2), h2 = i2.writer;
          if (c2 == "reading")
            return Fm(d2, h2), void Hm(s2, l2, d2, h2);
          if (c2 == "uploading") {
            const e3 = a2.loaders.get(r2);
            return Fm(d2, h2), void (e3 ? (Um(d2, h2), function(e4, t3, i3, n3) {
              const o3 = function(e5) {
                const t4 = e5.createUIElement("div", { class: "ck-progress-bar" });
                return e5.setCustomProperty("progressBar", true, t4), t4;
              }(t3);
              t3.insert(t3.createPositionAt(e4, "end"), o3), i3.on("change:uploadedPercent", (e5, t4, i4) => {
                n3.change((e6) => {
                  e6.setStyle("width", i4 + "%", o3);
                });
              });
            }(d2, h2, e3, n2.editing.view), function(e4, t3, i3, n3) {
              if (n3.data) {
                const o3 = e4.findViewImgElement(t3);
                i3.setAttribute("src", n3.data, o3);
              }
            }(s2, d2, h2, e3)) : Hm(s2, l2, d2, h2));
          }
          c2 == "complete" && a2.loaders.get(r2) && function(e3, t3, i3) {
            const n3 = t3.createUIElement("div", { class: "ck-image-upload-complete-icon" });
            t3.insert(t3.createPositionAt(e3, "end"), n3), setTimeout(() => {
              i3.change((e4) => e4.remove(e4.createRangeOn(n3)));
            }, 3e3);
          }(d2, h2, n2.editing.view), function(e3, t3) {
            qm(e3, t3, "progressBar");
          }(d2, h2), Um(d2, h2), function(e3, t3) {
            t3.removeClass("ck-appear", e3);
          }(d2, h2);
        }
      }
      function Fm(e2, t2) {
        e2.hasClass("ck-appear") || t2.addClass("ck-appear", e2);
      }
      function Hm(e2, t2, i2, n2) {
        i2.hasClass("ck-image-upload-placeholder") || n2.addClass("ck-image-upload-placeholder", i2);
        const o2 = e2.findViewImgElement(i2);
        o2.getAttribute("src") !== t2 && n2.setAttribute("src", t2, o2), Wm(i2, "placeholder") || n2.insert(n2.createPositionAfter(o2), function(e3) {
          const t3 = e3.createUIElement("div", { class: "ck-upload-placeholder-loader" });
          return e3.setCustomProperty("placeholder", true, t3), t3;
        }(n2));
      }
      function Um(e2, t2) {
        e2.hasClass("ck-image-upload-placeholder") && t2.removeClass("ck-image-upload-placeholder", e2), qm(e2, t2, "placeholder");
      }
      function Wm(e2, t2) {
        for (const i2 of e2.getChildren())
          if (i2.getCustomProperty(t2))
            return i2;
      }
      function qm(e2, t2, i2) {
        const n2 = Wm(e2, i2);
        n2 && t2.remove(t2.createRangeOn(n2));
      }
      class $m extends Ze {
        refresh() {
          const e2 = this.editor, t2 = e2.plugins.get("ImageUtils"), i2 = e2.model.document.selection.getSelectedElement();
          this.isEnabled = t2.isImageAllowed() || t2.isImage(i2);
        }
        execute(e2) {
          const t2 = en(e2.file), i2 = this.editor.model.document.selection, n2 = this.editor.plugins.get("ImageUtils"), o2 = Object.fromEntries(i2.getAttributes());
          t2.forEach((e3, t3) => {
            const r2 = i2.getSelectedElement();
            if (t3 && r2 && n2.isImage(r2)) {
              const t4 = this.editor.model.createPositionAfter(r2);
              this._uploadImage(e3, o2, t4);
            } else
              this._uploadImage(e3, o2);
          });
        }
        _uploadImage(e2, t2, i2) {
          const n2 = this.editor, o2 = n2.plugins.get(ng).createLoader(e2), r2 = n2.plugins.get("ImageUtils");
          o2 && r2.insertImage(__spreadProps(__spreadValues({}, t2), { uploadId: o2.id }), i2);
        }
      }
      class Ym extends Qe {
        static get requires() {
          return [ng, Od, _h, Gg];
        }
        static get pluginName() {
          return "ImageUploadEditing";
        }
        constructor(e2) {
          super(e2), e2.config.define("image", { upload: { types: ["jpeg", "png", "gif", "bmp", "webp", "tiff"] } }), this._uploadImageElements = new Map();
        }
        init() {
          const e2 = this.editor, t2 = e2.model.document, i2 = e2.conversion, n2 = e2.plugins.get(ng), o2 = e2.plugins.get("ImageUtils"), r2 = Dm(e2.config.get("image.upload.types")), s2 = new $m(e2);
          e2.commands.add("uploadImage", s2), e2.commands.add("imageUpload", s2), i2.for("upcast").attributeToAttribute({ view: { name: "img", key: "uploadId" }, model: "uploadId" }), this.listenTo(e2.editing.view.document, "clipboardInput", (t3, i3) => {
            if (n3 = i3.dataTransfer, Array.from(n3.types).includes("text/html") && n3.getData("text/html") !== "")
              return;
            var n3;
            const o3 = Array.from(i3.dataTransfer.files).filter((e3) => !!e3 && r2.test(e3.type));
            o3.length && (t3.stop(), e2.model.change((t4) => {
              i3.targetRanges && t4.setSelection(i3.targetRanges.map((t5) => e2.editing.mapper.toModelRange(t5))), e2.model.enqueueChange("default", () => {
                e2.execute("uploadImage", { file: o3 });
              });
            }));
          }), this.listenTo(e2.plugins.get("ClipboardPipeline"), "inputTransformation", (t3, i3) => {
            const r3 = Array.from(e2.editing.view.createRangeIn(i3.content)).filter((e3) => function(e4, t4) {
              return !(!e4.isInlineImageView(t4) || !t4.getAttribute("src")) && (t4.getAttribute("src").match(/^data:image\/\w+;base64,/g) || t4.getAttribute("src").match(/^blob:/g));
            }(o2, e3.item) && !e3.item.getAttribute("uploadProcessed")).map((e3) => ({ promise: Lm(e3.item), imageElement: e3.item }));
            if (!r3.length)
              return;
            const s3 = new gh(e2.editing.view.document);
            for (const e3 of r3) {
              s3.setAttribute("uploadProcessed", true, e3.imageElement);
              const t4 = n2.createLoader(e3.promise);
              t4 && (s3.setAttribute("src", "", e3.imageElement), s3.setAttribute("uploadId", t4.id, e3.imageElement));
            }
          }), e2.editing.view.document.on("dragover", (e3, t3) => {
            t3.preventDefault();
          }), t2.on("change", () => {
            const i3 = t2.differ.getChanges({ includeChangesInGraveyard: true }).reverse(), o3 = new Set();
            for (const t3 of i3)
              if (t3.type == "insert" && t3.name != "$text") {
                const i4 = t3.position.nodeAfter, r3 = t3.position.root.rootName == "$graveyard";
                for (const t4 of Gm(e2, i4)) {
                  const e3 = t4.getAttribute("uploadId");
                  if (!e3)
                    continue;
                  const i5 = n2.loaders.get(e3);
                  i5 && (r3 ? o3.has(e3) || i5.abort() : (o3.add(e3), this._uploadImageElements.set(e3, t4), i5.status == "idle" && this._readAndUpload(i5)));
                }
              }
          }), this.on("uploadComplete", (e3, { imageElement: t3, data: i3 }) => {
            const n3 = i3.urls ? i3.urls : i3;
            this.editor.model.change((e4) => {
              e4.setAttribute("src", n3.default, t3), this._parseAndSetSrcsetAttributeOnImage(n3, t3, e4);
            });
          }, { priority: "low" });
        }
        afterInit() {
          const e2 = this.editor.model.schema;
          this.editor.plugins.has("ImageBlockEditing") && e2.extend("imageBlock", { allowAttributes: ["uploadId", "uploadStatus"] }), this.editor.plugins.has("ImageInlineEditing") && e2.extend("imageInline", { allowAttributes: ["uploadId", "uploadStatus"] });
        }
        _readAndUpload(e2) {
          const t2 = this.editor, i2 = t2.model, n2 = t2.locale.t, o2 = t2.plugins.get(ng), r2 = t2.plugins.get(Od), s2 = t2.plugins.get("ImageUtils"), a2 = this._uploadImageElements;
          return i2.enqueueChange("transparent", (t3) => {
            t3.setAttribute("uploadStatus", "reading", a2.get(e2.id));
          }), e2.read().then(() => {
            const n3 = e2.upload(), o3 = a2.get(e2.id);
            if (So.isSafari) {
              const e3 = t2.editing.mapper.toViewElement(o3), i3 = s2.findViewImgElement(e3);
              t2.editing.view.once("render", () => {
                if (!i3.parent)
                  return;
                const e4 = t2.editing.view.domConverter.mapViewToDom(i3.parent);
                if (!e4)
                  return;
                const n4 = e4.style.display;
                e4.style.display = "none", e4._ckHack = e4.offsetHeight, e4.style.display = n4;
              });
            }
            return i2.enqueueChange("transparent", (e3) => {
              e3.setAttribute("uploadStatus", "uploading", o3);
            }), n3;
          }).then((t3) => {
            i2.enqueueChange("transparent", (i3) => {
              const n3 = a2.get(e2.id);
              i3.setAttribute("uploadStatus", "complete", n3), this.fire("uploadComplete", { data: t3, imageElement: n3 });
            }), c2();
          }).catch((t3) => {
            if (e2.status !== "error" && e2.status !== "aborted")
              throw t3;
            e2.status == "error" && t3 && r2.showWarning(t3, { title: n2("Upload failed"), namespace: "upload" }), i2.enqueueChange("transparent", (t4) => {
              t4.remove(a2.get(e2.id));
            }), c2();
          });
          function c2() {
            i2.enqueueChange("transparent", (t3) => {
              const i3 = a2.get(e2.id);
              t3.removeAttribute("uploadId", i3), t3.removeAttribute("uploadStatus", i3), a2.delete(e2.id);
            }), o2.destroyLoader(e2);
          }
        }
        _parseAndSetSrcsetAttributeOnImage(e2, t2, i2) {
          let n2 = 0;
          const o2 = Object.keys(e2).filter((e3) => {
            const t3 = parseInt(e3, 10);
            if (!isNaN(t3))
              return n2 = Math.max(n2, t3), true;
          }).map((t3) => `${e2[t3]} ${t3}w`).join(", ");
          o2 != "" && i2.setAttribute("srcset", { data: o2, width: n2 }, t2);
        }
      }
      function Gm(e2, t2) {
        const i2 = e2.plugins.get("ImageUtils");
        return Array.from(e2.model.createRangeOn(t2)).filter((e3) => i2.isImage(e3.item)).map((e3) => e3.item);
      }
      class Km extends Qe {
        static get pluginName() {
          return "IndentEditing";
        }
        init() {
          const e2 = this.editor;
          e2.commands.add("indent", new et(e2)), e2.commands.add("outdent", new et(e2));
        }
      }
      var Qm = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zM1.632 6.95 5.02 9.358a.4.4 0 0 1-.013.661l-3.39 2.207A.4.4 0 0 1 1 11.892V7.275a.4.4 0 0 1 .632-.326z"/></svg>', Jm = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zm1.618-9.55L.98 9.358a.4.4 0 0 0 .013.661l3.39 2.207A.4.4 0 0 0 5 11.892V7.275a.4.4 0 0 0-.632-.326z"/></svg>';
      class Zm extends Qe {
        static get pluginName() {
          return "IndentUI";
        }
        init() {
          const e2 = this.editor, t2 = e2.locale, i2 = e2.t, n2 = t2.uiLanguageDirection == "ltr" ? Qm : Jm, o2 = t2.uiLanguageDirection == "ltr" ? Jm : Qm;
          this._defineButton("indent", i2("Increase indent"), n2), this._defineButton("outdent", i2("Decrease indent"), o2);
        }
        _defineButton(e2, t2, i2) {
          const n2 = this.editor;
          n2.ui.componentFactory.add(e2, (o2) => {
            const r2 = n2.commands.get(e2), s2 = new td(o2);
            return s2.set({ label: t2, icon: i2, tooltip: true }), s2.bind("isOn", "isEnabled").to(r2, "value", "isEnabled"), this.listenTo(s2, "execute", () => {
              n2.execute(e2), n2.editing.view.focus();
            }), s2;
          });
        }
      }
      class Xm {
        constructor() {
          this._definitions = new Set();
        }
        get length() {
          return this._definitions.size;
        }
        add(e2) {
          Array.isArray(e2) ? e2.forEach((e3) => this._definitions.add(e3)) : this._definitions.add(e2);
        }
        getDispatcher() {
          return (e2) => {
            e2.on("attribute:linkHref", (e3, t2, i2) => {
              if (!i2.consumable.test(t2.item, "attribute:linkHref"))
                return;
              const n2 = i2.writer, o2 = n2.document.selection;
              for (const e4 of this._definitions) {
                const r2 = n2.createAttributeElement("a", e4.attributes, { priority: 5 });
                e4.classes && n2.addClass(e4.classes, r2);
                for (const t3 in e4.styles)
                  n2.setStyle(t3, e4.styles[t3], r2);
                n2.setCustomProperty("link", true, r2), e4.callback(t2.attributeNewValue) ? t2.item.is("selection") ? n2.wrap(o2.getFirstRange(), r2) : n2.wrap(i2.mapper.toViewRange(t2.range), r2) : n2.unwrap(i2.mapper.toViewRange(t2.range), r2);
              }
            }, { priority: "high" });
          };
        }
        getDispatcherForLinkedImage() {
          return (e2) => {
            e2.on("attribute:linkHref:imageBlock", (e3, t2, { writer: i2, mapper: n2 }) => {
              const o2 = n2.toViewElement(t2.item), r2 = Array.from(o2.getChildren()).find((e4) => e4.name === "a");
              for (const e4 of this._definitions) {
                const n3 = gn(e4.attributes);
                if (e4.callback(t2.attributeNewValue)) {
                  for (const [e5, t3] of n3)
                    e5 === "class" ? i2.addClass(t3, r2) : i2.setAttribute(e5, t3, r2);
                  e4.classes && i2.addClass(e4.classes, r2);
                  for (const t3 in e4.styles)
                    i2.setStyle(t3, e4.styles[t3], r2);
                } else {
                  for (const [e5, t3] of n3)
                    e5 === "class" ? i2.removeClass(t3, r2) : i2.removeAttribute(e5, r2);
                  e4.classes && i2.removeClass(e4.classes, r2);
                  for (const t3 in e4.styles)
                    i2.removeStyle(t3, r2);
                }
              }
            });
          };
        }
      }
      var ef = function(e2, t2, i2) {
        var n2 = e2.length;
        return i2 = i2 === void 0 ? n2 : i2, !t2 && i2 >= n2 ? e2 : zn(e2, t2, i2);
      }, tf = RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]");
      var nf = function(e2) {
        return tf.test(e2);
      };
      var of = function(e2) {
        return e2.split("");
      }, rf = "[\\ud800-\\udfff]", sf = "[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]", af = "\\ud83c[\\udffb-\\udfff]", cf = "[^\\ud800-\\udfff]", lf = "(?:\\ud83c[\\udde6-\\uddff]){2}", df = "[\\ud800-\\udbff][\\udc00-\\udfff]", hf = "(?:" + sf + "|" + af + ")?", uf = "[\\ufe0e\\ufe0f]?" + hf + ("(?:\\u200d(?:" + [cf, lf, df].join("|") + ")[\\ufe0e\\ufe0f]?" + hf + ")*"), gf = "(?:" + [cf + sf + "?", sf, lf, df, rf].join("|") + ")", mf = RegExp(af + "(?=" + af + ")|" + gf + uf, "g");
      var ff = function(e2) {
        return e2.match(mf) || [];
      };
      var pf = function(e2) {
        return nf(e2) ? ff(e2) : of(e2);
      };
      var bf = function(e2) {
        return function(t2) {
          t2 = Pn(t2);
          var i2 = nf(t2) ? pf(t2) : void 0, n2 = i2 ? i2[0] : t2.charAt(0), o2 = i2 ? ef(i2, 1).join("") : t2.slice(1);
          return n2[e2]() + o2;
        };
      }("toUpperCase");
      const wf = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g, kf = /^(?:(?:https?|ftps?|mailto):|[^a-z]|[a-z+.-]+(?:[^a-z+.:-]|$))/i, _f = /^[\S]+@((?![-_])(?:[-\w\u00a1-\uffff]{0,63}[^-_]\.))+(?:[a-z\u00a1-\uffff]{2,})$/i, vf = /^((\w+:(\/{2,})?)|(\W))/i;
      function yf(e2, { writer: t2 }) {
        const i2 = t2.createAttributeElement("a", { href: e2 }, { priority: 5 });
        return t2.setCustomProperty("link", true, i2), i2;
      }
      function xf(e2) {
        return function(e3) {
          return e3.replace(wf, "").match(kf);
        }(e2 = String(e2)) ? e2 : "#";
      }
      function Af(e2, t2) {
        return !!e2 && t2.checkAttribute(e2.name, "linkHref");
      }
      function Cf(e2, t2) {
        const i2 = (n2 = e2, _f.test(n2) ? "mailto:" : t2);
        var n2;
        const o2 = !!i2 && !vf.test(e2);
        return e2 && o2 ? i2 + e2 : e2;
      }
      class Tf extends Ze {
        constructor(e2) {
          super(e2), this.manualDecorators = new Zi(), this.automaticDecorators = new Xm();
        }
        restoreManualDecoratorStates() {
          for (const e2 of this.manualDecorators)
            e2.value = this._getDecoratorStateFromModel(e2.id);
        }
        refresh() {
          const e2 = this.editor.model, t2 = e2.document.selection, i2 = t2.getSelectedElement() || Ms(t2.getSelectedBlocks());
          Af(i2, e2.schema) ? (this.value = i2.getAttribute("linkHref"), this.isEnabled = e2.schema.checkAttribute(i2, "linkHref")) : (this.value = t2.getAttribute("linkHref"), this.isEnabled = e2.schema.checkAttributeInSelection(t2, "linkHref"));
          for (const e3 of this.manualDecorators)
            e3.value = this._getDecoratorStateFromModel(e3.id);
        }
        execute(e2, t2 = {}) {
          const i2 = this.editor.model, n2 = i2.document.selection, o2 = [], r2 = [];
          for (const e3 in t2)
            t2[e3] ? o2.push(e3) : r2.push(e3);
          i2.change((t3) => {
            if (n2.isCollapsed) {
              const s2 = n2.getFirstPosition();
              if (n2.hasAttribute("linkHref")) {
                const a2 = Wu(s2, "linkHref", n2.getAttribute("linkHref"), i2);
                t3.setAttribute("linkHref", e2, a2), o2.forEach((e3) => {
                  t3.setAttribute(e3, true, a2);
                }), r2.forEach((e3) => {
                  t3.removeAttribute(e3, a2);
                }), t3.setSelection(t3.createPositionAfter(a2.end.nodeBefore));
              } else if (e2 !== "") {
                const r3 = gn(n2.getAttributes());
                r3.set("linkHref", e2), o2.forEach((e3) => {
                  r3.set(e3, true);
                });
                const { end: a2 } = i2.insertContent(t3.createText(e2, r3), s2);
                t3.setSelection(a2);
              }
              ["linkHref", ...o2, ...r2].forEach((e3) => {
                t3.removeSelectionAttribute(e3);
              });
            } else {
              const s2 = i2.schema.getValidRanges(n2.getRanges(), "linkHref"), a2 = [];
              for (const e3 of n2.getSelectedBlocks())
                i2.schema.checkAttribute(e3, "linkHref") && a2.push(t3.createRangeOn(e3));
              const c2 = a2.slice();
              for (const e3 of s2)
                this._isRangeToUpdate(e3, a2) && c2.push(e3);
              for (const i3 of c2)
                t3.setAttribute("linkHref", e2, i3), o2.forEach((e3) => {
                  t3.setAttribute(e3, true, i3);
                }), r2.forEach((e3) => {
                  t3.removeAttribute(e3, i3);
                });
            }
          });
        }
        _getDecoratorStateFromModel(e2) {
          const t2 = this.editor.model, i2 = t2.document.selection, n2 = i2.getSelectedElement();
          return Af(n2, t2.schema) ? n2.getAttribute(e2) : i2.getAttribute(e2);
        }
        _isRangeToUpdate(e2, t2) {
          for (const i2 of t2)
            if (i2.containsRange(e2))
              return false;
          return true;
        }
      }
      class Ef extends Ze {
        refresh() {
          const e2 = this.editor.model, t2 = e2.document.selection, i2 = t2.getSelectedElement();
          Af(i2, e2.schema) ? this.isEnabled = e2.schema.checkAttribute(i2, "linkHref") : this.isEnabled = e2.schema.checkAttributeInSelection(t2, "linkHref");
        }
        execute() {
          const e2 = this.editor, t2 = this.editor.model, i2 = t2.document.selection, n2 = e2.commands.get("link");
          t2.change((e3) => {
            const o2 = i2.isCollapsed ? [Wu(i2.getFirstPosition(), "linkHref", i2.getAttribute("linkHref"), t2)] : t2.schema.getValidRanges(i2.getRanges(), "linkHref");
            for (const t3 of o2)
              if (e3.removeAttribute("linkHref", t3), n2)
                for (const i3 of n2.manualDecorators)
                  e3.removeAttribute(i3.id, t3);
          });
        }
      }
      class If {
        constructor({ id: e2, label: t2, attributes: i2, classes: n2, styles: o2, defaultValue: r2 }) {
          this.id = e2, this.set("value"), this.defaultValue = r2, this.label = t2, this.attributes = i2, this.classes = n2, this.styles = o2;
        }
        _createPattern() {
          return { attributes: this.attributes, classes: this.classes, styles: this.styles };
        }
      }
      Ke(If, Ue);
      i(88);
      const Sf = /^(https?:)?\/\//;
      class Pf extends Qe {
        static get pluginName() {
          return "LinkEditing";
        }
        static get requires() {
          return [Su, Cu, _h];
        }
        constructor(e2) {
          super(e2), e2.config.define("link", { addTargetToExternalLinks: false });
        }
        init() {
          const e2 = this.editor;
          e2.model.schema.extend("$text", { allowAttributes: "linkHref" }), e2.conversion.for("dataDowncast").attributeToElement({ model: "linkHref", view: yf }), e2.conversion.for("editingDowncast").attributeToElement({ model: "linkHref", view: (e3, t3) => yf(xf(e3), t3) }), e2.conversion.for("upcast").elementToAttribute({ view: { name: "a", attributes: { href: true } }, model: { key: "linkHref", value: (e3) => e3.getAttribute("href") } }), e2.commands.add("link", new Tf(e2)), e2.commands.add("unlink", new Ef(e2));
          const t2 = function(e3, t3) {
            const i2 = { "Open in a new tab": e3("Open in a new tab"), Downloadable: e3("Downloadable") };
            return t3.forEach((e4) => (e4.label && i2[e4.label] && (e4.label = i2[e4.label]), e4)), t3;
          }(e2.t, function(e3) {
            const t3 = [];
            if (e3)
              for (const [i2, n2] of Object.entries(e3)) {
                const e4 = Object.assign({}, n2, { id: "link" + bf(i2) });
                t3.push(e4);
              }
            return t3;
          }(e2.config.get("link.decorators")));
          this._enableAutomaticDecorators(t2.filter((e3) => e3.mode === "automatic")), this._enableManualDecorators(t2.filter((e3) => e3.mode === "manual"));
          e2.plugins.get(Su).registerAttribute("linkHref"), function(e3, t3, i2, n2) {
            const o2 = e3.editing.view, r2 = new Set();
            o2.document.registerPostFixer((o3) => {
              const s2 = e3.model.document.selection;
              let a2 = false;
              if (s2.hasAttribute(t3)) {
                const c2 = Wu(s2.getFirstPosition(), t3, s2.getAttribute(t3), e3.model), l2 = e3.editing.mapper.toViewRange(c2);
                for (const e4 of l2.getItems())
                  e4.is("element", i2) && !e4.hasClass(n2) && (o3.addClass(n2, e4), r2.add(e4), a2 = true);
              }
              return a2;
            }), e3.conversion.for("editingDowncast").add((e4) => {
              function t4() {
                o2.change((e5) => {
                  for (const t5 of r2.values())
                    e5.removeClass(n2, t5), r2.delete(t5);
                });
              }
              e4.on("insert", t4, { priority: "highest" }), e4.on("remove", t4, { priority: "highest" }), e4.on("attribute", t4, { priority: "highest" }), e4.on("selection", t4, { priority: "highest" });
            });
          }(e2, "linkHref", "a", "ck-link_selected"), this._enableInsertContentSelectionAttributesFixer(), this._enableClickingAfterLink(), this._enableTypingOverLink(), this._handleDeleteContentAfterLink();
        }
        _enableAutomaticDecorators(e2) {
          const t2 = this.editor, i2 = t2.commands.get("link").automaticDecorators;
          t2.config.get("link.addTargetToExternalLinks") && i2.add({ id: "linkIsExternal", mode: "automatic", callback: (e3) => Sf.test(e3), attributes: { target: "_blank", rel: "noopener noreferrer" } }), i2.add(e2), i2.length && t2.conversion.for("downcast").add(i2.getDispatcher());
        }
        _enableManualDecorators(e2) {
          if (!e2.length)
            return;
          const t2 = this.editor, i2 = t2.commands.get("link").manualDecorators;
          e2.forEach((e3) => {
            t2.model.schema.extend("$text", { allowAttributes: e3.id }), e3 = new If(e3), i2.add(e3), t2.conversion.for("downcast").attributeToElement({ model: e3.id, view: (t3, { writer: i3 }) => {
              if (t3) {
                const t4 = i3.createAttributeElement("a", e3.attributes, { priority: 5 });
                e3.classes && i3.addClass(e3.classes, t4);
                for (const n2 in e3.styles)
                  i3.setStyle(n2, e3.styles[n2], t4);
                return i3.setCustomProperty("link", true, t4), t4;
              }
            } }), t2.conversion.for("upcast").elementToAttribute({ view: __spreadValues({ name: "a" }, e3._createPattern()), model: { key: e3.id } });
          });
        }
        _enableInsertContentSelectionAttributesFixer() {
          const e2 = this.editor.model, t2 = e2.document.selection;
          this.listenTo(e2, "insertContent", () => {
            const i2 = t2.anchor.nodeBefore, n2 = t2.anchor.nodeAfter;
            t2.hasAttribute("linkHref") && i2 && i2.hasAttribute("linkHref") && (n2 && n2.hasAttribute("linkHref") || e2.change((t3) => {
              Mf(t3, Rf(e2.schema));
            }));
          }, { priority: "low" });
        }
        _enableClickingAfterLink() {
          const e2 = this.editor, t2 = e2.model;
          e2.editing.view.addObserver(uh);
          let i2 = false;
          this.listenTo(e2.editing.view.document, "mousedown", () => {
            i2 = true;
          }), this.listenTo(e2.editing.view.document, "selectionChange", () => {
            if (!i2)
              return;
            i2 = false;
            const e3 = t2.document.selection;
            if (!e3.isCollapsed)
              return;
            if (!e3.hasAttribute("linkHref"))
              return;
            const n2 = e3.getFirstPosition(), o2 = Wu(n2, "linkHref", e3.getAttribute("linkHref"), t2);
            (n2.isTouching(o2.start) || n2.isTouching(o2.end)) && t2.change((e4) => {
              Mf(e4, Rf(t2.schema));
            });
          });
        }
        _enableTypingOverLink() {
          const e2 = this.editor, t2 = e2.editing.view;
          let i2, n2;
          this.listenTo(t2.document, "delete", () => {
            n2 = true;
          }, { priority: "high" }), this.listenTo(e2.model, "deleteContent", () => {
            const t3 = e2.model.document.selection;
            t3.isCollapsed || (n2 ? n2 = false : Nf(e2) && function(e3) {
              const t4 = e3.document.selection, i3 = t4.getFirstPosition(), n3 = t4.getLastPosition(), o2 = i3.nodeAfter;
              if (!o2)
                return false;
              if (!o2.is("$text"))
                return false;
              if (!o2.hasAttribute("linkHref"))
                return false;
              const r2 = n3.textNode || n3.nodeBefore;
              if (o2 === r2)
                return true;
              return Wu(i3, "linkHref", o2.getAttribute("linkHref"), e3).containsRange(e3.createRange(i3, n3), true);
            }(e2.model) && (i2 = t3.getAttributes()));
          }, { priority: "high" }), this.listenTo(e2.model, "insertContent", (t3, [o2]) => {
            n2 = false, Nf(e2) && i2 && (e2.model.change((e3) => {
              for (const [t4, n3] of i2)
                e3.setAttribute(t4, n3, o2);
            }), i2 = null);
          }, { priority: "high" });
        }
        _handleDeleteContentAfterLink() {
          const e2 = this.editor, t2 = e2.model, i2 = t2.document.selection, n2 = e2.editing.view;
          let o2 = false, r2 = false;
          this.listenTo(n2.document, "delete", (e3, t3) => {
            r2 = t3.domEvent.keyCode === No.backspace;
          }, { priority: "high" }), this.listenTo(t2, "deleteContent", () => {
            o2 = false;
            const e3 = i2.getFirstPosition(), n3 = i2.getAttribute("linkHref");
            if (!n3)
              return;
            const r3 = Wu(e3, "linkHref", n3, t2);
            o2 = r3.containsPosition(e3) || r3.end.isEqual(e3);
          }, { priority: "high" }), this.listenTo(t2, "deleteContent", () => {
            r2 && (r2 = false, o2 || e2.model.enqueueChange((e3) => {
              Mf(e3, Rf(t2.schema));
            }));
          }, { priority: "low" });
        }
      }
      function Mf(e2, t2) {
        e2.removeSelectionAttribute("linkHref");
        for (const i2 of t2)
          e2.removeSelectionAttribute(i2);
      }
      function Nf(e2) {
        return e2.plugins.get("Input").isInput(e2.model.change((e3) => e3.batch));
      }
      function Rf(e2) {
        return e2.getDefinition("$text").allowAttributes.filter((e3) => e3.startsWith("link"));
      }
      i(90);
      class Of extends Nl {
        constructor(e2, t2) {
          super(e2);
          const i2 = e2.t;
          this.focusTracker = new Ns(), this.keystrokes = new Rs(), this.urlInputView = this._createUrlInput(), this.saveButtonView = this._createButton(i2("Save"), El.check, "ck-button-save"), this.saveButtonView.type = "submit", this.cancelButtonView = this._createButton(i2("Cancel"), El.cancel, "ck-button-cancel", "cancel"), this._manualDecoratorSwitches = this._createManualDecoratorSwitches(t2), this.children = this._createFormChildren(t2.manualDecorators), this._focusables = new Ml(), this._focusCycler = new nd({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } });
          const n2 = ["ck", "ck-link-form", "ck-responsive-form"];
          t2.manualDecorators.length && n2.push("ck-link-form_layout-vertical", "ck-vertical-form"), this.setTemplate({ tag: "form", attributes: { class: n2, tabindex: "-1" }, children: this.children }), Sl(this);
        }
        getDecoratorSwitchesState() {
          return Array.from(this._manualDecoratorSwitches).reduce((e2, t2) => (e2[t2.name] = t2.isOn, e2), {});
        }
        render() {
          super.render(), Pl({ view: this });
          [this.urlInputView, ...this._manualDecoratorSwitches, this.saveButtonView, this.cancelButtonView].forEach((e2) => {
            this._focusables.add(e2), this.focusTracker.add(e2.element);
          }), this.keystrokes.listenTo(this.element);
        }
        focus() {
          this._focusCycler.focusFirst();
        }
        _createUrlInput() {
          const e2 = this.locale.t, t2 = new Nd(this.locale, Rd);
          return t2.label = e2("Link URL"), t2;
        }
        _createButton(e2, t2, i2, n2) {
          const o2 = new td(this.locale);
          return o2.set({ label: e2, icon: t2, tooltip: true }), o2.extendTemplate({ attributes: { class: i2 } }), n2 && o2.delegate("execute").to(this, n2), o2;
        }
        _createManualDecoratorSwitches(e2) {
          const t2 = this.createCollection();
          for (const i2 of e2.manualDecorators) {
            const n2 = new id(this.locale);
            n2.set({ name: i2.id, label: i2.label, withText: true }), n2.bind("isOn").toMany([i2, e2], "value", (e3, t3) => t3 === void 0 && e3 === void 0 ? i2.defaultValue : e3), n2.on("execute", () => {
              i2.set("value", !n2.isOn);
            }), t2.add(n2);
          }
          return t2;
        }
        _createFormChildren(e2) {
          const t2 = this.createCollection();
          if (t2.add(this.urlInputView), e2.length) {
            const e3 = new Nl();
            e3.setTemplate({ tag: "ul", children: this._manualDecoratorSwitches.map((e4) => ({ tag: "li", children: [e4], attributes: { class: ["ck", "ck-list__item"] } })), attributes: { class: ["ck", "ck-reset", "ck-list"] } }), t2.add(e3);
          }
          return t2.add(this.saveButtonView), t2.add(this.cancelButtonView), t2;
        }
      }
      i(92);
      class zf extends Nl {
        constructor(e2) {
          super(e2);
          const t2 = e2.t;
          this.focusTracker = new Ns(), this.keystrokes = new Rs(), this.previewButtonView = this._createPreviewButton(), this.unlinkButtonView = this._createButton(t2("Unlink"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184zm4.919 10.562-1.414 1.414a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.061-1.06l1.414 1.414 1.414-1.415a.75.75 0 0 1 1.061 1.061l-1.414 1.414 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414z"/></svg>', "unlink"), this.editButtonView = this._createButton(t2("Edit link"), El.pencil, "edit"), this.set("href"), this._focusables = new Ml(), this._focusCycler = new nd({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-link-actions", "ck-responsive-form"], tabindex: "-1" }, children: [this.previewButtonView, this.editButtonView, this.unlinkButtonView] });
        }
        render() {
          super.render();
          [this.previewButtonView, this.editButtonView, this.unlinkButtonView].forEach((e2) => {
            this._focusables.add(e2), this.focusTracker.add(e2.element);
          }), this.keystrokes.listenTo(this.element);
        }
        focus() {
          this._focusCycler.focusFirst();
        }
        _createButton(e2, t2, i2) {
          const n2 = new td(this.locale);
          return n2.set({ label: e2, icon: t2, tooltip: true }), n2.delegate("execute").to(this, i2), n2;
        }
        _createPreviewButton() {
          const e2 = new td(this.locale), t2 = this.bindTemplate, i2 = this.t;
          return e2.set({ withText: true, tooltip: i2("Open link in new tab") }), e2.extendTemplate({ attributes: { class: ["ck", "ck-link-actions__preview"], href: t2.to("href", (e3) => e3 && xf(e3)), target: "_blank", rel: "noopener noreferrer" } }), e2.bind("label").to(this, "href", (e3) => e3 || i2("This link has no URL")), e2.bind("isEnabled").to(this, "href", (e3) => !!e3), e2.template.tag = "a", e2.template.eventListeners = {}, e2;
        }
      }
      class Df extends Qe {
        static get requires() {
          return [Ud];
        }
        static get pluginName() {
          return "LinkUI";
        }
        init() {
          const e2 = this.editor;
          e2.editing.view.addObserver(hh), this.actionsView = this._createActionsView(), this.formView = this._createFormView(), this._balloon = e2.plugins.get(Ud), this._createToolbarLinkButton(), this._enableUserBalloonInteractions(), e2.conversion.for("editingDowncast").markerToHighlight({ model: "link-ui", view: { classes: ["ck-fake-link-selection"] } }), e2.conversion.for("editingDowncast").markerToElement({ model: "link-ui", view: { name: "span", classes: ["ck-fake-link-selection", "ck-fake-link-selection_collapsed"] } });
        }
        destroy() {
          super.destroy(), this.formView.destroy();
        }
        _createActionsView() {
          const e2 = this.editor, t2 = new zf(e2.locale), i2 = e2.commands.get("link"), n2 = e2.commands.get("unlink");
          return t2.bind("href").to(i2, "value"), t2.editButtonView.bind("isEnabled").to(i2), t2.unlinkButtonView.bind("isEnabled").to(n2), this.listenTo(t2, "edit", () => {
            this._addFormView();
          }), this.listenTo(t2, "unlink", () => {
            e2.execute("unlink"), this._hideUI();
          }), t2.keystrokes.set("Esc", (e3, t3) => {
            this._hideUI(), t3();
          }), t2.keystrokes.set("Ctrl+K", (e3, t3) => {
            this._addFormView(), t3();
          }), t2;
        }
        _createFormView() {
          const e2 = this.editor, t2 = e2.commands.get("link"), i2 = e2.config.get("link.defaultProtocol"), n2 = new Of(e2.locale, t2);
          return n2.urlInputView.fieldView.bind("value").to(t2, "value"), n2.urlInputView.bind("isReadOnly").to(t2, "isEnabled", (e3) => !e3), n2.saveButtonView.bind("isEnabled").to(t2), this.listenTo(n2, "submit", () => {
            const { value: t3 } = n2.urlInputView.fieldView.element, o2 = Cf(t3, i2);
            e2.execute("link", o2, n2.getDecoratorSwitchesState()), this._closeFormView();
          }), this.listenTo(n2, "cancel", () => {
            this._closeFormView();
          }), n2.keystrokes.set("Esc", (e3, t3) => {
            this._closeFormView(), t3();
          }), n2;
        }
        _createToolbarLinkButton() {
          const e2 = this.editor, t2 = e2.commands.get("link"), i2 = e2.t;
          e2.keystrokes.set("Ctrl+K", (e3, i3) => {
            i3(), t2.isEnabled && this._showUI(true);
          }), e2.ui.componentFactory.add("link", (e3) => {
            const n2 = new td(e3);
            return n2.isEnabled = true, n2.label = i2("Link"), n2.icon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184z"/></svg>', n2.keystroke = "Ctrl+K", n2.tooltip = true, n2.isToggleable = true, n2.bind("isEnabled").to(t2, "isEnabled"), n2.bind("isOn").to(t2, "value", (e4) => !!e4), this.listenTo(n2, "execute", () => this._showUI(true)), n2;
          });
        }
        _enableUserBalloonInteractions() {
          const e2 = this.editor.editing.view.document;
          this.listenTo(e2, "click", () => {
            this._getSelectedLinkElement() && this._showUI();
          }), this.editor.keystrokes.set("Tab", (e3, t2) => {
            this._areActionsVisible && !this.actionsView.focusTracker.isFocused && (this.actionsView.focus(), t2());
          }, { priority: "high" }), this.editor.keystrokes.set("Esc", (e3, t2) => {
            this._isUIVisible && (this._hideUI(), t2());
          }), Il({ emitter: this.formView, activator: () => this._isUIInPanel, contextElements: [this._balloon.view.element], callback: () => this._hideUI() });
        }
        _addActionsView() {
          this._areActionsInPanel || this._balloon.add({ view: this.actionsView, position: this._getBalloonPositionData() });
        }
        _addFormView() {
          if (this._isFormInPanel)
            return;
          const e2 = this.editor.commands.get("link");
          this.formView.disableCssTransitions(), this._balloon.add({ view: this.formView, position: this._getBalloonPositionData() }), this._balloon.visibleView === this.formView && this.formView.urlInputView.fieldView.select(), this.formView.enableCssTransitions(), this.formView.urlInputView.fieldView.element.value = e2.value || "";
        }
        _closeFormView() {
          const e2 = this.editor.commands.get("link");
          e2.restoreManualDecoratorStates(), e2.value !== void 0 ? this._removeFormView() : this._hideUI();
        }
        _removeFormView() {
          this._isFormInPanel && (this.formView.saveButtonView.focus(), this._balloon.remove(this.formView), this.editor.editing.view.focus(), this._hideFakeVisualSelection());
        }
        _showUI(e2 = false) {
          this._getSelectedLinkElement() ? (this._areActionsVisible ? this._addFormView() : this._addActionsView(), e2 && this._balloon.showStack("main")) : (this._showFakeVisualSelection(), this._addActionsView(), e2 && this._balloon.showStack("main"), this._addFormView()), this._startUpdatingUI();
        }
        _hideUI() {
          if (!this._isUIInPanel)
            return;
          const e2 = this.editor;
          this.stopListening(e2.ui, "update"), this.stopListening(this._balloon, "change:visibleView"), e2.editing.view.focus(), this._removeFormView(), this._balloon.remove(this.actionsView), this._hideFakeVisualSelection();
        }
        _startUpdatingUI() {
          const e2 = this.editor, t2 = e2.editing.view.document;
          let i2 = this._getSelectedLinkElement(), n2 = r2();
          const o2 = () => {
            const e3 = this._getSelectedLinkElement(), t3 = r2();
            i2 && !e3 || !i2 && t3 !== n2 ? this._hideUI() : this._isUIVisible && this._balloon.updatePosition(this._getBalloonPositionData()), i2 = e3, n2 = t3;
          };
          function r2() {
            return t2.selection.focus.getAncestors().reverse().find((e3) => e3.is("element"));
          }
          this.listenTo(e2.ui, "update", o2), this.listenTo(this._balloon, "change:visibleView", o2);
        }
        get _isFormInPanel() {
          return this._balloon.hasView(this.formView);
        }
        get _areActionsInPanel() {
          return this._balloon.hasView(this.actionsView);
        }
        get _areActionsVisible() {
          return this._balloon.visibleView === this.actionsView;
        }
        get _isUIInPanel() {
          return this._isFormInPanel || this._areActionsInPanel;
        }
        get _isUIVisible() {
          return this._balloon.visibleView == this.formView || this._areActionsVisible;
        }
        _getBalloonPositionData() {
          const e2 = this.editor.editing.view, t2 = this.editor.model, i2 = e2.document;
          let n2 = null;
          if (t2.markers.has("link-ui")) {
            const t3 = Array.from(this.editor.editing.mapper.markerNameToElements("link-ui")), i3 = e2.createRange(e2.createPositionBefore(t3[0]), e2.createPositionAfter(t3[t3.length - 1]));
            n2 = e2.domConverter.viewRangeToDom(i3);
          } else
            n2 = () => {
              const t3 = this._getSelectedLinkElement();
              return t3 ? e2.domConverter.mapViewToDom(t3) : e2.domConverter.viewRangeToDom(i2.selection.getFirstRange());
            };
          return { target: n2 };
        }
        _getSelectedLinkElement() {
          const e2 = this.editor.editing.view, t2 = e2.document.selection, i2 = t2.getSelectedElement();
          if (t2.isCollapsed || i2 && Oh(i2))
            return Lf(t2.getFirstPosition());
          {
            const i3 = t2.getFirstRange().getTrimmed(), n2 = Lf(i3.start), o2 = Lf(i3.end);
            return n2 && n2 == o2 && e2.createRangeIn(n2).getTrimmed().isEqual(i3) ? n2 : null;
          }
        }
        _showFakeVisualSelection() {
          const e2 = this.editor.model;
          e2.change((t2) => {
            const i2 = e2.document.selection.getFirstRange();
            if (e2.markers.has("link-ui"))
              t2.updateMarker("link-ui", { range: i2 });
            else if (i2.start.isAtEnd) {
              const n2 = i2.start.getLastMatchingPosition(({ item: t3 }) => !e2.schema.isContent(t3), { boundaries: i2 });
              t2.addMarker("link-ui", { usingOperation: false, affectsData: false, range: t2.createRange(n2, i2.end) });
            } else
              t2.addMarker("link-ui", { usingOperation: false, affectsData: false, range: i2 });
          });
        }
        _hideFakeVisualSelection() {
          const e2 = this.editor.model;
          e2.markers.has("link-ui") && e2.change((e3) => {
            e3.removeMarker("link-ui");
          });
        }
      }
      function Lf(e2) {
        return e2.getAncestors().find((e3) => {
          return (t2 = e3).is("attributeElement") && !!t2.getCustomProperty("link");
          var t2;
        });
      }
      const Vf = new RegExp("(^|\\s)(((?:(?:(?:https?|ftp):)?\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(((?!www\\.)|(www\\.))(?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.)+(?:[a-z\\u00a1-\\uffff]{2,63})))(?::\\d{2,5})?(?:[/?#]\\S*)?)|((www.|(\\S+@))((?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.))+(?:[a-z\\u00a1-\\uffff]{2,63})))$", "i");
      class jf extends Qe {
        static get requires() {
          return [Sh];
        }
        static get pluginName() {
          return "AutoLink";
        }
        init() {
          const e2 = this.editor.model.document.selection;
          e2.on("change:range", () => {
            this.isEnabled = !e2.anchor.parent.is("element", "codeBlock");
          }), this._enableTypingHandling();
        }
        afterInit() {
          this._enableEnterHandling(), this._enableShiftEnterHandling();
        }
        _enableTypingHandling() {
          const e2 = this.editor, t2 = new Iu(e2.model, (e3) => {
            if (!function(e4) {
              return e4.length > 4 && e4[e4.length - 1] === " " && e4[e4.length - 2] !== " ";
            }(e3))
              return;
            const t3 = Bf(e3.substr(0, e3.length - 1));
            return t3 ? { url: t3 } : void 0;
          }), i2 = e2.plugins.get("Input");
          t2.on("matched:data", (t3, n2) => {
            const { batch: o2, range: r2, url: s2 } = n2;
            if (!i2.isInput(o2))
              return;
            const a2 = r2.end.getShiftedBy(-1), c2 = a2.getShiftedBy(-s2.length), l2 = e2.model.createRange(c2, a2);
            this._applyAutoLink(s2, l2);
          }), t2.bind("isEnabled").to(this);
        }
        _enableEnterHandling() {
          const e2 = this.editor, t2 = e2.model, i2 = e2.commands.get("enter");
          i2 && i2.on("execute", () => {
            const e3 = t2.document.selection.getFirstPosition();
            if (!e3.parent.previousSibling)
              return;
            const i3 = t2.createRangeIn(e3.parent.previousSibling);
            this._checkAndApplyAutoLinkOnRange(i3);
          });
        }
        _enableShiftEnterHandling() {
          const e2 = this.editor, t2 = e2.model, i2 = e2.commands.get("shiftEnter");
          i2 && i2.on("execute", () => {
            const e3 = t2.document.selection.getFirstPosition(), i3 = t2.createRange(t2.createPositionAt(e3.parent, 0), e3.getShiftedBy(-1));
            this._checkAndApplyAutoLinkOnRange(i3);
          });
        }
        _checkAndApplyAutoLinkOnRange(e2) {
          const t2 = this.editor.model, { text: i2, range: n2 } = Eu(e2, t2), o2 = Bf(i2);
          if (o2) {
            const e3 = t2.createRange(n2.end.getShiftedBy(-o2.length), n2.end);
            this._applyAutoLink(o2, e3);
          }
        }
        _applyAutoLink(e2, t2) {
          const i2 = this.editor.model, n2 = this.editor.plugins.get("Delete");
          this.isEnabled && function(e3, t3) {
            return t3.schema.checkAttributeInSelection(t3.createSelection(e3), "linkHref");
          }(t2, i2) && i2.enqueueChange((o2) => {
            const r2 = this.editor.config.get("link.defaultProtocol"), s2 = Cf(e2, r2);
            o2.setAttribute("linkHref", s2, t2), i2.enqueueChange(() => {
              n2.requestUndoOnBackspace();
            });
          });
        }
      }
      function Bf(e2) {
        const t2 = Vf.exec(e2);
        return t2 ? t2[2] : null;
      }
      class Ff extends Ze {
        constructor(e2, t2) {
          super(e2), this.type = t2;
        }
        refresh() {
          this.value = this._getValue(), this.isEnabled = this._checkEnabled();
        }
        execute(e2 = {}) {
          const t2 = this.editor.model, i2 = t2.document, n2 = Array.from(i2.selection.getSelectedBlocks()).filter((e3) => Uf(e3, t2.schema)), o2 = e2.forceValue !== void 0 ? !e2.forceValue : this.value;
          t2.change((e3) => {
            if (o2) {
              let t3 = n2[n2.length - 1].nextSibling, i3 = Number.POSITIVE_INFINITY, o3 = [];
              for (; t3 && t3.name == "listItem" && t3.getAttribute("listIndent") !== 0; ) {
                const e4 = t3.getAttribute("listIndent");
                e4 < i3 && (i3 = e4);
                const n3 = e4 - i3;
                o3.push({ element: t3, listIndent: n3 }), t3 = t3.nextSibling;
              }
              o3 = o3.reverse();
              for (const t4 of o3)
                e3.setAttribute("listIndent", t4.listIndent, t4.element);
            }
            if (!o2) {
              let e4 = Number.POSITIVE_INFINITY;
              for (const t3 of n2)
                t3.is("element", "listItem") && t3.getAttribute("listIndent") < e4 && (e4 = t3.getAttribute("listIndent"));
              e4 = e4 === 0 ? 1 : e4, Hf(n2, true, e4), Hf(n2, false, e4);
            }
            for (const t3 of n2.reverse())
              o2 && t3.name == "listItem" ? e3.rename(t3, "paragraph") : o2 || t3.name == "listItem" ? o2 || t3.name != "listItem" || t3.getAttribute("listType") == this.type || e3.setAttribute("listType", this.type, t3) : (e3.setAttributes({ listType: this.type, listIndent: 0 }, t3), e3.rename(t3, "listItem"));
            this.fire("_executeCleanup", n2);
          });
        }
        _getValue() {
          const e2 = Ms(this.editor.model.document.selection.getSelectedBlocks());
          return !!e2 && e2.is("element", "listItem") && e2.getAttribute("listType") == this.type;
        }
        _checkEnabled() {
          if (this.value)
            return true;
          const e2 = this.editor.model.document.selection, t2 = this.editor.model.schema, i2 = Ms(e2.getSelectedBlocks());
          return !!i2 && Uf(i2, t2);
        }
      }
      function Hf(e2, t2, i2) {
        const n2 = t2 ? e2[0] : e2[e2.length - 1];
        if (n2.is("element", "listItem")) {
          let o2 = n2[t2 ? "previousSibling" : "nextSibling"], r2 = n2.getAttribute("listIndent");
          for (; o2 && o2.is("element", "listItem") && o2.getAttribute("listIndent") >= i2; )
            r2 > o2.getAttribute("listIndent") && (r2 = o2.getAttribute("listIndent")), o2.getAttribute("listIndent") == r2 && e2[t2 ? "unshift" : "push"](o2), o2 = o2[t2 ? "previousSibling" : "nextSibling"];
        }
      }
      function Uf(e2, t2) {
        return t2.checkChild(e2.parent, "listItem") && !t2.isObject(e2);
      }
      class Wf extends Ze {
        constructor(e2, t2) {
          super(e2), this._indentBy = t2 == "forward" ? 1 : -1;
        }
        refresh() {
          this.isEnabled = this._checkEnabled();
        }
        execute() {
          const e2 = this.editor.model, t2 = e2.document;
          let i2 = Array.from(t2.selection.getSelectedBlocks());
          e2.change((e3) => {
            const t3 = i2[i2.length - 1];
            let n2 = t3.nextSibling;
            for (; n2 && n2.name == "listItem" && n2.getAttribute("listIndent") > t3.getAttribute("listIndent"); )
              i2.push(n2), n2 = n2.nextSibling;
            this._indentBy < 0 && (i2 = i2.reverse());
            for (const t4 of i2) {
              const i3 = t4.getAttribute("listIndent") + this._indentBy;
              i3 < 0 ? e3.rename(t4, "paragraph") : e3.setAttribute("listIndent", i3, t4);
            }
            this.fire("_executeCleanup", i2);
          });
        }
        _checkEnabled() {
          const e2 = Ms(this.editor.model.document.selection.getSelectedBlocks());
          if (!e2 || !e2.is("element", "listItem"))
            return false;
          if (this._indentBy > 0) {
            const t2 = e2.getAttribute("listIndent"), i2 = e2.getAttribute("listType");
            let n2 = e2.previousSibling;
            for (; n2 && n2.is("element", "listItem") && n2.getAttribute("listIndent") >= t2; ) {
              if (n2.getAttribute("listIndent") == t2)
                return n2.getAttribute("listType") == i2;
              n2 = n2.previousSibling;
            }
            return false;
          }
          return true;
        }
      }
      function qf(e2, t2) {
        const i2 = t2.mapper, n2 = t2.writer, o2 = e2.getAttribute("listType") == "numbered" ? "ol" : "ul", r2 = function(e3) {
          const t3 = e3.createContainerElement("li");
          return t3.getFillerOffset = Jf, t3;
        }(n2), s2 = n2.createContainerElement(o2, null);
        return n2.insert(n2.createPositionAt(s2, 0), r2), i2.bindElements(e2, r2), r2;
      }
      function $f(e2, t2, i2, n2) {
        const o2 = t2.parent, r2 = i2.mapper, s2 = i2.writer;
        let a2 = r2.toViewPosition(n2.createPositionBefore(e2));
        const c2 = Kf(e2.previousSibling, { sameIndent: true, smallerIndent: true, listIndent: e2.getAttribute("listIndent") }), l2 = e2.previousSibling;
        if (c2 && c2.getAttribute("listIndent") == e2.getAttribute("listIndent")) {
          const e3 = r2.toViewElement(c2);
          a2 = s2.breakContainer(s2.createPositionAfter(e3));
        } else if (l2 && l2.name == "listItem") {
          a2 = r2.toViewPosition(n2.createPositionAt(l2, "end"));
          const e3 = r2.findMappedViewAncestor(a2), t3 = function(e4) {
            for (const t4 of e4.getChildren())
              if (t4.name == "ul" || t4.name == "ol")
                return t4;
            return null;
          }(e3);
          a2 = t3 ? s2.createPositionBefore(t3) : s2.createPositionAt(e3, "end");
        } else
          a2 = r2.toViewPosition(n2.createPositionBefore(e2));
        if (a2 = Gf(a2), s2.insert(a2, o2), l2 && l2.name == "listItem") {
          const e3 = r2.toViewElement(l2), i3 = s2.createRange(s2.createPositionAt(e3, 0), a2).getWalker({ ignoreElementEnd: true });
          for (const e4 of i3)
            if (e4.item.is("element", "li")) {
              const n3 = s2.breakContainer(s2.createPositionBefore(e4.item)), o3 = e4.item.parent, r3 = s2.createPositionAt(t2, "end");
              Yf(s2, r3.nodeBefore, r3.nodeAfter), s2.move(s2.createRangeOn(o3), r3), i3.position = n3;
            }
        } else {
          const i3 = o2.nextSibling;
          if (i3 && (i3.is("element", "ul") || i3.is("element", "ol"))) {
            let n3 = null;
            for (const t3 of i3.getChildren()) {
              const i4 = r2.toModelElement(t3);
              if (!(i4 && i4.getAttribute("listIndent") > e2.getAttribute("listIndent")))
                break;
              n3 = t3;
            }
            n3 && (s2.breakContainer(s2.createPositionAfter(n3)), s2.move(s2.createRangeOn(n3.parent), s2.createPositionAt(t2, "end")));
          }
        }
        Yf(s2, o2, o2.nextSibling), Yf(s2, o2.previousSibling, o2);
      }
      function Yf(e2, t2, i2) {
        return !t2 || !i2 || t2.name != "ul" && t2.name != "ol" || t2.name != i2.name || t2.getAttribute("class") !== i2.getAttribute("class") ? null : e2.mergeContainers(e2.createPositionAfter(t2));
      }
      function Gf(e2) {
        return e2.getLastMatchingPosition((e3) => e3.item.is("uiElement"));
      }
      function Kf(e2, t2) {
        const i2 = !!t2.sameIndent, n2 = !!t2.smallerIndent, o2 = t2.listIndent;
        let r2 = e2;
        for (; r2 && r2.name == "listItem"; ) {
          const e3 = r2.getAttribute("listIndent");
          if (i2 && o2 == e3 || n2 && o2 > e3)
            return r2;
          r2 = t2.direction === "forward" ? r2.nextSibling : r2.previousSibling;
        }
        return null;
      }
      function Qf(e2, t2, i2, n2) {
        e2.ui.componentFactory.add(t2, (o2) => {
          const r2 = e2.commands.get(t2), s2 = new td(o2);
          return s2.set({ label: i2, icon: n2, tooltip: true, isToggleable: true }), s2.bind("isOn", "isEnabled").to(r2, "value", "isEnabled"), s2.on("execute", () => {
            e2.execute(t2), e2.editing.view.focus();
          }), s2;
        });
      }
      function Jf() {
        const e2 = !this.isEmpty && (this.getChild(0).name == "ul" || this.getChild(0).name == "ol");
        return this.isEmpty || e2 ? 0 : no.call(this);
      }
      function Zf(e2) {
        return (t2, i2, n2) => {
          const o2 = n2.consumable;
          if (!o2.test(i2.item, "insert") || !o2.test(i2.item, "attribute:listType") || !o2.test(i2.item, "attribute:listIndent"))
            return;
          o2.consume(i2.item, "insert"), o2.consume(i2.item, "attribute:listType"), o2.consume(i2.item, "attribute:listIndent");
          const r2 = i2.item;
          $f(r2, qf(r2, n2), n2, e2);
        };
      }
      function Xf(e2, t2, i2) {
        if (!i2.consumable.consume(t2.item, "attribute:listType"))
          return;
        const n2 = i2.mapper.toViewElement(t2.item), o2 = i2.writer;
        o2.breakContainer(o2.createPositionBefore(n2)), o2.breakContainer(o2.createPositionAfter(n2));
        const r2 = n2.parent, s2 = t2.attributeNewValue == "numbered" ? "ol" : "ul";
        o2.rename(s2, r2);
      }
      function ep(e2, t2, i2) {
        const n2 = i2.mapper.toViewElement(t2.item).parent, o2 = i2.writer;
        Yf(o2, n2, n2.nextSibling), Yf(o2, n2.previousSibling, n2);
        for (const e3 of t2.item.getChildren())
          i2.consumable.consume(e3, "insert");
      }
      function tp(e2, t2, i2) {
        if (t2.item.name != "listItem") {
          let e3 = i2.mapper.toViewPosition(t2.range.start);
          const n2 = i2.writer, o2 = [];
          for (; (e3.parent.name == "ul" || e3.parent.name == "ol") && (e3 = n2.breakContainer(e3), e3.parent.name == "li"); ) {
            const t3 = e3, i3 = n2.createPositionAt(e3.parent, "end");
            if (!t3.isEqual(i3)) {
              const e4 = n2.remove(n2.createRange(t3, i3));
              o2.push(e4);
            }
            e3 = n2.createPositionAfter(e3.parent);
          }
          if (o2.length > 0) {
            for (let t3 = 0; t3 < o2.length; t3++) {
              const i3 = e3.nodeBefore;
              if (e3 = n2.insert(e3, o2[t3]).end, t3 > 0) {
                const t4 = Yf(n2, i3, i3.nextSibling);
                t4 && t4.parent == i3 && e3.offset--;
              }
            }
            Yf(n2, e3.nodeBefore, e3.nodeAfter);
          }
        }
      }
      function ip(e2, t2, i2) {
        const n2 = i2.mapper.toViewPosition(t2.position), o2 = n2.nodeBefore, r2 = n2.nodeAfter;
        Yf(i2.writer, o2, r2);
      }
      function np(e2, t2, i2) {
        if (i2.consumable.consume(t2.viewItem, { name: true })) {
          const e3 = i2.writer, n2 = e3.createElement("listItem"), o2 = function(e4) {
            let t3 = 0, i3 = e4.parent;
            for (; i3; ) {
              if (i3.is("element", "li"))
                t3++;
              else {
                const e5 = i3.previousSibling;
                e5 && e5.is("element", "li") && t3++;
              }
              i3 = i3.parent;
            }
            return t3;
          }(t2.viewItem);
          e3.setAttribute("listIndent", o2, n2);
          const r2 = t2.viewItem.parent && t2.viewItem.parent.name == "ol" ? "numbered" : "bulleted";
          if (e3.setAttribute("listType", r2, n2), !i2.safeInsert(n2, t2.modelCursor))
            return;
          const s2 = function(e4, t3, i3) {
            const { writer: n3, schema: o3 } = i3;
            let r3 = n3.createPositionAfter(e4);
            for (const s3 of t3)
              if (s3.name == "ul" || s3.name == "ol")
                r3 = i3.convertItem(s3, r3).modelCursor;
              else {
                const t4 = i3.convertItem(s3, n3.createPositionAt(e4, "end")), a2 = t4.modelRange.start.nodeAfter;
                a2 && a2.is("element") && !o3.checkChild(e4, a2.name) && (e4 = t4.modelCursor.parent.is("element", "listItem") ? t4.modelCursor.parent : cp(t4.modelCursor), r3 = n3.createPositionAfter(e4));
              }
            return r3;
          }(n2, t2.viewItem.getChildren(), i2);
          t2.modelRange = e3.createRange(t2.modelCursor, s2), i2.updateConversionResult(n2, t2);
        }
      }
      function op(e2, t2, i2) {
        if (i2.consumable.test(t2.viewItem, { name: true })) {
          const e3 = Array.from(t2.viewItem.getChildren());
          for (const t3 of e3) {
            !(t3.is("element", "li") || dp(t3)) && t3._remove();
          }
        }
      }
      function rp(e2, t2, i2) {
        if (i2.consumable.test(t2.viewItem, { name: true })) {
          if (t2.viewItem.childCount === 0)
            return;
          const e3 = [...t2.viewItem.getChildren()];
          let i3 = false;
          for (const t3 of e3)
            i3 && !dp(t3) && t3._remove(), dp(t3) && (i3 = true);
        }
      }
      function sp(e2) {
        return (t2, i2) => {
          if (i2.isPhantom)
            return;
          const n2 = i2.modelPosition.nodeBefore;
          if (n2 && n2.is("element", "listItem")) {
            const t3 = i2.mapper.toViewElement(n2), o2 = t3.getAncestors().find(dp), r2 = e2.createPositionAt(t3, 0).getWalker();
            for (const e3 of r2) {
              if (e3.type == "elementStart" && e3.item.is("element", "li")) {
                i2.viewPosition = e3.previousPosition;
                break;
              }
              if (e3.type == "elementEnd" && e3.item == o2) {
                i2.viewPosition = e3.nextPosition;
                break;
              }
            }
          }
        };
      }
      function ap(e2, [t2, i2]) {
        let n2, o2 = t2.is("documentFragment") ? t2.getChild(0) : t2;
        if (n2 = i2 ? this.createSelection(i2) : this.document.selection, o2 && o2.is("element", "listItem")) {
          const e3 = n2.getFirstPosition();
          let t3 = null;
          if (e3.parent.is("element", "listItem") ? t3 = e3.parent : e3.nodeBefore && e3.nodeBefore.is("element", "listItem") && (t3 = e3.nodeBefore), t3) {
            const e4 = t3.getAttribute("listIndent");
            if (e4 > 0)
              for (; o2 && o2.is("element", "listItem"); )
                o2._setAttribute("listIndent", o2.getAttribute("listIndent") + e4), o2 = o2.nextSibling;
          }
        }
      }
      function cp(e2) {
        const t2 = new Js({ startPosition: e2 });
        let i2;
        do {
          i2 = t2.next();
        } while (!i2.value.item.is("element", "listItem"));
        return i2.value.item;
      }
      function lp(e2, t2, i2, n2, o2, r2) {
        const s2 = Kf(t2.nodeBefore, { sameIndent: true, smallerIndent: true, listIndent: e2, foo: "b" }), a2 = o2.mapper, c2 = o2.writer, l2 = s2 ? s2.getAttribute("listIndent") : null;
        let d2;
        if (s2)
          if (l2 == e2) {
            const e3 = a2.toViewElement(s2).parent;
            d2 = c2.createPositionAfter(e3);
          } else {
            const e3 = r2.createPositionAt(s2, "end");
            d2 = a2.toViewPosition(e3);
          }
        else
          d2 = i2;
        d2 = Gf(d2);
        for (const e3 of [...n2.getChildren()])
          dp(e3) && (d2 = c2.move(c2.createRangeOn(e3), d2).end, Yf(c2, e3, e3.nextSibling), Yf(c2, e3.previousSibling, e3));
      }
      function dp(e2) {
        return e2.is("element", "ol") || e2.is("element", "ul");
      }
      class hp extends Qe {
        static get pluginName() {
          return "ListEditing";
        }
        static get requires() {
          return [Ch, Sh];
        }
        init() {
          const e2 = this.editor;
          e2.model.schema.register("listItem", { inheritAllFrom: "$block", allowAttributes: ["listType", "listIndent"] });
          const t2 = e2.data, i2 = e2.editing;
          var n2;
          e2.model.document.registerPostFixer((t3) => function(e3, t4) {
            const i3 = e3.document.differ.getChanges(), n3 = new Map();
            let o3 = false;
            for (const n4 of i3)
              if (n4.type == "insert" && n4.name == "listItem")
                r3(n4.position);
              else if (n4.type == "insert" && n4.name != "listItem") {
                if (n4.name != "$text") {
                  const i4 = n4.position.nodeAfter;
                  i4.hasAttribute("listIndent") && (t4.removeAttribute("listIndent", i4), o3 = true), i4.hasAttribute("listType") && (t4.removeAttribute("listType", i4), o3 = true), i4.hasAttribute("listStyle") && (t4.removeAttribute("listStyle", i4), o3 = true);
                  for (const t5 of Array.from(e3.createRangeIn(i4)).filter((e4) => e4.item.is("element", "listItem")))
                    r3(t5.previousPosition);
                }
                r3(n4.position.getShiftedBy(n4.length));
              } else
                n4.type == "remove" && n4.name == "listItem" ? r3(n4.position) : (n4.type == "attribute" && n4.attributeKey == "listIndent" || n4.type == "attribute" && n4.attributeKey == "listType") && r3(n4.range.start);
            for (const e4 of n3.values())
              s2(e4), a2(e4);
            return o3;
            function r3(e4) {
              const t5 = e4.nodeBefore;
              if (t5 && t5.is("element", "listItem")) {
                let e5 = t5;
                if (n3.has(e5))
                  return;
                for (let t6 = e5.previousSibling; t6 && t6.is("element", "listItem"); t6 = e5.previousSibling)
                  if (e5 = t6, n3.has(e5))
                    return;
                n3.set(t5, e5);
              } else {
                const t6 = e4.nodeAfter;
                t6 && t6.is("element", "listItem") && n3.set(t6, t6);
              }
            }
            function s2(e4) {
              let i4 = 0, n4 = null;
              for (; e4 && e4.is("element", "listItem"); ) {
                const r4 = e4.getAttribute("listIndent");
                if (r4 > i4) {
                  let s3;
                  n4 === null ? (n4 = r4 - i4, s3 = i4) : (n4 > r4 && (n4 = r4), s3 = r4 - n4), t4.setAttribute("listIndent", s3, e4), o3 = true;
                } else
                  n4 = null, i4 = e4.getAttribute("listIndent") + 1;
                e4 = e4.nextSibling;
              }
            }
            function a2(e4) {
              let i4 = [], n4 = null;
              for (; e4 && e4.is("element", "listItem"); ) {
                const r4 = e4.getAttribute("listIndent");
                if (n4 && n4.getAttribute("listIndent") > r4 && (i4 = i4.slice(0, r4 + 1)), r4 != 0)
                  if (i4[r4]) {
                    const n5 = i4[r4];
                    e4.getAttribute("listType") != n5 && (t4.setAttribute("listType", n5, e4), o3 = true);
                  } else
                    i4[r4] = e4.getAttribute("listType");
                n4 = e4, e4 = e4.nextSibling;
              }
            }
          }(e2.model, t3)), i2.mapper.registerViewToModelLength("li", up), t2.mapper.registerViewToModelLength("li", up), i2.mapper.on("modelToViewPosition", sp(i2.view)), i2.mapper.on("viewToModelPosition", (n2 = e2.model, (e3, t3) => {
            const i3 = t3.viewPosition, o3 = i3.parent, r3 = t3.mapper;
            if (o3.name == "ul" || o3.name == "ol") {
              if (i3.isAtEnd) {
                const e4 = r3.toModelElement(i3.nodeBefore), o4 = r3.getModelLength(i3.nodeBefore);
                t3.modelPosition = n2.createPositionBefore(e4).getShiftedBy(o4);
              } else {
                const e4 = r3.toModelElement(i3.nodeAfter);
                t3.modelPosition = n2.createPositionBefore(e4);
              }
              e3.stop();
            } else if (o3.name == "li" && i3.nodeBefore && (i3.nodeBefore.name == "ul" || i3.nodeBefore.name == "ol")) {
              const s2 = r3.toModelElement(o3);
              let a2 = 1, c2 = i3.nodeBefore;
              for (; c2 && dp(c2); )
                a2 += r3.getModelLength(c2), c2 = c2.previousSibling;
              t3.modelPosition = n2.createPositionBefore(s2).getShiftedBy(a2), e3.stop();
            }
          })), t2.mapper.on("modelToViewPosition", sp(i2.view)), e2.conversion.for("editingDowncast").add((t3) => {
            t3.on("insert", tp, { priority: "high" }), t3.on("insert:listItem", Zf(e2.model)), t3.on("attribute:listType:listItem", Xf, { priority: "high" }), t3.on("attribute:listType:listItem", ep, { priority: "low" }), t3.on("attribute:listIndent:listItem", function(e3) {
              return (t4, i3, n3) => {
                if (!n3.consumable.consume(i3.item, "attribute:listIndent"))
                  return;
                const o3 = n3.mapper.toViewElement(i3.item), r3 = n3.writer;
                r3.breakContainer(r3.createPositionBefore(o3)), r3.breakContainer(r3.createPositionAfter(o3));
                const s2 = o3.parent, a2 = s2.previousSibling, c2 = r3.createRangeOn(s2);
                r3.remove(c2), a2 && a2.nextSibling && Yf(r3, a2, a2.nextSibling), lp(i3.attributeOldValue + 1, i3.range.start, c2.start, o3, n3, e3), $f(i3.item, o3, n3, e3);
                for (const e4 of i3.item.getChildren())
                  n3.consumable.consume(e4, "insert");
              };
            }(e2.model)), t3.on("remove:listItem", function(e3) {
              return (t4, i3, n3) => {
                const o3 = n3.mapper.toViewPosition(i3.position).getLastMatchingPosition((e4) => !e4.item.is("element", "li")).nodeAfter, r3 = n3.writer;
                r3.breakContainer(r3.createPositionBefore(o3)), r3.breakContainer(r3.createPositionAfter(o3));
                const s2 = o3.parent, a2 = s2.previousSibling, c2 = r3.createRangeOn(s2), l2 = r3.remove(c2);
                a2 && a2.nextSibling && Yf(r3, a2, a2.nextSibling);
                lp(n3.mapper.toModelElement(o3).getAttribute("listIndent") + 1, i3.position, c2.start, o3, n3, e3);
                for (const e4 of r3.createRangeIn(l2).getItems())
                  n3.mapper.unbindViewElement(e4);
                t4.stop();
              };
            }(e2.model)), t3.on("remove", ip, { priority: "low" });
          }), e2.conversion.for("dataDowncast").add((t3) => {
            t3.on("insert", tp, { priority: "high" }), t3.on("insert:listItem", Zf(e2.model));
          }), e2.conversion.for("upcast").add((e3) => {
            e3.on("element:ul", op, { priority: "high" }), e3.on("element:ol", op, { priority: "high" }), e3.on("element:li", rp, { priority: "high" }), e3.on("element:li", np);
          }), e2.model.on("insertContent", ap, { priority: "high" }), e2.commands.add("numberedList", new Ff(e2, "numbered")), e2.commands.add("bulletedList", new Ff(e2, "bulleted")), e2.commands.add("indentList", new Wf(e2, "forward")), e2.commands.add("outdentList", new Wf(e2, "backward"));
          const o2 = i2.view.document;
          this.listenTo(o2, "enter", (e3, t3) => {
            const i3 = this.editor.model.document, n3 = i3.selection.getLastPosition().parent;
            i3.selection.isCollapsed && n3.name == "listItem" && n3.isEmpty && (this.editor.execute("outdentList"), t3.preventDefault(), e3.stop());
          }, { context: "li" }), this.listenTo(o2, "delete", (e3, t3) => {
            if (t3.direction !== "backward")
              return;
            const i3 = this.editor.model.document.selection;
            if (!i3.isCollapsed)
              return;
            const n3 = i3.getFirstPosition();
            if (!n3.isAtStart)
              return;
            const o3 = n3.parent;
            if (o3.name !== "listItem")
              return;
            o3.previousSibling && o3.previousSibling.name === "listItem" || (this.editor.execute("outdentList"), t3.preventDefault(), e3.stop());
          }, { context: "li" });
          const r2 = (e3) => (t3, i3) => {
            this.editor.commands.get(e3).isEnabled && (this.editor.execute(e3), i3());
          };
          e2.keystrokes.set("Tab", r2("indentList")), e2.keystrokes.set("Shift+Tab", r2("outdentList"));
        }
        afterInit() {
          const e2 = this.editor.commands, t2 = e2.get("indent"), i2 = e2.get("outdent");
          t2 && t2.registerChildCommand(e2.get("indentList")), i2 && i2.registerChildCommand(e2.get("outdentList"));
        }
      }
      function up(e2) {
        let t2 = 1;
        for (const i2 of e2.getChildren())
          if (i2.name == "ul" || i2.name == "ol")
            for (const e3 of i2.getChildren())
              t2 += up(e3);
        return t2;
      }
      class gp extends Qe {
        static get pluginName() {
          return "ListUI";
        }
        init() {
          const e2 = this.editor.t;
          Qf(this.editor, "numberedList", e2("Numbered List"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM3.5 3v5H2V3.7H1v-1h2.5V3zM.343 17.857l2.59-3.257H2.92a.6.6 0 1 0-1.04 0H.302a2 2 0 1 1 3.995 0h-.001c-.048.405-.16.734-.333.988-.175.254-.59.692-1.244 1.312H4.3v1h-4l.043-.043zM7 14.75a.75.75 0 0 1 .75-.75h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75z"/></svg>'), Qf(this.editor, "bulletedList", e2("Bulleted List"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0C1 4.784 1.777 4 2.75 4c.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75C1.784 7.5 1 6.723 1 5.75zm6 9c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0c0-.966.777-1.75 1.75-1.75.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75-.966 0-1.75-.777-1.75-1.75z"/></svg>');
        }
      }
      function mp(e2, t2) {
        return (e3) => {
          e3.on("attribute:url:media", i2);
        };
        function i2(i3, n2, o2) {
          if (!o2.consumable.consume(n2.item, i3.name))
            return;
          const r2 = n2.attributeNewValue, s2 = o2.writer, a2 = o2.mapper.toViewElement(n2.item), c2 = [...a2.getChildren()].find((e3) => e3.getCustomProperty("media-content"));
          s2.remove(c2);
          const l2 = e2.getMediaViewElement(s2, r2, t2);
          s2.insert(s2.createPositionAt(a2, 0), l2);
        }
      }
      function fp(e2, t2, i2, n2) {
        const o2 = e2.createContainerElement("figure", { class: "media" });
        return e2.insert(e2.createPositionAt(o2, 0), t2.getMediaViewElement(e2, i2, n2)), o2;
      }
      function pp(e2) {
        const t2 = e2.getSelectedElement();
        return t2 && t2.is("element", "media") ? t2 : null;
      }
      function bp(e2, t2, i2) {
        e2.change((n2) => {
          const o2 = n2.createElement("media", { url: t2 });
          e2.insertContent(o2, i2), n2.setSelection(o2, "on");
        });
      }
      class wp extends Ze {
        refresh() {
          const e2 = this.editor.model, t2 = e2.document.selection, i2 = pp(t2);
          this.value = i2 ? i2.getAttribute("url") : null, this.isEnabled = function(e3) {
            const t3 = e3.getSelectedElement();
            return !!t3 && t3.name === "media";
          }(t2) || function(e3, t3) {
            let i3 = Fh(e3, t3).start.parent;
            i3.isEmpty && !t3.schema.isLimit(i3) && (i3 = i3.parent);
            return t3.schema.checkChild(i3, "media");
          }(t2, e2);
        }
        execute(e2) {
          const t2 = this.editor.model, i2 = t2.document.selection, n2 = pp(i2);
          n2 ? t2.change((t3) => {
            t3.setAttribute("url", e2, n2);
          }) : bp(t2, e2, Fh(i2, t2));
        }
      }
      class kp {
        constructor(e2, t2) {
          const i2 = t2.providers, n2 = t2.extraProviders || [], o2 = new Set(t2.removeProviders), r2 = i2.concat(n2).filter((e3) => {
            const t3 = e3.name;
            return t3 ? !o2.has(t3) : (Object(c.b)("media-embed-no-provider-name", { provider: e3 }), false);
          });
          this.locale = e2, this.providerDefinitions = r2;
        }
        hasMedia(e2) {
          return !!this._getMedia(e2);
        }
        getMediaViewElement(e2, t2, i2) {
          return this._getMedia(t2).getViewElement(e2, i2);
        }
        _getMedia(e2) {
          if (!e2)
            return new _p(this.locale);
          e2 = e2.trim();
          for (const t2 of this.providerDefinitions) {
            const i2 = t2.html, n2 = en(t2.url);
            for (const t3 of n2) {
              const n3 = this._getUrlMatches(e2, t3);
              if (n3)
                return new _p(this.locale, e2, n3, i2);
            }
          }
          return null;
        }
        _getUrlMatches(e2, t2) {
          let i2 = e2.match(t2);
          if (i2)
            return i2;
          let n2 = e2.replace(/^https?:\/\//, "");
          return i2 = n2.match(t2), i2 || (n2 = n2.replace(/^www\./, ""), i2 = n2.match(t2), i2 || null);
        }
      }
      class _p {
        constructor(e2, t2, i2, n2) {
          this.url = this._getValidUrl(t2), this._t = e2.t, this._match = i2, this._previewRenderer = n2;
        }
        getViewElement(e2, t2) {
          const i2 = {};
          let n2;
          if (t2.renderForEditingView || t2.renderMediaPreview && this.url && this._previewRenderer) {
            this.url && (i2["data-oembed-url"] = this.url), t2.renderForEditingView && (i2.class = "ck-media__wrapper");
            const o2 = this._getPreviewHtml(t2);
            n2 = e2.createRawElement("div", i2, function(e3) {
              e3.innerHTML = o2;
            });
          } else
            this.url && (i2.url = this.url), n2 = e2.createEmptyElement(t2.elementName, i2);
          return e2.setCustomProperty("media-content", true, n2), n2;
        }
        _getPreviewHtml(e2) {
          return this._previewRenderer ? this._previewRenderer(this._match) : this.url && e2.renderForEditingView ? this._getPlaceholderHtml() : "";
        }
        _getPlaceholderHtml() {
          const e2 = new ed(), t2 = new Xl();
          e2.text = this._t("Open media in new tab"), t2.content = '<svg viewBox="0 0 64 42" xmlns="http://www.w3.org/2000/svg"><path d="M47.426 17V3.713L63.102 0v19.389h-.001l.001.272c0 1.595-2.032 3.43-4.538 4.098-2.506.668-4.538-.083-4.538-1.678 0-1.594 2.032-3.43 4.538-4.098.914-.244 2.032-.565 2.888-.603V4.516L49.076 7.447v9.556A1.014 1.014 0 0 0 49 17h-1.574zM29.5 17h-8.343a7.073 7.073 0 1 0-4.657 4.06v3.781H3.3a2.803 2.803 0 0 1-2.8-2.804V8.63a2.803 2.803 0 0 1 2.8-2.805h4.082L8.58 2.768A1.994 1.994 0 0 1 10.435 1.5h8.985c.773 0 1.477.448 1.805 1.149l1.488 3.177H26.7c1.546 0 2.8 1.256 2.8 2.805V17zm-11.637 0H17.5a1 1 0 0 0-1 1v.05A4.244 4.244 0 1 1 17.863 17zm29.684 2c.97 0 .953-.048.953.889v20.743c0 .953.016.905-.953.905H19.453c-.97 0-.953.048-.953-.905V19.89c0-.937-.016-.889.97-.889h28.077zm-4.701 19.338V22.183H24.154v16.155h18.692zM20.6 21.375v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616V37.53H20.6zm24.233-16.155v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615V37.53h-1.615zM29.485 25.283a.4.4 0 0 1 .593-.35l9.05 4.977a.4.4 0 0 1 0 .701l-9.05 4.978a.4.4 0 0 1-.593-.35v-9.956z"/></svg>', t2.viewBox = "0 0 64 42";
          return new Rl({ tag: "div", attributes: { class: "ck ck-reset_all ck-media__placeholder" }, children: [{ tag: "div", attributes: { class: "ck-media__placeholder__icon" }, children: [t2] }, { tag: "a", attributes: { class: "ck-media__placeholder__url", target: "_blank", rel: "noopener noreferrer", href: this.url }, children: [{ tag: "span", attributes: { class: "ck-media__placeholder__url__text" }, children: [this.url] }, e2] }] }).render().outerHTML;
        }
        _getValidUrl(e2) {
          return e2 ? e2.match(/^https?/) ? e2 : "https://" + e2 : null;
        }
      }
      i(94);
      class vp extends Qe {
        static get pluginName() {
          return "MediaEmbedEditing";
        }
        constructor(e2) {
          super(e2), e2.config.define("mediaEmbed", { elementName: "oembed", providers: [{ name: "dailymotion", url: /^dailymotion\.com\/video\/(\w+)/, html: (e3) => `<div style="position: relative; padding-bottom: 100%; height: 0; "><iframe src="https://www.dailymotion.com/embed/video/${e3[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" width="480" height="270" allowfullscreen allow="autoplay"></iframe></div>` }, { name: "spotify", url: [/^open\.spotify\.com\/(artist\/\w+)/, /^open\.spotify\.com\/(album\/\w+)/, /^open\.spotify\.com\/(track\/\w+)/], html: (e3) => `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 126%;"><iframe src="https://open.spotify.com/embed/${e3[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" allowtransparency="true" allow="encrypted-media"></iframe></div>` }, { name: "youtube", url: [/^(?:m\.)?youtube\.com\/watch\?v=([\w-]+)/, /^(?:m\.)?youtube\.com\/v\/([\w-]+)/, /^youtube\.com\/embed\/([\w-]+)/, /^youtu\.be\/([\w-]+)/], html: (e3) => `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;"><iframe src="https://www.youtube.com/embed/${e3[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div>` }, { name: "vimeo", url: [/^vimeo\.com\/(\d+)/, /^vimeo\.com\/[^/]+\/[^/]+\/video\/(\d+)/, /^vimeo\.com\/album\/[^/]+\/video\/(\d+)/, /^vimeo\.com\/channels\/[^/]+\/(\d+)/, /^vimeo\.com\/groups\/[^/]+\/videos\/(\d+)/, /^vimeo\.com\/ondemand\/[^/]+\/(\d+)/, /^player\.vimeo\.com\/video\/(\d+)/], html: (e3) => `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;"><iframe src="https://player.vimeo.com/video/${e3[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe></div>` }, { name: "instagram", url: /^instagram\.com\/p\/(\w+)/ }, { name: "twitter", url: /^twitter\.com/ }, { name: "googleMaps", url: [/^google\.com\/maps/, /^goo\.gl\/maps/, /^maps\.google\.com/, /^maps\.app\.goo\.gl/] }, { name: "flickr", url: /^flickr\.com/ }, { name: "facebook", url: /^facebook\.com/ }] }), this.registry = new kp(e2.locale, e2.config.get("mediaEmbed"));
        }
        init() {
          const e2 = this.editor, t2 = e2.model.schema, i2 = e2.t, n2 = e2.conversion, o2 = e2.config.get("mediaEmbed.previewsInData"), r2 = e2.config.get("mediaEmbed.elementName"), s2 = this.registry;
          e2.commands.add("mediaEmbed", new wp(e2)), t2.register("media", { isObject: true, isBlock: true, allowWhere: "$block", allowAttributes: ["url"] }), n2.for("dataDowncast").elementToElement({ model: "media", view: (e3, { writer: t3 }) => {
            const i3 = e3.getAttribute("url");
            return fp(t3, s2, i3, { elementName: r2, renderMediaPreview: i3 && o2 });
          } }), n2.for("dataDowncast").add(mp(s2, { elementName: r2, renderMediaPreview: o2 })), n2.for("editingDowncast").elementToElement({ model: "media", view: (e3, { writer: t3 }) => {
            const n3 = e3.getAttribute("url");
            return function(e4, t4, i3) {
              return t4.setCustomProperty("media", true, e4), zh(e4, t4, { label: i3 });
            }(fp(t3, s2, n3, { elementName: r2, renderForEditingView: true }), t3, i2("media widget"));
          } }), n2.for("editingDowncast").add(mp(s2, { elementName: r2, renderForEditingView: true })), n2.for("upcast").elementToElement({ view: (e3) => ["oembed", r2].includes(e3.name) && e3.getAttribute("url") ? { name: true } : null, model: (e3, { writer: t3 }) => {
            const i3 = e3.getAttribute("url");
            if (s2.hasMedia(i3))
              return t3.createElement("media", { url: i3 });
          } }).elementToElement({ view: { name: "div", attributes: { "data-oembed-url": true } }, model: (e3, { writer: t3 }) => {
            const i3 = e3.getAttribute("data-oembed-url");
            if (s2.hasMedia(i3))
              return t3.createElement("media", { url: i3 });
          } }).add((e3) => {
            e3.on("element:figure", function(e4, t3, i3) {
              if (!i3.consumable.test(t3.viewItem, { name: true, classes: "media" }))
                return;
              const { modelRange: n3, modelCursor: o3 } = i3.convertChildren(t3.viewItem, t3.modelCursor);
              t3.modelRange = n3, t3.modelCursor = o3;
              if (!Ms(n3.getItems()))
                return;
              i3.consumable.consume(t3.viewItem, { name: true, classes: "media" });
            });
          });
        }
      }
      const yp = /^(?:http(s)?:\/\/)?[\w-]+\.[\w-.~:/?#[\]@!$&'()*+,;=%]+$/;
      class xp extends Qe {
        static get requires() {
          return [cu, Sh, tg];
        }
        static get pluginName() {
          return "AutoMediaEmbed";
        }
        constructor(e2) {
          super(e2), this._timeoutId = null, this._positionToInsert = null;
        }
        init() {
          const e2 = this.editor, t2 = e2.model.document;
          this.listenTo(e2.plugins.get("ClipboardPipeline"), "inputTransformation", () => {
            const e3 = t2.selection.getFirstRange(), i2 = Xc.fromPosition(e3.start);
            i2.stickiness = "toPrevious";
            const n2 = Xc.fromPosition(e3.end);
            n2.stickiness = "toNext", t2.once("change:data", () => {
              this._embedMediaBetweenPositions(i2, n2), i2.detach(), n2.detach();
            }, { priority: "high" });
          }), e2.commands.get("undo").on("execute", () => {
            this._timeoutId && (_r.window.clearTimeout(this._timeoutId), this._positionToInsert.detach(), this._timeoutId = null, this._positionToInsert = null);
          }, { priority: "high" });
        }
        _embedMediaBetweenPositions(e2, t2) {
          const i2 = this.editor, n2 = i2.plugins.get(vp).registry, o2 = new pa(e2, t2), r2 = o2.getWalker({ ignoreElementEnd: true });
          let s2 = "";
          for (const e3 of r2)
            e3.item.is("$textProxy") && (s2 += e3.item.data);
          if (s2 = s2.trim(), !s2.match(yp))
            return void o2.detach();
          if (!n2.hasMedia(s2))
            return void o2.detach();
          i2.commands.get("mediaEmbed").isEnabled ? (this._positionToInsert = Xc.fromPosition(e2), this._timeoutId = _r.window.setTimeout(() => {
            i2.model.change((e3) => {
              let t3;
              this._timeoutId = null, e3.remove(o2), o2.detach(), this._positionToInsert.root.rootName !== "$graveyard" && (t3 = this._positionToInsert), bp(i2.model, s2, t3), this._positionToInsert.detach(), this._positionToInsert = null;
            }), i2.plugins.get("Delete").requestUndoOnBackspace();
          }, 100)) : o2.detach();
        }
      }
      i(96);
      class Ap extends Nl {
        constructor(e2, t2) {
          super(t2);
          const i2 = t2.t;
          this.focusTracker = new Ns(), this.keystrokes = new Rs(), this.set("mediaURLInputValue", ""), this.urlInputView = this._createUrlInput(), this.saveButtonView = this._createButton(i2("Save"), El.check, "ck-button-save"), this.saveButtonView.type = "submit", this.saveButtonView.bind("isEnabled").to(this, "mediaURLInputValue", (e3) => !!e3), this.cancelButtonView = this._createButton(i2("Cancel"), El.cancel, "ck-button-cancel", "cancel"), this._focusables = new Ml(), this._focusCycler = new nd({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }), this._validators = e2, this.setTemplate({ tag: "form", attributes: { class: ["ck", "ck-media-form", "ck-responsive-form"], tabindex: "-1" }, children: [this.urlInputView, this.saveButtonView, this.cancelButtonView] }), Sl(this);
        }
        render() {
          super.render(), Pl({ view: this });
          [this.urlInputView, this.saveButtonView, this.cancelButtonView].forEach((e3) => {
            this._focusables.add(e3), this.focusTracker.add(e3.element);
          }), this.keystrokes.listenTo(this.element);
          const e2 = (e3) => e3.stopPropagation();
          this.keystrokes.set("arrowright", e2), this.keystrokes.set("arrowleft", e2), this.keystrokes.set("arrowup", e2), this.keystrokes.set("arrowdown", e2), this.listenTo(this.urlInputView.element, "selectstart", (e3, t2) => {
            t2.stopPropagation();
          }, { priority: "high" });
        }
        focus() {
          this._focusCycler.focusFirst();
        }
        get url() {
          return this.urlInputView.fieldView.element.value.trim();
        }
        set url(e2) {
          this.urlInputView.fieldView.element.value = e2.trim();
        }
        isValid() {
          this.resetFormStatus();
          for (const e2 of this._validators) {
            const t2 = e2(this);
            if (t2)
              return this.urlInputView.errorText = t2, false;
          }
          return true;
        }
        resetFormStatus() {
          this.urlInputView.errorText = null, this.urlInputView.infoText = this._urlInputViewInfoDefault;
        }
        _createUrlInput() {
          const e2 = this.locale.t, t2 = new Nd(this.locale, Rd), i2 = t2.fieldView;
          return this._urlInputViewInfoDefault = e2("Paste the media URL in the input."), this._urlInputViewInfoTip = e2("Tip: Paste the URL into the content to embed faster."), t2.label = e2("Media URL"), t2.infoText = this._urlInputViewInfoDefault, i2.on("input", () => {
            t2.infoText = i2.element.value ? this._urlInputViewInfoTip : this._urlInputViewInfoDefault, this.mediaURLInputValue = i2.element.value.trim();
          }), t2;
        }
        _createButton(e2, t2, i2, n2) {
          const o2 = new td(this.locale);
          return o2.set({ label: e2, icon: t2, tooltip: true }), o2.extendTemplate({ attributes: { class: i2 } }), n2 && o2.delegate("execute").to(this, n2), o2;
        }
      }
      class Cp extends Qe {
        static get requires() {
          return [vp];
        }
        static get pluginName() {
          return "MediaEmbedUI";
        }
        init() {
          const e2 = this.editor, t2 = e2.commands.get("mediaEmbed"), i2 = e2.plugins.get(vp).registry;
          e2.ui.componentFactory.add("mediaEmbed", (n2) => {
            const o2 = xd(n2), r2 = new Ap(function(e3, t3) {
              return [(t4) => {
                if (!t4.url.length)
                  return e3("The URL must not be empty.");
              }, (i3) => {
                if (!t3.hasMedia(i3.url))
                  return e3("This media URL is not supported.");
              }];
            }(e2.t, i2), e2.locale);
            return this._setUpDropdown(o2, r2, t2, e2), this._setUpForm(o2, r2, t2), o2;
          });
        }
        _setUpDropdown(e2, t2, i2) {
          const n2 = this.editor, o2 = n2.t, r2 = e2.buttonView;
          function s2() {
            n2.editing.view.focus(), e2.isOpen = false;
          }
          e2.bind("isEnabled").to(i2), e2.panelView.children.add(t2), r2.set({ label: o2("Insert media"), icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M18.68 3.03c.6 0 .59-.03.59.55v12.84c0 .59.01.56-.59.56H1.29c-.6 0-.59.03-.59-.56V3.58c0-.58-.01-.55.6-.55h17.38zM15.77 15V5H4.2v10h11.57zM2 4v1h1V4H2zm0 2v1h1V6H2zm0 2v1h1V8H2zm0 2v1h1v-1H2zm0 2v1h1v-1H2zm0 2v1h1v-1H2zM17 4v1h1V4h-1zm0 2v1h1V6h-1zm0 2v1h1V8h-1zm0 2v1h1v-1h-1zm0 2v1h1v-1h-1zm0 2v1h1v-1h-1zM7.5 7.177a.4.4 0 0 1 .593-.351l5.133 2.824a.4.4 0 0 1 0 .7l-5.133 2.824a.4.4 0 0 1-.593-.35V7.176v.001z"/></svg>', tooltip: true }), r2.on("open", () => {
            t2.disableCssTransitions(), t2.url = i2.value || "", t2.urlInputView.fieldView.select(), t2.focus(), t2.enableCssTransitions();
          }, { priority: "low" }), e2.on("submit", () => {
            t2.isValid() && (n2.execute("mediaEmbed", t2.url), s2());
          }), e2.on("change:isOpen", () => t2.resetFormStatus()), e2.on("cancel", () => s2());
        }
        _setUpForm(e2, t2, i2) {
          t2.delegate("submit", "cancel").to(e2), t2.urlInputView.bind("value").to(i2, "value"), t2.urlInputView.bind("isReadOnly").to(i2, "isEnabled", (e3) => !e3);
        }
      }
      i(98);
      function Tp(e2, t2) {
        if (!e2.childCount)
          return;
        const i2 = new gh(e2.document), n2 = function(e3, t3) {
          const i3 = t3.createRangeIn(e3), n3 = new mn({ name: /^p|h\d+$/, styles: { "mso-list": /.*/ } }), o3 = [];
          for (const e4 of i3)
            if (e4.type === "elementStart" && n3.match(e4.item)) {
              const t4 = Sp(e4.item);
              o3.push({ element: e4.item, id: t4.id, order: t4.order, indent: t4.indent });
            }
          return o3;
        }(e2, i2);
        if (!n2.length)
          return;
        let o2 = null, r2 = 1;
        n2.forEach((e3, s2) => {
          const a2 = function(e4, t3) {
            if (!e4)
              return true;
            if (e4.id !== t3.id)
              return t3.indent - e4.indent != 1;
            const i3 = t3.element.previousSibling;
            if (!i3)
              return true;
            return n3 = i3, !(n3.is("element", "ol") || n3.is("element", "ul"));
            var n3;
          }(n2[s2 - 1], e3), c2 = a2 ? null : n2[s2 - 1], l2 = (h2 = e3, (d2 = c2) ? h2.indent - d2.indent : h2.indent - 1);
          var d2, h2;
          if (a2 && (o2 = null, r2 = 1), !o2 || l2 !== 0) {
            const n3 = function(e4, t3) {
              const i3 = new RegExp(`@list l${e4.id}:level${e4.indent}\\s*({[^}]*)`, "gi"), n4 = /mso-level-number-format:([^;]{0,100});/gi, o3 = i3.exec(t3);
              let r3 = "decimal", s3 = "ol";
              if (o3 && o3[1]) {
                const t4 = n4.exec(o3[1]);
                if (t4 && t4[1] && (r3 = t4[1].trim(), s3 = r3 !== "bullet" && r3 !== "image" ? "ol" : "ul"), r3 === "bullet") {
                  const t5 = function(e5) {
                    const t6 = function(e6) {
                      if (e6.getChild(0).is("$text"))
                        return null;
                      for (const t7 of e6.getChildren()) {
                        if (!t7.is("element", "span"))
                          continue;
                        const e7 = t7.getChild(0);
                        return e7.is("$text") ? e7 : e7.getChild(0);
                      }
                    }(e5);
                    if (!t6)
                      return null;
                    const i4 = t6._data;
                    if (i4 === "o")
                      return "circle";
                    if (i4 === "\xB7")
                      return "disc";
                    if (i4 === "\xA7")
                      return "square";
                    return null;
                  }(e4.element);
                  t5 && (r3 = t5);
                }
              }
              return { type: s3, style: Ep(r3) };
            }(e3, t2);
            if (o2) {
              if (e3.indent > r2) {
                const e4 = o2.getChild(o2.childCount - 1), t3 = e4.getChild(e4.childCount - 1);
                o2 = Ip(n3, t3, i2), r2 += 1;
              } else if (e3.indent < r2) {
                const t3 = r2 - e3.indent;
                o2 = function(e4, t4) {
                  const i3 = e4.getAncestors({ parentFirst: true });
                  let n4 = null, o3 = 0;
                  for (const e5 of i3)
                    if (e5.name !== "ul" && e5.name !== "ol" || o3++, o3 === t4) {
                      n4 = e5;
                      break;
                    }
                  return n4;
                }(o2, t3), r2 = parseInt(e3.indent);
              }
            } else
              o2 = Ip(n3, e3.element, i2);
            e3.indent <= r2 && (o2.is("element", n3.type) || (o2 = i2.rename(n3.type, o2)));
          }
          const u2 = function(e4, t3) {
            return function(e5, t4) {
              const i3 = new mn({ name: "span", styles: { "mso-list": "Ignore" } }), n3 = t4.createRangeIn(e5);
              for (const e6 of n3)
                e6.type === "elementStart" && i3.match(e6.item) && t4.remove(e6.item);
            }(e4, t3), t3.rename("li", e4);
          }(e3.element, i2);
          i2.appendChild(u2, o2);
        });
      }
      function Ep(e2) {
        switch (e2) {
          case "arabic-leading-zero":
            return "decimal-leading-zero";
          case "alpha-upper":
            return "upper-alpha";
          case "alpha-lower":
            return "lower-alpha";
          case "roman-upper":
            return "upper-roman";
          case "roman-lower":
            return "lower-roman";
          case "circle":
          case "disc":
          case "square":
            return e2;
          default:
            return null;
        }
      }
      function Ip(e2, t2, i2) {
        const n2 = t2.parent, o2 = i2.createElement(e2.type), r2 = n2.getChildIndex(t2) + 1;
        return i2.insertChild(r2, o2, n2), e2.style && i2.setStyle("list-style-type", e2.style, o2), o2;
      }
      function Sp(e2) {
        const t2 = {}, i2 = e2.getStyle("mso-list");
        if (i2) {
          const e3 = i2.match(/(^|\s{1,100})l(\d+)/i), n2 = i2.match(/\s{0,100}lfo(\d+)/i), o2 = i2.match(/\s{0,100}level(\d+)/i);
          e3 && n2 && o2 && (t2.id = e3[2], t2.order = n2[1], t2.indent = o2[1]);
        }
        return t2;
      }
      const Pp = /id=("|')docs-internal-guid-[-0-9a-f]+("|')/i;
      class Mp {
        constructor(e2) {
          this.document = e2;
        }
        isActive(e2) {
          return Pp.test(e2);
        }
        execute(e2) {
          const t2 = new gh(this.document), { body: i2 } = e2._parsedData;
          !function(e3, t3) {
            for (const i3 of e3.getChildren())
              if (i3.is("element", "b") && i3.getStyle("font-weight") === "normal") {
                const n2 = e3.getChildIndex(i3);
                t3.remove(i3), t3.insertChild(n2, i3.getChildren(), e3);
              }
          }(i2, t2), function(e3, t3) {
            for (const i3 of t3.createRangeIn(e3)) {
              const e4 = i3.item;
              if (e4.is("element", "li")) {
                const i4 = e4.getChild(0);
                i4 && i4.is("element", "p") && t3.unwrapElement(i4);
              }
            }
          }(i2, t2), e2.content = i2;
        }
      }
      function Np(e2, t2) {
        if (!e2.childCount)
          return;
        const i2 = new gh();
        !function(e3, t3, i3) {
          const n3 = i3.createRangeIn(t3), o2 = new mn({ name: "img" }), r2 = [];
          for (const t4 of n3)
            if (o2.match(t4.item)) {
              const i4 = t4.item, n4 = i4.getAttribute("v:shapes") ? i4.getAttribute("v:shapes").split(" ") : [];
              n4.length && n4.every((t5) => e3.indexOf(t5) > -1) ? r2.push(i4) : i4.getAttribute("src") || r2.push(i4);
            }
          for (const e4 of r2)
            i3.remove(e4);
        }(function(e3, t3) {
          const i3 = t3.createRangeIn(e3), n3 = new mn({ name: /v:(.+)/ }), o2 = [];
          for (const e4 of i3) {
            if (e4.type != "elementStart")
              continue;
            const t4 = e4.item, i4 = t4.previousSibling && t4.previousSibling.name || null;
            n3.match(t4) && t4.getAttribute("o:gfxdata") && i4 !== "v:shapetype" && o2.push(e4.item.getAttribute("id"));
          }
          return o2;
        }(e2, i2), e2, i2), function(e3, t3) {
          const i3 = t3.createRangeIn(e3), n3 = new mn({ name: /v:(.+)/ }), o2 = [];
          for (const e4 of i3)
            e4.type == "elementStart" && n3.match(e4.item) && o2.push(e4.item);
          for (const e4 of o2)
            t3.remove(e4);
        }(e2, i2);
        const n2 = function(e3, t3) {
          const i3 = t3.createRangeIn(e3), n3 = new mn({ name: "img" }), o2 = [];
          for (const e4 of i3)
            n3.match(e4.item) && e4.item.getAttribute("src").startsWith("file://") && o2.push(e4.item);
          return o2;
        }(e2, i2);
        n2.length && function(e3, t3, i3) {
          if (e3.length === t3.length)
            for (let o2 = 0; o2 < e3.length; o2++) {
              const r2 = `data:${t3[o2].type};base64,${n3 = t3[o2].hex, btoa(n3.match(/\w{2}/g).map((e4) => String.fromCharCode(parseInt(e4, 16))).join(""))}`;
              i3.setAttribute("src", r2, e3[o2]);
            }
          var n3;
        }(n2, function(e3) {
          if (!e3)
            return [];
          const t3 = /{\\pict[\s\S]+?\\bliptag-?\d+(\\blipupi-?\d+)?({\\\*\\blipuid\s?[\da-fA-F]+)?[\s}]*?/, i3 = new RegExp("(?:(" + t3.source + "))([\\da-fA-F\\s]+)\\}", "g"), n3 = e3.match(i3), o2 = [];
          if (n3)
            for (const e4 of n3) {
              let i4 = false;
              e4.includes("\\pngblip") ? i4 = "image/png" : e4.includes("\\jpegblip") && (i4 = "image/jpeg"), i4 && o2.push({ hex: e4.replace(t3, "").replace(/[^\da-fA-F]/g, ""), type: i4 });
            }
          return o2;
        }(t2), i2);
      }
      const Rp = /<meta\s*name="?generator"?\s*content="?microsoft\s*word\s*\d+"?\/?>/i, Op = /xmlns:o="urn:schemas-microsoft-com/i;
      class zp {
        constructor(e2) {
          this.document = e2;
        }
        isActive(e2) {
          return Rp.test(e2) || Op.test(e2);
        }
        execute(e2) {
          const { body: t2, stylesString: i2 } = e2._parsedData;
          Tp(t2, i2), Np(t2, e2.dataTransfer.getData("text/rtf")), e2.content = t2;
        }
      }
      function Dp(e2) {
        return e2.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, (e3, t2) => t2.length === 1 ? " " : Array(t2.length + 1).join("\xA0 ").substr(0, t2.length));
      }
      function Lp(e2, t2) {
        const i2 = new DOMParser(), n2 = function(e3) {
          return Dp(Dp(e3)).replace(/(<span\s+style=['"]mso-spacerun:yes['"]>[^\S\r\n]*?)[\r\n]+([^\S\r\n]*<\/span>)/g, "$1$2").replace(/<span\s+style=['"]mso-spacerun:yes['"]><\/span>/g, "").replace(/ <\//g, "\xA0</").replace(/ <o:p><\/o:p>/g, "\xA0<o:p></o:p>").replace(/<o:p>(&nbsp;|\u00A0)<\/o:p>/g, "").replace(/>([^\S\r\n]*[\r\n]\s*)</g, "><");
        }(function(e3) {
          const t3 = e3.indexOf("</body>");
          if (t3 < 0)
            return e3;
          const i3 = e3.indexOf("</html>", t3 + "</body>".length);
          return e3.substring(0, t3 + "</body>".length) + (i3 >= 0 ? e3.substring(i3) : "");
        }(e2 = e2.replace(/<!--\[if gte vml 1]>/g, ""))), o2 = i2.parseFromString(n2, "text/html");
        !function(e3) {
          e3.querySelectorAll("span[style*=spacerun]").forEach((e4) => {
            const t3 = e4.innerText.length || 0;
            e4.innerHTML = Array(t3 + 1).join("\xA0 ").substr(0, t3);
          });
        }(o2);
        const r2 = o2.body.innerHTML, s2 = function(e3, t3) {
          const i3 = new yo(t3), n3 = new Tr(i3, { blockFillerMode: "nbsp" }), o3 = e3.createDocumentFragment(), r3 = e3.body.childNodes;
          for (; r3.length > 0; )
            o3.appendChild(r3[0]);
          return n3.domToView(o3, { skipComments: true });
        }(o2, t2), a2 = function(e3) {
          const t3 = [], i3 = [], n3 = Array.from(e3.getElementsByTagName("style"));
          for (const e4 of n3)
            e4.sheet && e4.sheet.cssRules && e4.sheet.cssRules.length && (t3.push(e4.sheet), i3.push(e4.innerHTML));
          return { styles: t3, stylesString: i3.join(" ") };
        }(o2);
        return { body: s2, bodyString: r2, styles: a2.styles, stylesString: a2.stylesString };
      }
      function Vp(e2, t2, i2, n2, o2 = 1) {
        t2 > o2 ? n2.setAttribute(e2, t2, i2) : n2.removeAttribute(e2, i2);
      }
      function jp(e2, t2, i2 = {}) {
        const n2 = e2.createElement("tableCell", i2);
        return e2.insertElement("paragraph", n2), e2.insert(n2, t2), n2;
      }
      function Bp(e2, t2) {
        const i2 = t2.parent.parent, n2 = parseInt(i2.getAttribute("headingColumns") || 0), { column: o2 } = e2.getCellLocation(t2);
        return !!n2 && o2 < n2;
      }
      function Fp() {
        return (e2) => {
          e2.on("element:table", (e3, t2, i2) => {
            const n2 = t2.viewItem;
            if (!i2.consumable.test(n2, { name: true }))
              return;
            const { rows: o2, headingRows: r2, headingColumns: s2 } = function(e4) {
              const t3 = { headingRows: 0, headingColumns: 0 }, i3 = [], n3 = [];
              let o3;
              for (const r3 of Array.from(e4.getChildren()))
                if (r3.name === "tbody" || r3.name === "thead" || r3.name === "tfoot") {
                  r3.name !== "thead" || o3 || (o3 = r3);
                  const e5 = Array.from(r3.getChildren()).filter((e6) => e6.is("element", "tr"));
                  for (const r4 of e5)
                    if (r4.parent.name === "thead" && r4.parent === o3)
                      t3.headingRows++, i3.push(r4);
                    else {
                      n3.push(r4);
                      const e6 = Up(r4);
                      e6 > t3.headingColumns && (t3.headingColumns = e6);
                    }
                }
              return t3.rows = [...i3, ...n3], t3;
            }(n2), a2 = {};
            s2 && (a2.headingColumns = s2), r2 && (a2.headingRows = r2);
            const c2 = i2.writer.createElement("table", a2);
            if (i2.safeInsert(c2, t2.modelCursor)) {
              if (i2.consumable.consume(n2, { name: true }), o2.forEach((e4) => i2.convertItem(e4, i2.writer.createPositionAt(c2, "end"))), i2.convertChildren(n2, i2.writer.createPositionAt(c2, "end")), c2.isEmpty) {
                const e4 = i2.writer.createElement("tableRow");
                i2.writer.insert(e4, i2.writer.createPositionAt(c2, "end")), jp(i2.writer, i2.writer.createPositionAt(e4, "end"));
              }
              i2.updateConversionResult(c2, t2);
            }
          });
        };
      }
      function Hp(e2) {
        return (t2) => {
          t2.on("element:" + e2, (e3, t3, i2) => {
            if (t3.modelRange && t3.viewItem.isEmpty) {
              const e4 = t3.modelRange.start.nodeAfter, n2 = i2.writer.createPositionAt(e4, 0);
              i2.writer.insertElement("paragraph", n2);
            }
          }, { priority: "low" });
        };
      }
      function Up(e2) {
        let t2 = 0, i2 = 0;
        const n2 = Array.from(e2.getChildren()).filter((e3) => e3.name === "th" || e3.name === "td");
        for (; i2 < n2.length && n2[i2].name === "th"; ) {
          const e3 = n2[i2];
          t2 += parseInt(e3.getAttribute("colspan") || 1), i2++;
        }
        return t2;
      }
      class Wp {
        constructor(e2, t2 = {}) {
          this._table = e2, this._startRow = t2.row !== void 0 ? t2.row : t2.startRow || 0, this._endRow = t2.row !== void 0 ? t2.row : t2.endRow, this._startColumn = t2.column !== void 0 ? t2.column : t2.startColumn || 0, this._endColumn = t2.column !== void 0 ? t2.column : t2.endColumn, this._includeAllSlots = !!t2.includeAllSlots, this._skipRows = new Set(), this._row = 0, this._rowIndex = 0, this._column = 0, this._cellIndex = 0, this._spannedCells = new Map(), this._nextCellAtColumn = -1;
        }
        [Symbol.iterator]() {
          return this;
        }
        next() {
          const e2 = this._table.getChild(this._rowIndex);
          if (!e2 || this._isOverEndRow())
            return { done: true };
          if (!e2.is("element", "tableRow"))
            return this._rowIndex++, this.next();
          if (this._isOverEndColumn())
            return this._advanceToNextRow();
          let t2 = null;
          const i2 = this._getSpanned();
          if (i2)
            this._includeAllSlots && !this._shouldSkipSlot() && (t2 = this._formatOutValue(i2.cell, i2.row, i2.column));
          else {
            const i3 = e2.getChild(this._cellIndex);
            if (!i3)
              return this._advanceToNextRow();
            const n2 = parseInt(i3.getAttribute("colspan") || 1), o2 = parseInt(i3.getAttribute("rowspan") || 1);
            (n2 > 1 || o2 > 1) && this._recordSpans(i3, o2, n2), this._shouldSkipSlot() || (t2 = this._formatOutValue(i3)), this._nextCellAtColumn = this._column + n2;
          }
          return this._column++, this._column == this._nextCellAtColumn && this._cellIndex++, t2 || this.next();
        }
        skipRow(e2) {
          this._skipRows.add(e2);
        }
        _advanceToNextRow() {
          return this._row++, this._rowIndex++, this._column = 0, this._cellIndex = 0, this._nextCellAtColumn = -1, this.next();
        }
        _isOverEndRow() {
          return this._endRow !== void 0 && this._row > this._endRow;
        }
        _isOverEndColumn() {
          return this._endColumn !== void 0 && this._column > this._endColumn;
        }
        _formatOutValue(e2, t2 = this._row, i2 = this._column) {
          return { done: false, value: new qp(this, e2, t2, i2) };
        }
        _shouldSkipSlot() {
          const e2 = this._skipRows.has(this._row), t2 = this._row < this._startRow, i2 = this._column < this._startColumn, n2 = this._endColumn !== void 0 && this._column > this._endColumn;
          return e2 || t2 || i2 || n2;
        }
        _getSpanned() {
          const e2 = this._spannedCells.get(this._row);
          return e2 && e2.get(this._column) || null;
        }
        _recordSpans(e2, t2, i2) {
          const n2 = { cell: e2, row: this._row, column: this._column };
          for (let e3 = this._row; e3 < this._row + t2; e3++)
            for (let t3 = this._column; t3 < this._column + i2; t3++)
              e3 == this._row && t3 == this._column || this._markSpannedCell(e3, t3, n2);
        }
        _markSpannedCell(e2, t2, i2) {
          this._spannedCells.has(e2) || this._spannedCells.set(e2, new Map());
          this._spannedCells.get(e2).set(t2, i2);
        }
      }
      class qp {
        constructor(e2, t2, i2, n2) {
          this.cell = t2, this.row = e2._row, this.column = e2._column, this.cellAnchorRow = i2, this.cellAnchorColumn = n2, this._cellIndex = e2._cellIndex, this._rowIndex = e2._rowIndex, this._table = e2._table;
        }
        get isAnchor() {
          return this.row === this.cellAnchorRow && this.column === this.cellAnchorColumn;
        }
        get cellWidth() {
          return parseInt(this.cell.getAttribute("colspan") || 1);
        }
        get cellHeight() {
          return parseInt(this.cell.getAttribute("rowspan") || 1);
        }
        get rowIndex() {
          return this._rowIndex;
        }
        getPositionBefore() {
          return this._table.root.document.model.createPositionAt(this._table.getChild(this.row), this._cellIndex);
        }
      }
      function $p(e2 = {}) {
        return (t2) => t2.on("insert:table", (t3, i2, n2) => {
          const o2 = i2.item;
          if (!n2.consumable.consume(o2, "insert"))
            return;
          n2.consumable.consume(o2, "attribute:headingRows:table"), n2.consumable.consume(o2, "attribute:headingColumns:table");
          const r2 = e2 && e2.asWidget, s2 = n2.writer.createContainerElement("figure", { class: "table" }), a2 = n2.writer.createContainerElement("table");
          let c2;
          var l2, d2;
          n2.writer.insert(n2.writer.createPositionAt(s2, 0), a2), r2 && (l2 = s2, (d2 = n2.writer).setCustomProperty("table", true, l2), c2 = zh(l2, d2, { hasSelectionHandle: true }));
          const h2 = new Wp(o2), u2 = { headingRows: o2.getAttribute("headingRows") || 0, headingColumns: o2.getAttribute("headingColumns") || 0 }, g2 = new Map();
          for (const t4 of h2) {
            const { row: i3, cell: r3 } = t4, s3 = o2.getChild(i3), c3 = g2.get(i3) || Jp(a2, s3, i3, u2, n2);
            g2.set(i3, c3), n2.consumable.consume(r3, "insert");
            Qp(t4, u2, n2.writer.createPositionAt(c3, "end"), n2, e2);
          }
          for (const e3 of o2.getChildren()) {
            const t4 = e3.index;
            e3.is("element", "tableRow") && !g2.has(t4) && g2.set(t4, Jp(a2, e3, t4, u2, n2));
          }
          const m2 = n2.mapper.toViewPosition(i2.range.start);
          n2.mapper.bindElements(o2, r2 ? c2 : s2), n2.writer.insert(m2, r2 ? c2 : s2);
        });
      }
      function Yp(e2, t2) {
        const { writer: i2 } = t2;
        if (e2.parent.is("element", "tableCell"))
          return Gp(e2) ? i2.createContainerElement("span", { class: "ck-table-bogus-paragraph" }) : i2.createContainerElement("p");
      }
      function Gp(e2) {
        return e2.parent.childCount === 1 && !tb(e2);
      }
      function Kp(e2, t2, i2) {
        const { cell: n2 } = e2, o2 = Zp(e2, t2), r2 = i2.mapper.toViewElement(n2);
        r2 && r2.name !== o2 && function(e3, t3, i3) {
          const n3 = i3.writer, o3 = i3.mapper.toViewElement(e3), r3 = Bh(n3.createEditableElement(t3, o3.getAttributes()), n3);
          n3.insert(n3.createPositionAfter(o3), r3), n3.move(n3.createRangeIn(o3), n3.createPositionAt(r3, 0)), n3.remove(n3.createRangeOn(o3)), i3.mapper.unbindViewElement(o3), i3.mapper.bindElements(e3, r3);
        }(n2, o2, i2);
      }
      function Qp(e2, t2, i2, n2, o2) {
        const r2 = o2 && o2.asWidget, s2 = Zp(e2, t2), a2 = r2 ? Bh(n2.writer.createEditableElement(s2), n2.writer) : n2.writer.createContainerElement(s2), c2 = e2.cell, l2 = c2.getChild(0), d2 = c2.childCount === 1 && l2.name === "paragraph";
        if (n2.writer.insert(i2, a2), n2.mapper.bindElements(c2, a2), !r2 && d2 && !tb(l2)) {
          const e3 = c2.getChild(0);
          n2.consumable.consume(e3, "insert"), n2.mapper.bindElements(e3, a2);
        }
      }
      function Jp(e2, t2, i2, n2, o2) {
        o2.consumable.consume(t2, "insert");
        const r2 = t2.isEmpty ? o2.writer.createEmptyElement("tr") : o2.writer.createContainerElement("tr");
        o2.mapper.bindElements(t2, r2);
        const s2 = n2.headingRows, a2 = function(e3, t3, i3) {
          const n3 = Xp(e3, t3);
          return n3 || function(e4, t4, i4) {
            const n4 = i4.writer.createContainerElement(e4), o3 = i4.writer.createPositionAt(t4, e4 == "tbody" ? "end" : 0);
            return i4.writer.insert(o3, n4), n4;
          }(e3, t3, i3);
        }(function(e3, t3) {
          return e3 < t3.headingRows ? "thead" : "tbody";
        }(i2, n2), e2, o2), c2 = s2 > 0 && i2 >= s2 ? i2 - s2 : i2, l2 = o2.writer.createPositionAt(a2, c2);
        return o2.writer.insert(l2, r2), r2;
      }
      function Zp(e2, t2) {
        const { row: i2, column: n2 } = e2, { headingColumns: o2, headingRows: r2 } = t2;
        if (r2 && r2 > i2)
          return "th";
        return o2 && o2 > n2 ? "th" : "td";
      }
      function Xp(e2, t2) {
        for (const i2 of t2.getChildren())
          if (i2.name == e2)
            return i2;
      }
      function eb(e2, t2, i2) {
        const n2 = Xp(e2, t2);
        n2 && n2.childCount === 0 && i2.writer.remove(i2.writer.createRangeOn(n2));
      }
      function tb(e2) {
        return !![...e2.getAttributeKeys()].length;
      }
      class ib extends Ze {
        refresh() {
          const e2 = this.editor.model, t2 = e2.document.selection, i2 = e2.schema;
          this.isEnabled = function(e3, t3) {
            const i3 = e3.getFirstPosition().parent, n2 = i3 === i3.root ? i3 : i3.parent;
            return t3.checkChild(n2, "table");
          }(t2, i2);
        }
        execute(e2 = {}) {
          const t2 = this.editor.model, i2 = t2.document.selection, n2 = this.editor.plugins.get("TableUtils"), o2 = this.editor.config.get("table"), r2 = Fh(i2, t2), s2 = o2.defaultHeadings.rows, a2 = o2.defaultHeadings.columns;
          e2.headingRows === void 0 && s2 && (e2.headingRows = s2), e2.headingColumns === void 0 && a2 && (e2.headingColumns = a2), t2.change((i3) => {
            const o3 = n2.createTable(i3, e2);
            t2.insertContent(o3, r2), i3.setSelection(i3.createPositionAt(o3.getNodeByPath([0, 0, 0]), 0));
          });
        }
      }
      function nb(e2) {
        const t2 = [];
        for (const i2 of lb(e2.getRanges())) {
          const e3 = i2.getContainedElement();
          e3 && e3.is("element", "tableCell") && t2.push(e3);
        }
        return t2;
      }
      function ob(e2) {
        const t2 = [];
        for (const i2 of e2.getRanges()) {
          const e3 = i2.start.findAncestor("tableCell");
          e3 && t2.push(e3);
        }
        return t2;
      }
      function rb(e2) {
        const t2 = nb(e2);
        return t2.length ? t2 : ob(e2);
      }
      function sb(e2) {
        return db(e2.map((e3) => e3.parent.index));
      }
      function ab(e2) {
        const t2 = e2[0].findAncestor("table");
        return db([...new Wp(t2)].filter((t3) => e2.includes(t3.cell)).map((e3) => e3.column));
      }
      function cb(e2, t2) {
        if (e2.length < 2 || !function(e3) {
          const t3 = e3[0].findAncestor("table"), i3 = sb(e3), n3 = parseInt(t3.getAttribute("headingRows") || 0);
          if (!ub(i3, n3))
            return false;
          const o3 = parseInt(t3.getAttribute("headingColumns") || 0);
          return ub(ab(e3), o3);
        }(e2))
          return false;
        const i2 = new Set(), n2 = new Set();
        let o2 = 0;
        for (const r2 of e2) {
          const { row: e3, column: s2 } = t2.getCellLocation(r2), a2 = parseInt(r2.getAttribute("rowspan") || 1), c2 = parseInt(r2.getAttribute("colspan") || 1);
          i2.add(e3), n2.add(s2), a2 > 1 && i2.add(e3 + a2 - 1), c2 > 1 && n2.add(s2 + c2 - 1), o2 += a2 * c2;
        }
        return function(e3, t3) {
          const i3 = Array.from(e3.values()), n3 = Array.from(t3.values()), o3 = Math.max(...i3), r2 = Math.min(...i3), s2 = Math.max(...n3), a2 = Math.min(...n3);
          return (o3 - r2 + 1) * (s2 - a2 + 1);
        }(i2, n2) == o2;
      }
      function lb(e2) {
        return Array.from(e2).sort(hb);
      }
      function db(e2) {
        const t2 = e2.sort((e3, t3) => e3 - t3);
        return { first: t2[0], last: t2[t2.length - 1] };
      }
      function hb(e2, t2) {
        const i2 = e2.start, n2 = t2.start;
        return i2.isBefore(n2) ? -1 : 1;
      }
      function ub({ first: e2, last: t2 }, i2) {
        return e2 < i2 === t2 < i2;
      }
      class gb extends Ze {
        constructor(e2, t2 = {}) {
          super(e2), this.order = t2.order || "below";
        }
        refresh() {
          const e2 = !!rb(this.editor.model.document.selection).length;
          this.isEnabled = e2;
        }
        execute() {
          const e2 = this.editor, t2 = e2.model.document.selection, i2 = e2.plugins.get("TableUtils"), n2 = this.order === "above", o2 = rb(t2), r2 = sb(o2), s2 = n2 ? r2.first : r2.last, a2 = o2[0].findAncestor("table");
          i2.insertRows(a2, { at: n2 ? s2 : s2 + 1, copyStructureFromAbove: !n2 });
        }
      }
      class mb extends Ze {
        constructor(e2, t2 = {}) {
          super(e2), this.order = t2.order || "right";
        }
        refresh() {
          const e2 = !!rb(this.editor.model.document.selection).length;
          this.isEnabled = e2;
        }
        execute() {
          const e2 = this.editor, t2 = e2.model.document.selection, i2 = e2.plugins.get("TableUtils"), n2 = this.order === "left", o2 = rb(t2), r2 = ab(o2), s2 = n2 ? r2.first : r2.last, a2 = o2[0].findAncestor("table");
          i2.insertColumns(a2, { columns: 1, at: n2 ? s2 : s2 + 1 });
        }
      }
      class fb extends Ze {
        constructor(e2, t2 = {}) {
          super(e2), this.direction = t2.direction || "horizontally";
        }
        refresh() {
          const e2 = rb(this.editor.model.document.selection);
          this.isEnabled = e2.length === 1;
        }
        execute() {
          const e2 = rb(this.editor.model.document.selection)[0], t2 = this.direction === "horizontally", i2 = this.editor.plugins.get("TableUtils");
          t2 ? i2.splitCellHorizontally(e2, 2) : i2.splitCellVertically(e2, 2);
        }
      }
      function pb(e2, t2, i2) {
        const { startRow: n2, startColumn: o2, endRow: r2, endColumn: s2 } = t2, a2 = i2.createElement("table"), c2 = r2 - n2 + 1;
        for (let e3 = 0; e3 < c2; e3++)
          i2.insertElement("tableRow", a2, "end");
        const l2 = [...new Wp(e2, { startRow: n2, endRow: r2, startColumn: o2, endColumn: s2, includeAllSlots: true })];
        for (const { row: e3, column: t3, cell: c3, isAnchor: d2, cellAnchorRow: h2, cellAnchorColumn: u2 } of l2) {
          const l3 = e3 - n2, g2 = a2.getChild(l3);
          if (d2) {
            const n3 = i2.cloneElement(c3);
            i2.append(n3, g2), vb(n3, e3, t3, r2, s2, i2);
          } else
            (h2 < n2 || u2 < o2) && jp(i2, i2.createPositionAt(g2, "end"));
        }
        return function(e3, t3, i3, n3, o3) {
          const r3 = parseInt(t3.getAttribute("headingRows") || 0);
          if (r3 > 0) {
            Vp("headingRows", r3 - i3, e3, o3, 0);
          }
          const s3 = parseInt(t3.getAttribute("headingColumns") || 0);
          if (s3 > 0) {
            Vp("headingColumns", s3 - n3, e3, o3, 0);
          }
        }(a2, e2, n2, o2, i2), a2;
      }
      function bb(e2, t2, i2 = 0) {
        const n2 = [], o2 = new Wp(e2, { startRow: i2, endRow: t2 - 1 });
        for (const e3 of o2) {
          const { row: i3, cellHeight: o3 } = e3, r2 = i3 + o3 - 1;
          i3 < t2 && t2 <= r2 && n2.push(e3);
        }
        return n2;
      }
      function wb(e2, t2, i2) {
        const n2 = e2.parent, o2 = n2.parent, r2 = n2.index, s2 = t2 - r2, a2 = {}, c2 = parseInt(e2.getAttribute("rowspan")) - s2;
        c2 > 1 && (a2.rowspan = c2);
        const l2 = parseInt(e2.getAttribute("colspan") || 1);
        l2 > 1 && (a2.colspan = l2);
        const d2 = r2 + s2, h2 = [...new Wp(o2, { startRow: r2, endRow: d2, includeAllSlots: true })];
        let u2, g2 = null;
        for (const t3 of h2) {
          const { row: n3, column: o3, cell: r3 } = t3;
          r3 === e2 && u2 === void 0 && (u2 = o3), u2 !== void 0 && u2 === o3 && n3 === d2 && (g2 = jp(i2, t3.getPositionBefore(), a2));
        }
        return Vp("rowspan", s2, e2, i2), g2;
      }
      function kb(e2, t2) {
        const i2 = [], n2 = new Wp(e2);
        for (const e3 of n2) {
          const { column: n3, cellWidth: o2 } = e3, r2 = n3 + o2 - 1;
          n3 < t2 && t2 <= r2 && i2.push(e3);
        }
        return i2;
      }
      function _b(e2, t2, i2, n2) {
        const o2 = i2 - t2, r2 = {}, s2 = parseInt(e2.getAttribute("colspan")) - o2;
        s2 > 1 && (r2.colspan = s2);
        const a2 = parseInt(e2.getAttribute("rowspan") || 1);
        a2 > 1 && (r2.rowspan = a2);
        const c2 = jp(n2, n2.createPositionAfter(e2), r2);
        return Vp("colspan", o2, e2, n2), c2;
      }
      function vb(e2, t2, i2, n2, o2, r2) {
        const s2 = parseInt(e2.getAttribute("colspan") || 1), a2 = parseInt(e2.getAttribute("rowspan") || 1);
        if (i2 + s2 - 1 > o2) {
          Vp("colspan", o2 - i2 + 1, e2, r2, 1);
        }
        if (t2 + a2 - 1 > n2) {
          Vp("rowspan", n2 - t2 + 1, e2, r2, 1);
        }
      }
      function yb(e2, t2) {
        const i2 = t2.getColumns(e2), n2 = new Array(i2).fill(0);
        for (const { column: t3 } of new Wp(e2))
          n2[t3]++;
        const o2 = n2.reduce((e3, t3, i3) => t3 ? e3 : [...e3, i3], []);
        if (o2.length > 0) {
          const i3 = o2[o2.length - 1];
          return t2.removeColumns(e2, { at: i3 }), true;
        }
        return false;
      }
      function xb(e2, t2) {
        const i2 = [], n2 = t2.getRows(e2);
        for (let t3 = 0; t3 < n2; t3++) {
          e2.getChild(t3).isEmpty && i2.push(t3);
        }
        if (i2.length > 0) {
          const n3 = i2[i2.length - 1];
          return t2.removeRows(e2, { at: n3 }), true;
        }
        return false;
      }
      function Ab(e2, t2) {
        yb(e2, t2) || xb(e2, t2);
      }
      function Cb(e2, t2) {
        const i2 = Array.from(new Wp(e2, { startColumn: t2.firstColumn, endColumn: t2.lastColumn, row: t2.lastRow }));
        if (i2.every(({ cellHeight: e3 }) => e3 === 1))
          return t2.lastRow;
        const n2 = i2[0].cellHeight - 1;
        return t2.lastRow + n2;
      }
      function Tb(e2, t2) {
        const i2 = Array.from(new Wp(e2, { startRow: t2.firstRow, endRow: t2.lastRow, column: t2.lastColumn }));
        if (i2.every(({ cellWidth: e3 }) => e3 === 1))
          return t2.lastColumn;
        const n2 = i2[0].cellWidth - 1;
        return t2.lastColumn + n2;
      }
      class Eb extends Ze {
        constructor(e2, t2) {
          super(e2), this.direction = t2.direction, this.isHorizontal = this.direction == "right" || this.direction == "left";
        }
        refresh() {
          const e2 = this._getMergeableCell();
          this.value = e2, this.isEnabled = !!e2;
        }
        execute() {
          const e2 = this.editor.model, t2 = ob(e2.document.selection)[0], i2 = this.value, n2 = this.direction;
          e2.change((e3) => {
            const o2 = n2 == "right" || n2 == "down", r2 = o2 ? t2 : i2, s2 = o2 ? i2 : t2, a2 = s2.parent;
            !function(e4, t3, i3) {
              Ib(e4) || (Ib(t3) && i3.remove(i3.createRangeIn(t3)), i3.move(i3.createRangeIn(e4), i3.createPositionAt(t3, "end")));
              i3.remove(e4);
            }(s2, r2, e3);
            const c2 = this.isHorizontal ? "colspan" : "rowspan", l2 = parseInt(t2.getAttribute(c2) || 1), d2 = parseInt(i2.getAttribute(c2) || 1);
            e3.setAttribute(c2, l2 + d2, r2), e3.setSelection(e3.createRangeIn(r2));
            const h2 = this.editor.plugins.get("TableUtils");
            Ab(a2.findAncestor("table"), h2);
          });
        }
        _getMergeableCell() {
          const e2 = ob(this.editor.model.document.selection)[0];
          if (!e2)
            return;
          const t2 = this.editor.plugins.get("TableUtils"), i2 = this.isHorizontal ? function(e3, t3, i3) {
            const n3 = e3.parent.parent, o3 = t3 == "right" ? e3.nextSibling : e3.previousSibling, r2 = (n3.getAttribute("headingColumns") || 0) > 0;
            if (!o3)
              return;
            const s2 = t3 == "right" ? e3 : o3, a2 = t3 == "right" ? o3 : e3, { column: c2 } = i3.getCellLocation(s2), { column: l2 } = i3.getCellLocation(a2), d2 = parseInt(s2.getAttribute("colspan") || 1), h2 = Bp(i3, s2), u2 = Bp(i3, a2);
            if (r2 && h2 != u2)
              return;
            return c2 + d2 === l2 ? o3 : void 0;
          }(e2, this.direction, t2) : function(e3, t3, i3) {
            const n3 = e3.parent, o3 = n3.parent, r2 = o3.getChildIndex(n3);
            if (t3 == "down" && r2 === i3.getRows(o3) - 1 || t3 == "up" && r2 === 0)
              return;
            const s2 = parseInt(e3.getAttribute("rowspan") || 1), a2 = o3.getAttribute("headingRows") || 0, c2 = t3 == "down" && r2 + s2 === a2, l2 = t3 == "up" && r2 === a2;
            if (a2 && (c2 || l2))
              return;
            const d2 = parseInt(e3.getAttribute("rowspan") || 1), h2 = t3 == "down" ? r2 + d2 : r2, u2 = [...new Wp(o3, { endRow: h2 })], g2 = u2.find((t4) => t4.cell === e3).column, m2 = u2.find(({ row: e4, cellHeight: i4, column: n4 }) => n4 === g2 && (t3 == "down" ? e4 === h2 : h2 === e4 + i4));
            return m2 && m2.cell;
          }(e2, this.direction, t2);
          if (!i2)
            return;
          const n2 = this.isHorizontal ? "rowspan" : "colspan", o2 = parseInt(e2.getAttribute(n2) || 1);
          return parseInt(i2.getAttribute(n2) || 1) === o2 ? i2 : void 0;
        }
      }
      function Ib(e2) {
        return e2.childCount == 1 && e2.getChild(0).is("element", "paragraph") && e2.getChild(0).isEmpty;
      }
      class Sb extends Ze {
        refresh() {
          const e2 = rb(this.editor.model.document.selection), t2 = e2[0];
          if (t2) {
            const i2 = t2.findAncestor("table"), n2 = this.editor.plugins.get("TableUtils").getRows(i2) - 1, o2 = sb(e2), r2 = o2.first === 0 && o2.last === n2;
            this.isEnabled = !r2;
          } else
            this.isEnabled = false;
        }
        execute() {
          const e2 = this.editor.model, t2 = this.editor.plugins.get("TableUtils"), i2 = rb(e2.document.selection), n2 = sb(i2), o2 = i2[0], r2 = o2.findAncestor("table"), s2 = t2.getCellLocation(o2).column;
          e2.change((e3) => {
            const i3 = n2.last - n2.first + 1;
            t2.removeRows(r2, { at: n2.first, rows: i3 });
            const o3 = function(e4, t3, i4, n3) {
              const o4 = e4.getChild(Math.min(t3, n3 - 1));
              let r3 = o4.getChild(0), s3 = 0;
              for (const e5 of o4.getChildren()) {
                if (s3 > i4)
                  return r3;
                r3 = e5, s3 += parseInt(e5.getAttribute("colspan") || 1);
              }
              return r3;
            }(r2, n2.first, s2, t2.getRows(r2));
            e3.setSelection(e3.createPositionAt(o3, 0));
          });
        }
      }
      class Pb extends Ze {
        refresh() {
          const e2 = rb(this.editor.model.document.selection), t2 = e2[0];
          if (t2) {
            const i2 = t2.findAncestor("table"), n2 = this.editor.plugins.get("TableUtils").getColumns(i2), { first: o2, last: r2 } = ab(e2);
            this.isEnabled = r2 - o2 < n2 - 1;
          } else
            this.isEnabled = false;
        }
        execute() {
          const [e2, t2] = function(e3) {
            const t3 = rb(e3), i3 = t3[0], n3 = t3.pop(), o3 = [i3, n3];
            return i3.isBefore(n3) ? o3 : o3.reverse();
          }(this.editor.model.document.selection), i2 = e2.parent.parent, n2 = [...new Wp(i2)], o2 = { first: n2.find((t3) => t3.cell === e2).column, last: n2.find((e3) => e3.cell === t2).column }, r2 = function(e3, t3, i3, n3) {
            return parseInt(i3.getAttribute("colspan") || 1) > 1 ? i3 : t3.previousSibling || i3.nextSibling ? i3.nextSibling || t3.previousSibling : n3.first ? e3.reverse().find(({ column: e4 }) => e4 < n3.first).cell : e3.reverse().find(({ column: e4 }) => e4 > n3.last).cell;
          }(n2, e2, t2, o2);
          this.editor.model.change((e3) => {
            const t3 = o2.last - o2.first + 1;
            this.editor.plugins.get("TableUtils").removeColumns(i2, { at: o2.first, columns: t3 }), e3.setSelection(e3.createPositionAt(r2, 0));
          });
        }
      }
      class Mb extends Ze {
        refresh() {
          const e2 = rb(this.editor.model.document.selection), t2 = e2.length > 0;
          this.isEnabled = t2, this.value = t2 && e2.every((e3) => this._isInHeading(e3, e3.parent.parent));
        }
        execute(e2 = {}) {
          if (e2.forceValue === this.value)
            return;
          const t2 = this.editor.model, i2 = rb(t2.document.selection), n2 = i2[0].findAncestor("table"), { first: o2, last: r2 } = sb(i2), s2 = this.value ? o2 : r2 + 1, a2 = n2.getAttribute("headingRows") || 0;
          t2.change((e3) => {
            if (s2) {
              const t3 = bb(n2, s2, s2 > a2 ? a2 : 0);
              for (const { cell: i3 } of t3)
                wb(i3, s2, e3);
            }
            Vp("headingRows", s2, n2, e3, 0);
          });
        }
        _isInHeading(e2, t2) {
          const i2 = parseInt(t2.getAttribute("headingRows") || 0);
          return !!i2 && e2.parent.index < i2;
        }
      }
      class Nb extends Ze {
        refresh() {
          const e2 = rb(this.editor.model.document.selection), t2 = this.editor.plugins.get("TableUtils"), i2 = e2.length > 0;
          this.isEnabled = i2, this.value = i2 && e2.every((e3) => Bp(t2, e3));
        }
        execute(e2 = {}) {
          if (e2.forceValue === this.value)
            return;
          const t2 = this.editor.model, i2 = rb(t2.document.selection), n2 = i2[0].findAncestor("table"), { first: o2, last: r2 } = ab(i2), s2 = this.value ? o2 : r2 + 1;
          t2.change((e3) => {
            if (s2) {
              const t3 = kb(n2, s2);
              for (const { cell: i3, column: n3 } of t3)
                _b(i3, n3, s2, e3);
            }
            Vp("headingColumns", s2, n2, e3, 0);
          });
        }
      }
      class Rb extends Qe {
        static get pluginName() {
          return "TableUtils";
        }
        init() {
          this.decorate("insertColumns"), this.decorate("insertRows");
        }
        getCellLocation(e2) {
          const t2 = e2.parent, i2 = t2.parent, n2 = i2.getChildIndex(t2), o2 = new Wp(i2, { row: n2 });
          for (const { cell: t3, row: i3, column: n3 } of o2)
            if (t3 === e2)
              return { row: i3, column: n3 };
        }
        createTable(e2, t2) {
          const i2 = e2.createElement("table"), n2 = parseInt(t2.rows) || 2, o2 = parseInt(t2.columns) || 2;
          return Ob(e2, i2, 0, n2, o2), t2.headingRows && Vp("headingRows", Math.min(t2.headingRows, n2), i2, e2, 0), t2.headingColumns && Vp("headingColumns", Math.min(t2.headingColumns, o2), i2, e2, 0), i2;
        }
        insertRows(e2, t2 = {}) {
          const i2 = this.editor.model, n2 = t2.at || 0, o2 = t2.rows || 1, r2 = t2.copyStructureFromAbove !== void 0, s2 = t2.copyStructureFromAbove ? n2 - 1 : n2, a2 = this.getRows(e2), l2 = this.getColumns(e2);
          if (n2 > a2)
            throw new c.a("tableutils-insertrows-insert-out-of-range", this, { options: t2 });
          i2.change((t3) => {
            const i3 = e2.getAttribute("headingRows") || 0;
            if (i3 > n2 && Vp("headingRows", i3 + o2, e2, t3, 0), !r2 && (n2 === 0 || n2 === a2))
              return void Ob(t3, e2, n2, o2, l2);
            const c2 = r2 ? Math.max(n2, s2) : n2, d2 = new Wp(e2, { endRow: c2 }), h2 = new Array(l2).fill(1);
            for (const { row: e3, column: i4, cellHeight: a3, cellWidth: c3, cell: l3 } of d2) {
              const d3 = e3 + a3 - 1, u2 = e3 <= s2 && s2 <= d3;
              e3 < n2 && n2 <= d3 ? (t3.setAttribute("rowspan", a3 + o2, l3), h2[i4] = -c3) : r2 && u2 && (h2[i4] = c3);
            }
            for (let i4 = 0; i4 < o2; i4++) {
              const i5 = t3.createElement("tableRow");
              t3.insert(i5, e2, n2);
              for (let e3 = 0; e3 < h2.length; e3++) {
                const n3 = h2[e3], o3 = t3.createPositionAt(i5, "end");
                n3 > 0 && jp(t3, o3, n3 > 1 ? { colspan: n3 } : null), e3 += Math.abs(n3) - 1;
              }
            }
          });
        }
        insertColumns(e2, t2 = {}) {
          const i2 = this.editor.model, n2 = t2.at || 0, o2 = t2.columns || 1;
          i2.change((t3) => {
            const i3 = e2.getAttribute("headingColumns");
            n2 < i3 && t3.setAttribute("headingColumns", i3 + o2, e2);
            const r2 = this.getColumns(e2);
            if (n2 === 0 || r2 === n2) {
              for (const i4 of e2.getChildren())
                i4.is("element", "tableRow") && zb(o2, t3, t3.createPositionAt(i4, n2 ? "end" : 0));
              return;
            }
            const s2 = new Wp(e2, { column: n2, includeAllSlots: true });
            for (const e3 of s2) {
              const { row: i4, cell: r3, cellAnchorColumn: a2, cellAnchorRow: c2, cellWidth: l2, cellHeight: d2 } = e3;
              if (a2 < n2) {
                t3.setAttribute("colspan", l2 + o2, r3);
                const e4 = c2 + d2 - 1;
                for (let t4 = i4; t4 <= e4; t4++)
                  s2.skipRow(t4);
              } else
                zb(o2, t3, e3.getPositionBefore());
            }
          });
        }
        removeRows(e2, t2) {
          const i2 = this.editor.model, n2 = t2.rows || 1, o2 = this.getRows(e2), r2 = t2.at, s2 = r2 + n2 - 1;
          if (s2 > o2 - 1)
            throw new c.a("tableutils-removerows-row-index-out-of-range", this, { table: e2, options: t2 });
          i2.change((t3) => {
            const { cellsToMove: i3, cellsToTrim: n3 } = function(e3, t4, i4) {
              const n4 = new Map(), o3 = [];
              for (const { row: r3, column: s3, cellHeight: a2, cell: c2 } of new Wp(e3, { endRow: i4 })) {
                const e4 = r3 + a2 - 1;
                if (r3 >= t4 && r3 <= i4 && e4 > i4) {
                  const e5 = a2 - (i4 - r3 + 1);
                  n4.set(s3, { cell: c2, rowspan: e5 });
                }
                if (r3 < t4 && e4 >= t4) {
                  let n5;
                  n5 = e4 >= i4 ? i4 - t4 + 1 : e4 - t4 + 1, o3.push({ cell: c2, rowspan: a2 - n5 });
                }
              }
              return { cellsToMove: n4, cellsToTrim: o3 };
            }(e2, r2, s2);
            if (i3.size) {
              !function(e3, t4, i4, n4) {
                const o3 = [...new Wp(e3, { includeAllSlots: true, row: t4 })], r3 = e3.getChild(t4);
                let s3;
                for (const { column: e4, cell: t5, isAnchor: a2 } of o3)
                  if (i4.has(e4)) {
                    const { cell: t6, rowspan: o4 } = i4.get(e4), a3 = s3 ? n4.createPositionAfter(s3) : n4.createPositionAt(r3, 0);
                    n4.move(n4.createRangeOn(t6), a3), Vp("rowspan", o4, t6, n4), s3 = t6;
                  } else
                    a2 && (s3 = t5);
              }(e2, s2 + 1, i3, t3);
            }
            for (let i4 = s2; i4 >= r2; i4--)
              t3.remove(e2.getChild(i4));
            for (const { rowspan: e3, cell: i4 } of n3)
              Vp("rowspan", e3, i4, t3);
            !function(e3, t4, i4, n4) {
              const o3 = e3.getAttribute("headingRows") || 0;
              if (t4 < o3) {
                Vp("headingRows", i4 < o3 ? o3 - (i4 - t4 + 1) : t4, e3, n4, 0);
              }
            }(e2, r2, s2, t3), yb(e2, this) || xb(e2, this);
          });
        }
        removeColumns(e2, t2) {
          const i2 = this.editor.model, n2 = t2.at, o2 = t2.columns || 1, r2 = t2.at + o2 - 1;
          i2.change((t3) => {
            !function(e3, t4, i3) {
              const n3 = e3.getAttribute("headingColumns") || 0;
              if (n3 && t4.first < n3) {
                const o3 = Math.min(n3 - 1, t4.last) - t4.first + 1;
                i3.setAttribute("headingColumns", n3 - o3, e3);
              }
            }(e2, { first: n2, last: r2 }, t3);
            for (let i3 = r2; i3 >= n2; i3--)
              for (const { cell: n3, column: o3, cellWidth: r3 } of [...new Wp(e2)])
                o3 <= i3 && r3 > 1 && o3 + r3 > i3 ? Vp("colspan", r3 - 1, n3, t3) : o3 === i3 && t3.remove(n3);
            xb(e2, this) || yb(e2, this);
          });
        }
        splitCellVertically(e2, t2 = 2) {
          const i2 = this.editor.model, n2 = e2.parent.parent, o2 = parseInt(e2.getAttribute("rowspan") || 1), r2 = parseInt(e2.getAttribute("colspan") || 1);
          i2.change((i3) => {
            if (r2 > 1) {
              const { newCellsSpan: n3, updatedSpan: s2 } = Db(r2, t2);
              Vp("colspan", s2, e2, i3);
              const a2 = {};
              n3 > 1 && (a2.colspan = n3), o2 > 1 && (a2.rowspan = o2);
              zb(r2 > t2 ? t2 - 1 : r2 - 1, i3, i3.createPositionAfter(e2), a2);
            }
            if (r2 < t2) {
              const s2 = t2 - r2, a2 = [...new Wp(n2)], { column: c2 } = a2.find(({ cell: t3 }) => t3 === e2), l2 = a2.filter(({ cell: t3, cellWidth: i4, column: n3 }) => t3 !== e2 && n3 === c2 || n3 < c2 && n3 + i4 > c2);
              for (const { cell: e3, cellWidth: t3 } of l2)
                i3.setAttribute("colspan", t3 + s2, e3);
              const d2 = {};
              o2 > 1 && (d2.rowspan = o2), zb(s2, i3, i3.createPositionAfter(e2), d2);
              const h2 = n2.getAttribute("headingColumns") || 0;
              h2 > c2 && Vp("headingColumns", h2 + s2, n2, i3);
            }
          });
        }
        splitCellHorizontally(e2, t2 = 2) {
          const i2 = this.editor.model, n2 = e2.parent, o2 = n2.parent, r2 = o2.getChildIndex(n2), s2 = parseInt(e2.getAttribute("rowspan") || 1), a2 = parseInt(e2.getAttribute("colspan") || 1);
          i2.change((i3) => {
            if (s2 > 1) {
              const n3 = [...new Wp(o2, { startRow: r2, endRow: r2 + s2 - 1, includeAllSlots: true })], { newCellsSpan: c2, updatedSpan: l2 } = Db(s2, t2);
              Vp("rowspan", l2, e2, i3);
              const { column: d2 } = n3.find(({ cell: t3 }) => t3 === e2), h2 = {};
              c2 > 1 && (h2.rowspan = c2), a2 > 1 && (h2.colspan = a2);
              for (const e3 of n3) {
                const { column: t3, row: n4 } = e3, o3 = t3 === d2, s3 = (n4 + r2 + l2) % c2 == 0;
                n4 >= r2 + l2 && o3 && s3 && zb(1, i3, e3.getPositionBefore(), h2);
              }
            }
            if (s2 < t2) {
              const n3 = t2 - s2, c2 = [...new Wp(o2, { startRow: 0, endRow: r2 })];
              for (const { cell: t3, cellHeight: o3, row: s3 } of c2)
                if (t3 !== e2 && s3 + o3 > r2) {
                  const e3 = o3 + n3;
                  i3.setAttribute("rowspan", e3, t3);
                }
              const l2 = {};
              a2 > 1 && (l2.colspan = a2), Ob(i3, o2, r2 + 1, n3, 1, l2);
              const d2 = o2.getAttribute("headingRows") || 0;
              d2 > r2 && Vp("headingRows", d2 + n3, o2, i3);
            }
          });
        }
        getColumns(e2) {
          return [...e2.getChild(0).getChildren()].reduce((e3, t2) => e3 + parseInt(t2.getAttribute("colspan") || 1), 0);
        }
        getRows(e2) {
          return Array.from(e2.getChildren()).reduce((e3, t2) => t2.is("element", "tableRow") ? e3 + 1 : e3, 0);
        }
      }
      function Ob(e2, t2, i2, n2, o2, r2 = {}) {
        for (let s2 = 0; s2 < n2; s2++) {
          const n3 = e2.createElement("tableRow");
          e2.insert(n3, t2, i2), zb(o2, e2, e2.createPositionAt(n3, "end"), r2);
        }
      }
      function zb(e2, t2, i2, n2 = {}) {
        for (let o2 = 0; o2 < e2; o2++)
          jp(t2, i2, n2);
      }
      function Db(e2, t2) {
        if (e2 < t2)
          return { newCellsSpan: 1, updatedSpan: 1 };
        const i2 = Math.floor(e2 / t2);
        return { newCellsSpan: i2, updatedSpan: e2 - i2 * t2 + i2 };
      }
      class Lb extends Ze {
        refresh() {
          const e2 = nb(this.editor.model.document.selection);
          this.isEnabled = cb(e2, this.editor.plugins.get(Rb));
        }
        execute() {
          const e2 = this.editor.model, t2 = this.editor.plugins.get(Rb);
          e2.change((i2) => {
            const n2 = nb(e2.document.selection), o2 = n2.shift(), { mergeWidth: r2, mergeHeight: s2 } = function(e3, t3, i3) {
              let n3 = 0, o3 = 0;
              for (const e4 of t3) {
                const { row: t4, column: r4 } = i3.getCellLocation(e4);
                n3 = Bb(e4, r4, n3, "colspan"), o3 = Bb(e4, t4, o3, "rowspan");
              }
              const { row: r3, column: s3 } = i3.getCellLocation(e3);
              return { mergeWidth: n3 - s3, mergeHeight: o3 - r3 };
            }(o2, n2, t2);
            Vp("colspan", r2, o2, i2), Vp("rowspan", s2, o2, i2);
            for (const e3 of n2)
              Vb(e3, o2, i2);
            Ab(o2.findAncestor("table"), t2), i2.setSelection(o2, "in");
          });
        }
      }
      function Vb(e2, t2, i2) {
        jb(e2) || (jb(t2) && i2.remove(i2.createRangeIn(t2)), i2.move(i2.createRangeIn(e2), i2.createPositionAt(t2, "end"))), i2.remove(e2);
      }
      function jb(e2) {
        return e2.childCount == 1 && e2.getChild(0).is("element", "paragraph") && e2.getChild(0).isEmpty;
      }
      function Bb(e2, t2, i2, n2) {
        const o2 = parseInt(e2.getAttribute(n2) || 1);
        return Math.max(i2, t2 + o2);
      }
      class Fb extends Ze {
        refresh() {
          const e2 = rb(this.editor.model.document.selection);
          this.isEnabled = e2.length > 0;
        }
        execute() {
          const e2 = this.editor.model, t2 = rb(e2.document.selection), i2 = sb(t2), n2 = t2[0].findAncestor("table"), o2 = [];
          for (let t3 = i2.first; t3 <= i2.last; t3++)
            for (const i3 of n2.getChild(t3).getChildren())
              o2.push(e2.createRangeOn(i3));
          e2.change((e3) => {
            e3.setSelection(o2);
          });
        }
      }
      class Hb extends Ze {
        refresh() {
          const e2 = rb(this.editor.model.document.selection);
          this.isEnabled = e2.length > 0;
        }
        execute() {
          const e2 = this.editor.model, t2 = rb(e2.document.selection), i2 = t2[0], n2 = t2.pop(), o2 = i2.findAncestor("table"), r2 = this.editor.plugins.get("TableUtils"), s2 = r2.getCellLocation(i2), a2 = r2.getCellLocation(n2), c2 = Math.min(s2.column, a2.column), l2 = Math.max(s2.column, a2.column), d2 = [];
          for (const t3 of new Wp(o2, { startColumn: c2, endColumn: l2 }))
            d2.push(e2.createRangeOn(t3.cell));
          e2.change((e3) => {
            e3.setSelection(d2);
          });
        }
      }
      function Ub(e2) {
        e2.document.registerPostFixer((t2) => function(e3, t3) {
          const i2 = t3.document.differ.getChanges();
          let n2 = false;
          const o2 = new Set();
          for (const t4 of i2) {
            let i3;
            t4.name == "table" && t4.type == "insert" && (i3 = t4.position.nodeAfter), t4.name != "tableRow" && t4.name != "tableCell" || (i3 = t4.position.findAncestor("table")), $b(t4) && (i3 = t4.range.start.findAncestor("table")), i3 && !o2.has(i3) && (n2 = Wb(i3, e3) || n2, n2 = qb(i3, e3) || n2, o2.add(i3));
          }
          return n2;
        }(t2, e2));
      }
      function Wb(e2, t2) {
        let i2 = false;
        const n2 = function(e3) {
          const t3 = parseInt(e3.getAttribute("headingRows") || 0), i3 = Array.from(e3.getChildren()).reduce((e4, t4) => t4.is("element", "tableRow") ? e4 + 1 : e4, 0), n3 = [];
          for (const { row: o2, cell: r2, cellHeight: s2 } of new Wp(e3)) {
            if (s2 < 2)
              continue;
            const e4 = o2 < t3 ? t3 : i3;
            if (o2 + s2 > e4) {
              const t4 = e4 - o2;
              n3.push({ cell: r2, rowspan: t4 });
            }
          }
          return n3;
        }(e2);
        if (n2.length) {
          i2 = true;
          for (const e3 of n2)
            Vp("rowspan", e3.rowspan, e3.cell, t2, 1);
        }
        return i2;
      }
      function qb(e2, t2) {
        let i2 = false;
        const n2 = function(e3) {
          const t3 = new Array(e3.childCount).fill(0);
          for (const { rowIndex: i3 } of new Wp(e3, { includeAllSlots: true }))
            t3[i3]++;
          return t3;
        }(e2), o2 = [];
        for (const [t3, i3] of n2.entries())
          !i3 && e2.getChild(t3).is("element", "tableRow") && o2.push(t3);
        if (o2.length) {
          i2 = true;
          for (const i3 of o2.reverse())
            t2.remove(e2.getChild(i3)), n2.splice(i3, 1);
        }
        const r2 = n2.filter((t3, i3) => e2.getChild(i3).is("element", "tableRow")), s2 = r2[0];
        if (!r2.every((e3) => e3 === s2)) {
          const n3 = r2.reduce((e3, t3) => t3 > e3 ? t3 : e3, 0);
          for (const [o3, s3] of r2.entries()) {
            const r3 = n3 - s3;
            if (r3) {
              for (let i3 = 0; i3 < r3; i3++)
                jp(t2, t2.createPositionAt(e2.getChild(o3), "end"));
              i2 = true;
            }
          }
        }
        return i2;
      }
      function $b(e2) {
        const t2 = e2.type === "attribute", i2 = e2.attributeKey;
        return t2 && (i2 === "headingRows" || i2 === "colspan" || i2 === "rowspan");
      }
      function Yb(e2) {
        e2.document.registerPostFixer((t2) => function(e3, t3) {
          const i2 = t3.document.differ.getChanges();
          let n2 = false;
          for (const t4 of i2)
            t4.type == "insert" && t4.name == "table" && (n2 = Gb(t4.position.nodeAfter, e3) || n2), t4.type == "insert" && t4.name == "tableRow" && (n2 = Kb(t4.position.nodeAfter, e3) || n2), t4.type == "insert" && t4.name == "tableCell" && (n2 = Qb(t4.position.nodeAfter, e3) || n2), Jb(t4) && (n2 = Qb(t4.position.parent, e3) || n2);
          return n2;
        }(t2, e2));
      }
      function Gb(e2, t2) {
        let i2 = false;
        for (const n2 of e2.getChildren())
          n2.is("element", "tableRow") && (i2 = Kb(n2, t2) || i2);
        return i2;
      }
      function Kb(e2, t2) {
        let i2 = false;
        for (const n2 of e2.getChildren())
          i2 = Qb(n2, t2) || i2;
        return i2;
      }
      function Qb(e2, t2) {
        if (e2.childCount == 0)
          return t2.insertElement("paragraph", e2), true;
        const i2 = Array.from(e2.getChildren()).filter((e3) => e3.is("$text"));
        for (const e3 of i2)
          t2.wrap(t2.createRangeOn(e3), "paragraph");
        return !!i2.length;
      }
      function Jb(e2) {
        return !(!e2.position || !e2.position.parent.is("element", "tableCell")) && (e2.type == "insert" && e2.name == "$text" || e2.type == "remove");
      }
      function Zb(e2, t2) {
        e2.document.registerPostFixer(() => function(e3, t3) {
          const i2 = new Set();
          for (const t4 of e3.getChanges()) {
            const e4 = t4.type == "attribute" ? t4.range.start.parent : t4.position.parent;
            e4.is("element", "tableCell") && i2.add(e4);
          }
          for (const n2 of i2.values())
            for (const i3 of [...n2.getChildren()].filter((e4) => Xb(e4, t3)))
              e3.refreshItem(i3);
          return false;
        }(e2.document.differ, t2));
      }
      function Xb(e2, t2) {
        if (!e2.is("element", "paragraph"))
          return false;
        const i2 = t2.toViewElement(e2);
        return !!i2 && Gp(e2) !== i2.is("element", "span");
      }
      function ew(e2) {
        e2.document.registerPostFixer(() => function(e3) {
          const t2 = e3.document.differ, i2 = new Set();
          for (const e4 of t2.getChanges())
            if (e4.type === "attribute") {
              const t3 = e4.range.start.nodeAfter;
              t3 && t3.is("element", "table") && e4.attributeKey === "headingRows" && i2.add(t3);
            } else if (e4.type === "insert" || e4.type === "remove") {
              if (e4.name === "tableRow") {
                const t3 = e4.position.findAncestor("table"), n2 = t3.getAttribute("headingRows") || 0;
                e4.position.offset < n2 && i2.add(t3);
              } else if (e4.name === "tableCell") {
                const t3 = e4.position.findAncestor("table"), n2 = t3.getAttribute("headingColumns") || 0;
                e4.position.offset < n2 && i2.add(t3);
              }
            }
          if (i2.size) {
            for (const e4 of i2.values())
              t2.refreshItem(e4);
            return true;
          }
          return false;
        }(e2));
      }
      i(100);
      class tw extends Qe {
        static get pluginName() {
          return "TableEditing";
        }
        init() {
          const e2 = this.editor, t2 = e2.model, i2 = t2.schema, n2 = e2.conversion;
          i2.register("table", { allowWhere: "$block", allowAttributes: ["headingRows", "headingColumns"], isObject: true, isBlock: true }), i2.register("tableRow", { allowIn: "table", isLimit: true }), i2.register("tableCell", { allowIn: "tableRow", allowChildren: "$block", allowAttributes: ["colspan", "rowspan"], isLimit: true, isSelectable: true }), n2.for("upcast").add((e3) => {
            e3.on("element:figure", (e4, t3, i3) => {
              if (!i3.consumable.test(t3.viewItem, { name: true, classes: "table" }))
                return;
              const n3 = function(e5) {
                for (const t4 of e5.getChildren())
                  if (t4.is("element", "table"))
                    return t4;
              }(t3.viewItem);
              if (!n3 || !i3.consumable.test(n3, { name: true }))
                return;
              const o2 = Ms(i3.convertItem(n3, t3.modelCursor).modelRange.getItems());
              o2 && (i3.consumable.consume(t3.viewItem, { name: true, classes: "table" }), i3.convertChildren(t3.viewItem, i3.writer.createPositionAt(o2, "end")), i3.updateConversionResult(o2, t3));
            });
          }), n2.for("upcast").add(Fp()), n2.for("editingDowncast").add($p({ asWidget: true })), n2.for("dataDowncast").add($p()), n2.for("upcast").elementToElement({ model: "tableRow", view: "tr" }), n2.for("upcast").add((e3) => {
            e3.on("element:tr", (e4, t3) => {
              t3.viewItem.isEmpty && t3.modelCursor.index == 0 && e4.stop();
            }, { priority: "high" });
          }), n2.for("editingDowncast").add((e3) => e3.on("insert:tableRow", (e4, t3, i3) => {
            const n3 = t3.item;
            if (!i3.consumable.consume(n3, "insert"))
              return;
            const o2 = n3.parent, r2 = function(e5) {
              for (const t4 of e5.getChildren())
                if (t4.name === "table")
                  return t4;
            }(i3.mapper.toViewElement(o2)), s2 = o2.getChildIndex(n3), a2 = new Wp(o2, { row: s2 }), c2 = { headingRows: o2.getAttribute("headingRows") || 0, headingColumns: o2.getAttribute("headingColumns") || 0 }, l2 = new Map();
            for (const e5 of a2) {
              const t4 = l2.get(s2) || Jp(r2, n3, s2, c2, i3);
              l2.set(s2, t4), i3.consumable.consume(e5.cell, "insert"), Qp(e5, c2, i3.writer.createPositionAt(t4, "end"), i3, { asWidget: true });
            }
          })), n2.for("editingDowncast").add((e3) => e3.on("remove:tableRow", (e4, t3, i3) => {
            e4.stop();
            const n3 = i3.writer, o2 = i3.mapper, r2 = o2.toViewPosition(t3.position).getLastMatchingPosition((e5) => !e5.item.is("element", "tr")).nodeAfter, s2 = r2.parent.parent, a2 = n3.createRangeOn(r2), c2 = n3.remove(a2);
            for (const e5 of n3.createRangeIn(c2).getItems())
              o2.unbindViewElement(e5);
            eb("thead", s2, i3), eb("tbody", s2, i3);
          }, { priority: "higher" })), n2.for("upcast").elementToElement({ model: "tableCell", view: "td" }), n2.for("upcast").elementToElement({ model: "tableCell", view: "th" }), n2.for("upcast").add(Hp("td")), n2.for("upcast").add(Hp("th")), n2.for("editingDowncast").add((e3) => e3.on("insert:tableCell", (e4, t3, i3) => {
            const n3 = t3.item;
            if (!i3.consumable.consume(n3, "insert"))
              return;
            const o2 = n3.parent, r2 = o2.parent, s2 = r2.getChildIndex(o2), a2 = new Wp(r2, { row: s2 }), c2 = { headingRows: r2.getAttribute("headingRows") || 0, headingColumns: r2.getAttribute("headingColumns") || 0 };
            for (const e5 of a2)
              if (e5.cell === n3) {
                const t4 = i3.mapper.toViewElement(o2);
                return void Qp(e5, c2, i3.writer.createPositionAt(t4, o2.getChildIndex(n3)), i3, { asWidget: true });
              }
          })), n2.for("editingDowncast").elementToElement({ model: "paragraph", view: Yp, converterPriority: "high" }), n2.for("downcast").attributeToAttribute({ model: "colspan", view: "colspan" }), n2.for("upcast").attributeToAttribute({ model: { key: "colspan", value: iw("colspan") }, view: "colspan" }), n2.for("downcast").attributeToAttribute({ model: "rowspan", view: "rowspan" }), n2.for("upcast").attributeToAttribute({ model: { key: "rowspan", value: iw("rowspan") }, view: "rowspan" }), n2.for("editingDowncast").add((e3) => e3.on("attribute:headingColumns:table", (e4, t3, i3) => {
            const n3 = t3.item;
            if (!i3.consumable.consume(t3.item, e4.name))
              return;
            const o2 = { headingRows: n3.getAttribute("headingRows") || 0, headingColumns: n3.getAttribute("headingColumns") || 0 }, r2 = t3.attributeOldValue, s2 = t3.attributeNewValue, a2 = (r2 > s2 ? r2 : s2) - 1;
            for (const e5 of new Wp(n3, { endColumn: a2 }))
              Kp(e5, o2, i3);
          })), e2.data.mapper.on("modelToViewPosition", (e3, t3) => {
            const i3 = t3.modelPosition.parent, n3 = t3.modelPosition.nodeBefore;
            if (!i3.is("element", "tableCell"))
              return;
            if (!n3 || !n3.is("element", "paragraph"))
              return;
            const o2 = t3.mapper.toViewElement(n3), r2 = t3.mapper.toViewElement(i3);
            o2 === r2 && (t3.viewPosition = t3.mapper.findPositionIn(r2, n3.maxOffset));
          }), e2.config.define("table.defaultHeadings.rows", 0), e2.config.define("table.defaultHeadings.columns", 0), e2.commands.add("insertTable", new ib(e2)), e2.commands.add("insertTableRowAbove", new gb(e2, { order: "above" })), e2.commands.add("insertTableRowBelow", new gb(e2, { order: "below" })), e2.commands.add("insertTableColumnLeft", new mb(e2, { order: "left" })), e2.commands.add("insertTableColumnRight", new mb(e2, { order: "right" })), e2.commands.add("removeTableRow", new Sb(e2)), e2.commands.add("removeTableColumn", new Pb(e2)), e2.commands.add("splitTableCellVertically", new fb(e2, { direction: "vertically" })), e2.commands.add("splitTableCellHorizontally", new fb(e2, { direction: "horizontally" })), e2.commands.add("mergeTableCells", new Lb(e2)), e2.commands.add("mergeTableCellRight", new Eb(e2, { direction: "right" })), e2.commands.add("mergeTableCellLeft", new Eb(e2, { direction: "left" })), e2.commands.add("mergeTableCellDown", new Eb(e2, { direction: "down" })), e2.commands.add("mergeTableCellUp", new Eb(e2, { direction: "up" })), e2.commands.add("setTableColumnHeader", new Nb(e2)), e2.commands.add("setTableRowHeader", new Mb(e2)), e2.commands.add("selectTableRow", new Fb(e2)), e2.commands.add("selectTableColumn", new Hb(e2)), ew(t2), Ub(t2), Zb(t2, e2.editing.mapper), Yb(t2);
        }
        static get requires() {
          return [Rb];
        }
      }
      function iw(e2) {
        return (t2) => {
          const i2 = parseInt(t2.getAttribute(e2));
          return Number.isNaN(i2) || i2 <= 0 ? null : i2;
        };
      }
      i(102);
      class nw extends Nl {
        constructor(e2) {
          super(e2);
          const t2 = this.bindTemplate;
          this.items = this._createGridCollection(), this.set("rows", 0), this.set("columns", 0), this.bind("label").to(this, "columns", this, "rows", (e3, t3) => `${t3} \xD7 ${e3}`), this.setTemplate({ tag: "div", attributes: { class: ["ck"] }, children: [{ tag: "div", attributes: { class: ["ck-insert-table-dropdown__grid"] }, on: { "mouseover@.ck-insert-table-dropdown-grid-box": t2.to("boxover") }, children: this.items }, { tag: "div", attributes: { class: ["ck-insert-table-dropdown__label"] }, children: [{ text: t2.to("label") }] }], on: { mousedown: t2.to((e3) => {
            e3.preventDefault();
          }), click: t2.to(() => {
            this.fire("execute");
          }) } }), this.on("boxover", (e3, t3) => {
            const { row: i2, column: n2 } = t3.target.dataset;
            this.set({ rows: parseInt(i2), columns: parseInt(n2) });
          }), this.on("change:columns", () => {
            this._highlightGridBoxes();
          }), this.on("change:rows", () => {
            this._highlightGridBoxes();
          });
        }
        focus() {
        }
        focusLast() {
        }
        _highlightGridBoxes() {
          const e2 = this.rows, t2 = this.columns;
          this.items.map((i2, n2) => {
            const o2 = Math.floor(n2 / 10) < e2 && n2 % 10 < t2;
            i2.set("isOn", o2);
          });
        }
        _createGridCollection() {
          const e2 = [];
          for (let t2 = 0; t2 < 100; t2++) {
            const i2 = Math.floor(t2 / 10), n2 = t2 % 10;
            e2.push(new ow(this.locale, i2 + 1, n2 + 1));
          }
          return this.createCollection(e2);
        }
      }
      class ow extends Nl {
        constructor(e2, t2, i2) {
          super(e2);
          const n2 = this.bindTemplate;
          this.set("isOn", false), this.setTemplate({ tag: "div", attributes: { class: ["ck-insert-table-dropdown-grid-box", n2.if("isOn", "ck-on")], "data-row": t2, "data-column": i2 } });
        }
      }
      class rw extends Qe {
        static get pluginName() {
          return "TableUI";
        }
        init() {
          const e2 = this.editor, t2 = this.editor.t, i2 = e2.locale.contentLanguageDirection === "ltr";
          e2.ui.componentFactory.add("insertTable", (i3) => {
            const n2 = e2.commands.get("insertTable"), o2 = xd(i3);
            let r2;
            return o2.bind("isEnabled").to(n2), o2.buttonView.set({ icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 6v3h4V6H3zm0 4v3h4v-3H3zm0 4v3h4v-3H3zm5 3h4v-3H8v3zm5 0h4v-3h-4v3zm4-4v-3h-4v3h4zm0-4V6h-4v3h4zm1.5 8a1.5 1.5 0 0 1-1.5 1.5H3A1.5 1.5 0 0 1 1.5 17V4c.222-.863 1.068-1.5 2-1.5h13c.932 0 1.778.637 2 1.5v13zM12 13v-3H8v3h4zm0-4V6H8v3h4z"/></svg>', label: t2("Insert table"), tooltip: true }), o2.on("change:isOpen", () => {
              r2 || (r2 = new nw(i3), o2.panelView.children.add(r2), r2.delegate("execute").to(o2), o2.buttonView.on("open", () => {
                r2.rows = 0, r2.columns = 0;
              }), o2.on("execute", () => {
                e2.execute("insertTable", { rows: r2.rows, columns: r2.columns }), e2.editing.view.focus();
              }));
            }), o2;
          }), e2.ui.componentFactory.add("tableColumn", (e3) => {
            const n2 = [{ type: "switchbutton", model: { commandName: "setTableColumnHeader", label: t2("Header column"), bindIsOn: true } }, { type: "separator" }, { type: "button", model: { commandName: i2 ? "insertTableColumnLeft" : "insertTableColumnRight", label: t2("Insert column left") } }, { type: "button", model: { commandName: i2 ? "insertTableColumnRight" : "insertTableColumnLeft", label: t2("Insert column right") } }, { type: "button", model: { commandName: "removeTableColumn", label: t2("Delete column") } }, { type: "button", model: { commandName: "selectTableColumn", label: t2("Select column") } }];
            return this._prepareDropdown(t2("Column"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M18 7v1H2V7h16zm0 5v1H2v-1h16z" opacity=".6"/><path d="M14 1v18a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V1a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1zm-2 1H8v4h4V2zm0 6H8v4h4V8zm0 6H8v4h4v-4z"/></svg>', n2, e3);
          }), e2.ui.componentFactory.add("tableRow", (e3) => {
            const i3 = [{ type: "switchbutton", model: { commandName: "setTableRowHeader", label: t2("Header row"), bindIsOn: true } }, { type: "separator" }, { type: "button", model: { commandName: "insertTableRowAbove", label: t2("Insert row above") } }, { type: "button", model: { commandName: "insertTableRowBelow", label: t2("Insert row below") } }, { type: "button", model: { commandName: "removeTableRow", label: t2("Delete row") } }, { type: "button", model: { commandName: "selectTableRow", label: t2("Select row") } }];
            return this._prepareDropdown(t2("Row"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v16h-1V2z" opacity=".6"/><path d="M1 6h18a1 1 0 0 1 1 1v6a1 1 0 0 1-1 1H1a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1zm1 2v4h4V8H2zm6 0v4h4V8H8zm6 0v4h4V8h-4z"/></svg>', i3, e3);
          }), e2.ui.componentFactory.add("mergeTableCells", (e3) => {
            const n2 = [{ type: "button", model: { commandName: "mergeTableCellUp", label: t2("Merge cell up") } }, { type: "button", model: { commandName: i2 ? "mergeTableCellRight" : "mergeTableCellLeft", label: t2("Merge cell right") } }, { type: "button", model: { commandName: "mergeTableCellDown", label: t2("Merge cell down") } }, { type: "button", model: { commandName: i2 ? "mergeTableCellLeft" : "mergeTableCellRight", label: t2("Merge cell left") } }, { type: "separator" }, { type: "button", model: { commandName: "splitTableCellVertically", label: t2("Split cell vertically") } }, { type: "button", model: { commandName: "splitTableCellHorizontally", label: t2("Split cell horizontally") } }];
            return this._prepareMergeSplitButtonDropdown(t2("Merge cells"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v7h-1V2zm6 5v1H2V7h16zM8 12v1H2v-1h6z" opacity=".6"/><path d="M7 7h12a1 1 0 0 1 1 1v11a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V8a1 1 0 0 1 1-1zm1 2v9h10V9H8z"/></svg>', n2, e3);
          });
        }
        _prepareDropdown(e2, t2, i2, n2) {
          const o2 = this.editor, r2 = xd(n2), s2 = this._fillDropdownWithListOptions(r2, i2);
          return r2.buttonView.set({ label: e2, icon: t2, tooltip: true }), r2.bind("isEnabled").toMany(s2, "isEnabled", (...e3) => e3.some((e4) => e4)), this.listenTo(r2, "execute", (e3) => {
            o2.execute(e3.source.commandName), o2.editing.view.focus();
          }), r2;
        }
        _prepareMergeSplitButtonDropdown(e2, t2, i2, n2) {
          const o2 = this.editor, r2 = xd(n2, ad), s2 = o2.commands.get("mergeTableCells"), a2 = this._fillDropdownWithListOptions(r2, i2);
          return r2.buttonView.set({ label: e2, icon: t2, tooltip: true, isEnabled: true }), r2.bind("isEnabled").toMany([s2, ...a2], "isEnabled", (...e3) => e3.some((e4) => e4)), this.listenTo(r2.buttonView, "execute", () => {
            o2.execute("mergeTableCells"), o2.editing.view.focus();
          }), this.listenTo(r2, "execute", (e3) => {
            o2.execute(e3.source.commandName), o2.editing.view.focus();
          }), r2;
        }
        _fillDropdownWithListOptions(e2, t2) {
          const i2 = this.editor, n2 = [], o2 = new Zi();
          for (const e3 of t2)
            sw(e3, i2, n2, o2);
          return Cd(e2, o2, i2.ui.componentFactory), n2;
        }
      }
      function sw(e2, t2, i2, n2) {
        const o2 = e2.model = new zd(e2.model), { commandName: r2, bindIsOn: s2 } = e2.model;
        if (e2.type === "button" || e2.type === "switchbutton") {
          const e3 = t2.commands.get(r2);
          i2.push(e3), o2.set({ commandName: r2 }), o2.bind("isEnabled").to(e3), s2 && o2.bind("isOn").to(e3, "value");
        }
        o2.set({ withText: true }), n2.add(e2);
      }
      i(104);
      class aw extends Qe {
        static get pluginName() {
          return "TableSelection";
        }
        static get requires() {
          return [Rb];
        }
        init() {
          const e2 = this.editor.model;
          this.listenTo(e2, "deleteContent", (e3, t2) => this._handleDeleteContent(e3, t2), { priority: "high" }), this._defineSelectionConverter(), this._enablePluginDisabling();
        }
        getSelectedTableCells() {
          const e2 = nb(this.editor.model.document.selection);
          return e2.length == 0 ? null : e2;
        }
        getSelectionAsFragment() {
          const e2 = this.getSelectedTableCells();
          return e2 ? this.editor.model.change((t2) => {
            const i2 = t2.createDocumentFragment(), n2 = this.editor.plugins.get("TableUtils"), { first: o2, last: r2 } = ab(e2), { first: s2, last: a2 } = sb(e2), c2 = e2[0].findAncestor("table");
            let l2 = a2, d2 = r2;
            if (cb(e2, n2)) {
              const e3 = { firstColumn: o2, lastColumn: r2, firstRow: s2, lastRow: a2 };
              l2 = Cb(c2, e3), d2 = Tb(c2, e3);
            }
            const h2 = pb(c2, { startRow: s2, startColumn: o2, endRow: l2, endColumn: d2 }, t2);
            return t2.insert(h2, i2, 0), i2;
          }) : null;
        }
        setCellSelection(e2, t2) {
          const i2 = this._getCellsToSelect(e2, t2);
          this.editor.model.change((e3) => {
            e3.setSelection(i2.cells.map((t3) => e3.createRangeOn(t3)), { backward: i2.backward });
          });
        }
        getFocusCell() {
          const e2 = [...this.editor.model.document.selection.getRanges()].pop().getContainedElement();
          return e2 && e2.is("element", "tableCell") ? e2 : null;
        }
        getAnchorCell() {
          const e2 = Ms(this.editor.model.document.selection.getRanges()).getContainedElement();
          return e2 && e2.is("element", "tableCell") ? e2 : null;
        }
        _defineSelectionConverter() {
          const e2 = this.editor, t2 = new Set();
          e2.conversion.for("editingDowncast").add((e3) => e3.on("selection", (e4, i2, n2) => {
            const o2 = n2.writer;
            !function(e5) {
              for (const i3 of t2)
                e5.removeClass("ck-editor__editable_selected", i3);
              t2.clear();
            }(o2);
            const r2 = this.getSelectedTableCells();
            if (!r2)
              return;
            for (const e5 of r2) {
              const i3 = n2.mapper.toViewElement(e5);
              o2.addClass("ck-editor__editable_selected", i3), t2.add(i3);
            }
            const s2 = n2.mapper.toViewElement(r2[r2.length - 1]);
            o2.setSelection(s2, 0);
          }, { priority: "lowest" }));
        }
        _enablePluginDisabling() {
          const e2 = this.editor;
          this.on("change:isEnabled", () => {
            if (!this.isEnabled) {
              const t2 = this.getSelectedTableCells();
              if (!t2)
                return;
              e2.model.change((i2) => {
                const n2 = i2.createPositionAt(t2[0], 0), o2 = e2.model.schema.getNearestSelectionRange(n2);
                i2.setSelection(o2);
              });
            }
          });
        }
        _handleDeleteContent(e2, t2) {
          const [i2, n2] = t2, o2 = this.editor.model, r2 = !n2 || n2.direction == "backward", s2 = nb(i2);
          s2.length && (e2.stop(), o2.change((e3) => {
            const t3 = s2[r2 ? s2.length - 1 : 0];
            o2.change((e4) => {
              for (const t4 of s2)
                o2.deleteContent(e4.createSelection(t4, "in"));
            });
            const n3 = o2.schema.getNearestSelectionRange(e3.createPositionAt(t3, 0));
            i2.is("documentSelection") ? e3.setSelection(n3) : i2.setTo(n3);
          }));
        }
        _getCellsToSelect(e2, t2) {
          const i2 = this.editor.plugins.get("TableUtils"), n2 = i2.getCellLocation(e2), o2 = i2.getCellLocation(t2), r2 = Math.min(n2.row, o2.row), s2 = Math.max(n2.row, o2.row), a2 = Math.min(n2.column, o2.column), c2 = Math.max(n2.column, o2.column), l2 = new Array(s2 - r2 + 1).fill(null).map(() => []), d2 = { startRow: r2, endRow: s2, startColumn: a2, endColumn: c2 };
          for (const { row: t3, cell: i3 } of new Wp(e2.findAncestor("table"), d2))
            l2[t3 - r2].push(i3);
          const h2 = o2.row < n2.row, u2 = o2.column < n2.column;
          return h2 && l2.reverse(), u2 && l2.forEach((e3) => e3.reverse()), { cells: l2.flat(), backward: h2 || u2 };
        }
      }
      class cw extends Qe {
        static get pluginName() {
          return "TableClipboard";
        }
        static get requires() {
          return [aw, Rb];
        }
        init() {
          const e2 = this.editor, t2 = e2.editing.view.document;
          this.listenTo(t2, "copy", (e3, t3) => this._onCopyCut(e3, t3)), this.listenTo(t2, "cut", (e3, t3) => this._onCopyCut(e3, t3)), this.listenTo(e2.model, "insertContent", (e3, t3) => this._onInsertContent(e3, ...t3), { priority: "high" }), this.decorate("_replaceTableSlotCell");
        }
        _onCopyCut(e2, t2) {
          const i2 = this.editor.plugins.get(aw);
          if (!i2.getSelectedTableCells())
            return;
          if (e2.name == "cut" && this.editor.isReadOnly)
            return;
          t2.preventDefault(), e2.stop();
          const n2 = this.editor.data, o2 = this.editor.editing.view.document, r2 = n2.toView(i2.getSelectionAsFragment());
          o2.fire("clipboardOutput", { dataTransfer: t2.dataTransfer, content: r2, method: e2.name });
        }
        _onInsertContent(e2, t2, i2) {
          if (i2 && !i2.is("documentSelection"))
            return;
          const n2 = this.editor.model, o2 = this.editor.plugins.get(Rb);
          let r2 = function(e3, t3) {
            if (!e3.is("documentFragment") && !e3.is("element"))
              return null;
            if (e3.is("element", "table"))
              return e3;
            if (e3.childCount == 1 && e3.getChild(0).is("element", "table"))
              return e3.getChild(0);
            const i3 = t3.createRangeIn(e3);
            for (const e4 of i3.getItems())
              if (e4.is("element", "table")) {
                const n3 = t3.createRange(i3.start, t3.createPositionBefore(e4));
                if (t3.hasContent(n3, { ignoreWhitespaces: true }))
                  return null;
                const o3 = t3.createRange(t3.createPositionAfter(e4), i3.end);
                return t3.hasContent(o3, { ignoreWhitespaces: true }) ? null : e4;
              }
            return null;
          }(t2, n2);
          if (!r2)
            return;
          const s2 = rb(n2.document.selection);
          s2.length ? (e2.stop(), n2.change((e3) => {
            const t3 = { width: o2.getColumns(r2), height: o2.getRows(r2) }, i3 = function(e4, t4, i4, n4) {
              const o3 = e4[0].findAncestor("table"), r3 = ab(e4), s3 = sb(e4), a3 = { firstColumn: r3.first, lastColumn: r3.last, firstRow: s3.first, lastRow: s3.last }, c3 = e4.length === 1;
              c3 && (a3.lastRow += t4.height - 1, a3.lastColumn += t4.width - 1, function(e5, t5, i5, n5) {
                const o4 = n5.getColumns(e5), r4 = n5.getRows(e5);
                i5 > o4 && n5.insertColumns(e5, { at: o4, columns: i5 - o4 });
                t5 > r4 && n5.insertRows(e5, { at: r4, rows: t5 - r4 });
              }(o3, a3.lastRow + 1, a3.lastColumn + 1, n4));
              c3 || !cb(e4, n4) ? function(e5, t5, i5) {
                const { firstRow: n5, lastRow: o4, firstColumn: r4, lastColumn: s4 } = t5, a4 = { first: n5, last: o4 }, c4 = { first: r4, last: s4 };
                dw(e5, r4, a4, i5), dw(e5, s4 + 1, a4, i5), lw(e5, n5, c4, i5), lw(e5, o4 + 1, c4, i5, n5);
              }(o3, a3, i4) : (a3.lastRow = Cb(o3, a3), a3.lastColumn = Tb(o3, a3));
              return a3;
            }(s2, t3, e3, o2), n3 = i3.lastRow - i3.firstRow + 1, a2 = i3.lastColumn - i3.firstColumn + 1, c2 = { startRow: 0, startColumn: 0, endRow: Math.min(n3, t3.height) - 1, endColumn: Math.min(a2, t3.width) - 1 };
            r2 = pb(r2, c2, e3);
            const l2 = s2[0].findAncestor("table"), d2 = this._replaceSelectedCellsWithPasted(r2, t3, l2, i3, e3);
            if (this.editor.plugins.get("TableSelection").isEnabled) {
              const t4 = lb(d2.map((t5) => e3.createRangeOn(t5)));
              e3.setSelection(t4);
            } else
              e3.setSelection(d2[0], 0);
          })) : Ab(r2, o2);
        }
        _replaceSelectedCellsWithPasted(e2, t2, i2, n2, o2) {
          const { width: r2, height: s2 } = t2, a2 = function(e3, t3, i3) {
            const n3 = new Array(i3).fill(null).map(() => new Array(t3).fill(null));
            for (const { column: t4, row: i4, cell: o3 } of new Wp(e3))
              n3[i4][t4] = o3;
            return n3;
          }(e2, r2, s2), c2 = [...new Wp(i2, { startRow: n2.firstRow, endRow: n2.lastRow, startColumn: n2.firstColumn, endColumn: n2.lastColumn, includeAllSlots: true })], l2 = [];
          let d2;
          for (const e3 of c2) {
            const { row: t3, column: i3 } = e3;
            i3 === n2.firstColumn && (d2 = e3.getPositionBefore());
            const c3 = t3 - n2.firstRow, h3 = i3 - n2.firstColumn, u3 = a2[c3 % s2][h3 % r2], g3 = u3 ? o2.cloneElement(u3) : null, m3 = this._replaceTableSlotCell(e3, g3, d2, o2);
            m3 && (vb(m3, t3, i3, n2.lastRow, n2.lastColumn, o2), l2.push(m3), d2 = o2.createPositionAfter(m3));
          }
          const h2 = parseInt(i2.getAttribute("headingRows") || 0), u2 = parseInt(i2.getAttribute("headingColumns") || 0), g2 = n2.firstRow < h2 && h2 <= n2.lastRow, m2 = n2.firstColumn < u2 && u2 <= n2.lastColumn;
          if (g2) {
            const e3 = lw(i2, h2, { first: n2.firstColumn, last: n2.lastColumn }, o2, n2.firstRow);
            l2.push(...e3);
          }
          if (m2) {
            const e3 = dw(i2, u2, { first: n2.firstRow, last: n2.lastRow }, o2);
            l2.push(...e3);
          }
          return l2;
        }
        _replaceTableSlotCell(e2, t2, i2, n2) {
          const { cell: o2, isAnchor: r2 } = e2;
          return r2 && n2.remove(o2), t2 ? (n2.insert(t2, i2), t2) : null;
        }
      }
      function lw(e2, t2, i2, n2, o2 = 0) {
        if (t2 < 1)
          return;
        return bb(e2, t2, o2).filter(({ column: e3, cellWidth: t3 }) => hw(e3, t3, i2)).map(({ cell: e3 }) => wb(e3, t2, n2));
      }
      function dw(e2, t2, i2, n2) {
        if (t2 < 1)
          return;
        return kb(e2, t2).filter(({ row: e3, cellHeight: t3 }) => hw(e3, t3, i2)).map(({ cell: e3, column: i3 }) => _b(e3, i3, t2, n2));
      }
      function hw(e2, t2, i2) {
        const n2 = e2 + t2 - 1, { first: o2, last: r2 } = i2;
        return e2 >= o2 && e2 <= r2 || e2 < o2 && n2 >= o2;
      }
      class uw extends Qe {
        static get pluginName() {
          return "TableKeyboard";
        }
        static get requires() {
          return [aw];
        }
        init() {
          const e2 = this.editor.editing.view.document;
          this.editor.keystrokes.set("Tab", (...e3) => this._handleTabOnSelectedTable(...e3), { priority: "low" }), this.editor.keystrokes.set("Tab", this._getTabHandler(true), { priority: "low" }), this.editor.keystrokes.set("Shift+Tab", this._getTabHandler(false), { priority: "low" }), this.listenTo(e2, "arrowKey", (...e3) => this._onArrowKey(...e3), { context: "table" });
        }
        _handleTabOnSelectedTable(e2, t2) {
          const i2 = this.editor, n2 = i2.model.document.selection.getSelectedElement();
          n2 && n2.is("element", "table") && (t2(), i2.model.change((e3) => {
            e3.setSelection(e3.createRangeIn(n2.getChild(0).getChild(0)));
          }));
        }
        _getTabHandler(e2) {
          const t2 = this.editor;
          return (i2, n2) => {
            let o2 = ob(t2.model.document.selection)[0];
            if (o2 || (o2 = this.editor.plugins.get("TableSelection").getFocusCell()), !o2)
              return;
            n2();
            const r2 = o2.parent, s2 = r2.parent, a2 = s2.getChildIndex(r2), c2 = r2.getChildIndex(o2), l2 = c2 === 0;
            if (!e2 && l2 && a2 === 0)
              return void t2.model.change((e3) => {
                e3.setSelection(e3.createRangeOn(s2));
              });
            const d2 = this.editor.plugins.get("TableUtils"), h2 = c2 === r2.childCount - 1, u2 = a2 === d2.getRows(s2) - 1;
            if (e2 && u2 && h2 && (t2.execute("insertTableRowBelow"), a2 === d2.getRows(s2) - 1))
              return void t2.model.change((e3) => {
                e3.setSelection(e3.createRangeOn(s2));
              });
            let g2;
            if (e2 && h2) {
              const e3 = s2.getChild(a2 + 1);
              g2 = e3.getChild(0);
            } else if (!e2 && l2) {
              const e3 = s2.getChild(a2 - 1);
              g2 = e3.getChild(e3.childCount - 1);
            } else
              g2 = r2.getChild(c2 + (e2 ? 1 : -1));
            t2.model.change((e3) => {
              e3.setSelection(e3.createRangeIn(g2));
            });
          };
        }
        _onArrowKey(e2, t2) {
          const i2 = this.editor, n2 = Lo(t2.keyCode, i2.locale.contentLanguageDirection);
          this._handleArrowKeys(n2, t2.shiftKey) && (t2.preventDefault(), t2.stopPropagation(), e2.stop());
        }
        _handleArrowKeys(e2, t2) {
          const i2 = this.editor.model, n2 = i2.document.selection, o2 = ["right", "down"].includes(e2), r2 = nb(n2);
          if (r2.length) {
            let i3;
            return i3 = t2 ? this.editor.plugins.get("TableSelection").getFocusCell() : o2 ? r2[r2.length - 1] : r2[0], this._navigateFromCellInDirection(i3, e2, t2), true;
          }
          const s2 = n2.focus.findAncestor("tableCell");
          if (!s2)
            return false;
          if (!n2.isCollapsed)
            if (t2) {
              if (n2.isBackward == o2 && !n2.containsEntireContent(s2))
                return false;
            } else {
              const e3 = n2.getSelectedElement();
              if (!e3 || !i2.schema.isObject(e3))
                return false;
            }
          return !!this._isSelectionAtCellEdge(n2, s2, o2) && (this._navigateFromCellInDirection(s2, e2, t2), true);
        }
        _isSelectionAtCellEdge(e2, t2, i2) {
          const n2 = this.editor.model, o2 = this.editor.model.schema, r2 = i2 ? e2.getLastPosition() : e2.getFirstPosition();
          if (!o2.getLimitElement(r2).is("element", "tableCell")) {
            return n2.createPositionAt(t2, i2 ? "end" : 0).isTouching(r2);
          }
          const s2 = n2.createSelection(r2);
          return n2.modifySelection(s2, { direction: i2 ? "forward" : "backward" }), r2.isEqual(s2.focus);
        }
        _navigateFromCellInDirection(e2, t2, i2 = false) {
          const n2 = this.editor.model, o2 = e2.findAncestor("table"), r2 = [...new Wp(o2, { includeAllSlots: true })], { row: s2, column: a2 } = r2[r2.length - 1], c2 = r2.find(({ cell: t3 }) => t3 == e2);
          let { row: l2, column: d2 } = c2;
          switch (t2) {
            case "left":
              d2--;
              break;
            case "up":
              l2--;
              break;
            case "right":
              d2 += c2.cellWidth;
              break;
            case "down":
              l2 += c2.cellHeight;
          }
          if (l2 < 0 || l2 > s2 || d2 < 0 && l2 <= 0 || d2 > a2 && l2 >= s2)
            return void n2.change((e3) => {
              e3.setSelection(e3.createRangeOn(o2));
            });
          d2 < 0 ? (d2 = i2 ? 0 : a2, l2--) : d2 > a2 && (d2 = i2 ? a2 : 0, l2++);
          const h2 = r2.find((e3) => e3.row == l2 && e3.column == d2).cell, u2 = ["right", "down"].includes(t2), g2 = this.editor.plugins.get("TableSelection");
          if (i2 && g2.isEnabled) {
            const t3 = g2.getAnchorCell() || e2;
            g2.setCellSelection(t3, h2);
          } else {
            const e3 = n2.createPositionAt(h2, u2 ? 0 : "end");
            n2.change((t3) => {
              t3.setSelection(e3);
            });
          }
        }
      }
      class gw extends es {
        constructor(e2) {
          super(e2), this.domEventType = ["mousemove", "mouseleave"];
        }
        onDomEvent(e2) {
          this.fire(e2.type, e2);
        }
      }
      class mw extends Qe {
        static get pluginName() {
          return "TableMouse";
        }
        static get requires() {
          return [aw];
        }
        init() {
          this.editor.editing.view.addObserver(gw), this._enableShiftClickSelection(), this._enableMouseDragSelection();
        }
        _enableShiftClickSelection() {
          const e2 = this.editor;
          let t2 = false;
          const i2 = e2.plugins.get(aw);
          this.listenTo(e2.editing.view.document, "mousedown", (n2, o2) => {
            if (!this.isEnabled || !i2.isEnabled)
              return;
            if (!o2.domEvent.shiftKey)
              return;
            const r2 = i2.getAnchorCell() || ob(e2.model.document.selection)[0];
            if (!r2)
              return;
            const s2 = this._getModelTableCellFromDomEvent(o2);
            s2 && fw(r2, s2) && (t2 = true, i2.setCellSelection(r2, s2), o2.preventDefault());
          }), this.listenTo(e2.editing.view.document, "mouseup", () => {
            t2 = false;
          }), this.listenTo(e2.editing.view.document, "selectionChange", (e3) => {
            t2 && e3.stop();
          }, { priority: "highest" });
        }
        _enableMouseDragSelection() {
          const e2 = this.editor;
          let t2, i2, n2 = false, o2 = false;
          const r2 = e2.plugins.get(aw);
          this.listenTo(e2.editing.view.document, "mousedown", (e3, i3) => {
            this.isEnabled && r2.isEnabled && (i3.domEvent.shiftKey || i3.domEvent.ctrlKey || i3.domEvent.altKey || (t2 = this._getModelTableCellFromDomEvent(i3)));
          }), this.listenTo(e2.editing.view.document, "mousemove", (e3, s2) => {
            if (!s2.domEvent.buttons)
              return;
            if (!t2)
              return;
            const a2 = this._getModelTableCellFromDomEvent(s2);
            a2 && fw(t2, a2) && (i2 = a2, n2 || i2 == t2 || (n2 = true)), n2 && (o2 = true, r2.setCellSelection(t2, i2), s2.preventDefault());
          }), this.listenTo(e2.editing.view.document, "mouseup", () => {
            n2 = false, o2 = false, t2 = null, i2 = null;
          }), this.listenTo(e2.editing.view.document, "selectionChange", (e3) => {
            o2 && e3.stop();
          }, { priority: "highest" });
        }
        _getModelTableCellFromDomEvent(e2) {
          const t2 = e2.target, i2 = this.editor.editing.view.createPositionAt(t2, 0);
          return this.editor.editing.mapper.toModelPosition(i2).parent.findAncestor("tableCell", { includeSelf: true });
        }
      }
      function fw(e2, t2) {
        return e2.parent.parent == t2.parent.parent;
      }
      i(106);
      function pw(e2) {
        const t2 = e2.getSelectedElement();
        return t2 && ww(t2) ? t2 : null;
      }
      function bw(e2) {
        let t2 = e2.getFirstPosition().parent;
        for (; t2; ) {
          if (t2.is("element") && ww(t2))
            return t2;
          t2 = t2.parent;
        }
        return null;
      }
      function ww(e2) {
        return !!e2.getCustomProperty("table") && Oh(e2);
      }
      const kw = { autoRefresh: true };
      class _w {
        constructor(e2, t2 = kw) {
          if (!e2)
            throw new c.a("token-missing-token-url", this);
          t2.initValue && this._validateTokenValue(t2.initValue), this.set("value", t2.initValue), this._refresh = typeof e2 == "function" ? e2 : () => {
            return t3 = e2, new Promise((e3, i2) => {
              const n2 = new XMLHttpRequest();
              n2.open("GET", t3), n2.addEventListener("load", () => {
                const t4 = n2.status, o2 = n2.response;
                return t4 < 200 || t4 > 299 ? i2(new c.a("token-cannot-download-new-token", null)) : e3(o2);
              }), n2.addEventListener("error", () => i2(new Error("Network Error"))), n2.addEventListener("abort", () => i2(new Error("Abort"))), n2.send();
            });
            var t3;
          }, this._options = Object.assign({}, kw, t2);
        }
        init() {
          return new Promise((e2, t2) => {
            this.value ? (this._options.autoRefresh && this._registerRefreshTokenTimeout(), e2(this)) : this.refreshToken().then(e2).catch(t2);
          });
        }
        refreshToken() {
          return this._refresh().then((e2) => {
            this._validateTokenValue(e2), this.set("value", e2), this._options.autoRefresh && this._registerRefreshTokenTimeout();
          }).then(() => this);
        }
        destroy() {
          clearTimeout(this._tokenRefreshTimeout);
        }
        _validateTokenValue(e2) {
          const t2 = typeof e2 == "string", i2 = !/^".*"$/.test(e2), n2 = t2 && e2.split(".").length === 3;
          if (!i2 || !n2)
            throw new c.a("token-not-in-jwt-format", this);
        }
        _registerRefreshTokenTimeout() {
          const e2 = this._getTokenRefreshTimeoutTime();
          clearTimeout(this._tokenRefreshTimeout), this._tokenRefreshTimeout = setTimeout(() => {
            this.refreshToken();
          }, e2);
        }
        _getTokenRefreshTimeoutTime() {
          try {
            const [, e2] = this.value.split("."), { exp: t2 } = JSON.parse(atob(e2));
            if (!t2)
              return 36e5;
            return Math.floor((1e3 * t2 - Date.now()) / 2);
          } catch (e2) {
            return 36e5;
          }
        }
        static create(e2, t2 = kw) {
          return new _w(e2, t2).init();
        }
      }
      Ke(_w, Ue);
      var vw = _w;
      const yw = /^data:(\S*?);base64,/;
      class xw {
        constructor(e2, t2, i2) {
          if (!e2)
            throw new c.a("fileuploader-missing-file", null);
          if (!t2)
            throw new c.a("fileuploader-missing-token", null);
          if (!i2)
            throw new c.a("fileuploader-missing-api-address", null);
          this.file = function(e3) {
            if (typeof e3 != "string")
              return false;
            const t3 = e3.match(yw);
            return !(!t3 || !t3.length);
          }(e2) ? function(e3, t3 = 512) {
            try {
              const i3 = e3.match(yw)[1], n2 = atob(e3.replace(yw, "")), o2 = [];
              for (let e4 = 0; e4 < n2.length; e4 += t3) {
                const i4 = n2.slice(e4, e4 + t3), r2 = new Array(i4.length);
                for (let e5 = 0; e5 < i4.length; e5++)
                  r2[e5] = i4.charCodeAt(e5);
                o2.push(new Uint8Array(r2));
              }
              return new Blob(o2, { type: i3 });
            } catch (e4) {
              throw new c.a("fileuploader-decoding-image-data-error", null);
            }
          }(e2) : e2, this._token = t2, this._apiAddress = i2;
        }
        onProgress(e2) {
          return this.on("progress", (t2, i2) => e2(i2)), this;
        }
        onError(e2) {
          return this.once("error", (t2, i2) => e2(i2)), this;
        }
        abort() {
          this.xhr.abort();
        }
        send() {
          return this._prepareRequest(), this._attachXHRListeners(), this._sendRequest();
        }
        _prepareRequest() {
          const e2 = new XMLHttpRequest();
          e2.open("POST", this._apiAddress), e2.setRequestHeader("Authorization", this._token.value), e2.responseType = "json", this.xhr = e2;
        }
        _attachXHRListeners() {
          const e2 = this, t2 = this.xhr;
          function i2(t3) {
            return () => e2.fire("error", t3);
          }
          t2.addEventListener("error", i2("Network Error")), t2.addEventListener("abort", i2("Abort")), t2.upload && t2.upload.addEventListener("progress", (e3) => {
            e3.lengthComputable && this.fire("progress", { total: e3.total, uploaded: e3.loaded });
          }), t2.addEventListener("load", () => {
            const e3 = t2.status, i3 = t2.response;
            if (e3 < 200 || e3 > 299)
              return this.fire("error", i3.message || i3.error);
          });
        }
        _sendRequest() {
          const e2 = new FormData(), t2 = this.xhr;
          return e2.append("file", this.file), new Promise((i2, n2) => {
            t2.addEventListener("load", () => {
              const e3 = t2.status, o2 = t2.response;
              return e3 < 200 || e3 > 299 ? o2.message ? n2(new c.a("fileuploader-uploading-data-failed", this, { message: o2.message })) : n2(o2.error) : i2(o2);
            }), t2.addEventListener("error", () => n2(new Error("Network Error"))), t2.addEventListener("abort", () => n2(new Error("Abort"))), t2.send(e2);
          });
        }
      }
      Ke(xw, h);
      class Aw {
        constructor(e2, t2) {
          if (!e2)
            throw new c.a("uploadgateway-missing-token", null);
          if (!t2)
            throw new c.a("uploadgateway-missing-api-address", null);
          this._token = e2, this._apiAddress = t2;
        }
        upload(e2) {
          return new xw(e2, this._token, this._apiAddress);
        }
      }
      class Cw extends an {
        static get pluginName() {
          return "CloudServicesCore";
        }
        createToken(e2, t2) {
          return new vw(e2, t2);
        }
        createUploadGateway(e2, t2) {
          return new Aw(e2, t2);
        }
      }
      class Tw extends ph {
      }
      Tw.builtinPlugins = [class extends Qe {
        static get requires() {
          return [cu, Ch, wu, uu, Tu, tg];
        }
        static get pluginName() {
          return "Essentials";
        }
      }, class extends Qe {
        static get requires() {
          return [ng];
        }
        static get pluginName() {
          return "CKFinderUploadAdapter";
        }
        init() {
          const e2 = this.editor.config.get("ckfinder.uploadUrl");
          e2 && (this.editor.plugins.get(ng).createUploadAdapter = (t2) => new cg(t2, e2, this.editor.t));
        }
      }, class extends Qe {
        static get requires() {
          return [Sh];
        }
        static get pluginName() {
          return "Autoformat";
        }
        afterInit() {
          this._addListAutoformats(), this._addBasicStylesAutoformats(), this._addHeadingAutoformats(), this._addBlockQuoteAutoformats(), this._addCodeBlockAutoformats(), this._addHorizontalLineAutoformats();
        }
        _addListAutoformats() {
          const e2 = this.editor.commands;
          e2.get("bulletedList") && lg(this.editor, this, /^[*-]\s$/, "bulletedList"), e2.get("numberedList") && lg(this.editor, this, /^1[.|)]\s$/, "numberedList"), e2.get("todoList") && lg(this.editor, this, /^\[\s?\]\s$/, "todoList"), e2.get("checkTodoList") && lg(this.editor, this, /^\[\s?x\s?\]\s$/, () => {
            this.editor.execute("todoList"), this.editor.execute("checkTodoList");
          });
        }
        _addBasicStylesAutoformats() {
          const e2 = this.editor.commands;
          if (e2.get("bold")) {
            const e3 = ug(this.editor, "bold");
            dg(this.editor, this, /(?:^|\s)(\*\*)([^*]+)(\*\*)$/g, e3), dg(this.editor, this, /(?:^|\s)(__)([^_]+)(__)$/g, e3);
          }
          if (e2.get("italic")) {
            const e3 = ug(this.editor, "italic");
            dg(this.editor, this, /(?:^|\s)(\*)([^*_]+)(\*)$/g, e3), dg(this.editor, this, /(?:^|\s)(_)([^_]+)(_)$/g, e3);
          }
          if (e2.get("code")) {
            const e3 = ug(this.editor, "code");
            dg(this.editor, this, /(`)([^`]+)(`)$/g, e3);
          }
          if (e2.get("strikethrough")) {
            const e3 = ug(this.editor, "strikethrough");
            dg(this.editor, this, /(~~)([^~]+)(~~)$/g, e3);
          }
        }
        _addHeadingAutoformats() {
          const e2 = this.editor.commands.get("heading");
          e2 && e2.modelElements.filter((e3) => e3.match(/^heading[1-6]$/)).forEach((t2) => {
            const i2 = t2[7], n2 = new RegExp(`^(#{${i2}})\\s$`);
            lg(this.editor, this, n2, () => {
              if (!e2.isEnabled || e2.value === t2)
                return false;
              this.editor.execute("heading", { value: t2 });
            });
          });
        }
        _addBlockQuoteAutoformats() {
          this.editor.commands.get("blockQuote") && lg(this.editor, this, /^>\s$/, "blockQuote");
        }
        _addCodeBlockAutoformats() {
          const e2 = this.editor, t2 = e2.model.document.selection;
          e2.commands.get("codeBlock") && lg(e2, this, /^```$/, () => {
            if (t2.getFirstPosition().parent.is("element", "listItem"))
              return false;
            this.editor.execute("codeBlock", { usePreviousLanguageChoice: true });
          });
        }
        _addHorizontalLineAutoformats() {
          this.editor.commands.get("horizontalLine") && lg(this.editor, this, /^---$/, "horizontalLine");
        }
      }, class extends Qe {
        static get requires() {
          return [mg, fg];
        }
        static get pluginName() {
          return "Bold";
        }
      }, class extends Qe {
        static get requires() {
          return [pg, bg];
        }
        static get pluginName() {
          return "Italic";
        }
      }, class extends Qe {
        static get requires() {
          return [yg, xg];
        }
        static get pluginName() {
          return "BlockQuote";
        }
      }, class extends Qe {
        static get pluginName() {
          return "CKFinder";
        }
        static get requires() {
          return ["Link", "CKFinderUploadAdapter", Eg, Ag];
        }
      }, class extends an {
        static get pluginName() {
          return "CloudServices";
        }
        static get requires() {
          return [Cw];
        }
        init() {
          const e2 = this.context.config.get("cloudServices") || {};
          for (const t2 in e2)
            this[t2] = e2[t2];
          if (this._tokens = new Map(), this.tokenUrl)
            return this.token = this.context.plugins.get("CloudServicesCore").createToken(this.tokenUrl), this._tokens.set(this.tokenUrl, this.token), this.token.init();
          this.token = null;
        }
        registerTokenUrl(e2) {
          if (this._tokens.has(e2))
            return Promise.resolve(this.getTokenFor(e2));
          const t2 = this.context.plugins.get("CloudServicesCore").createToken(e2);
          return this._tokens.set(e2, t2), t2.init();
        }
        getTokenFor(e2) {
          const t2 = this._tokens.get(e2);
          if (!t2)
            throw new c.a("cloudservices-token-not-registered", this);
          return t2;
        }
        destroy() {
          super.destroy();
          for (const e2 of this._tokens.values())
            e2.destroy();
        }
      }, class extends Qe {
        static get requires() {
          return [Ig, "ImageUpload"];
        }
        init() {
          const e2 = this.editor;
          e2.plugins.has("ImageBlockEditing") || e2.plugins.has("ImageInlineEditing") || Object(c.b)("easy-image-image-feature-missing", e2);
        }
        static get pluginName() {
          return "EasyImage";
        }
      }, class extends Qe {
        static get requires() {
          return [Dg, Lg];
        }
        static get pluginName() {
          return "Heading";
        }
      }, class extends Qe {
        static get requires() {
          return [cm, dm];
        }
        static get pluginName() {
          return "Image";
        }
      }, class extends Qe {
        static get requires() {
          return [mm, pm];
        }
        static get pluginName() {
          return "ImageCaption";
        }
      }, class extends Qe {
        static get requires() {
          return [Mm, Nm];
        }
        static get pluginName() {
          return "ImageStyle";
        }
      }, class extends Qe {
        static get requires() {
          return [Vg, Gg];
        }
        static get pluginName() {
          return "ImageToolbar";
        }
        afterInit() {
          const e2 = this.editor, t2 = e2.t, i2 = e2.plugins.get(Vg), n2 = e2.plugins.get("ImageUtils");
          var o2;
          i2.register("image", { ariaLabel: t2("Image toolbar"), items: (o2 = e2.config.get("image.toolbar") || [], o2.map((e3) => w(e3) ? e3.name : e3)), getRelatedElement: (e3) => n2.getClosestSelectedImageWidget(e3) });
        }
      }, class extends Qe {
        static get pluginName() {
          return "ImageUpload";
        }
        static get requires() {
          return [Ym, jm, Bm];
        }
      }, class extends Qe {
        static get pluginName() {
          return "Indent";
        }
        static get requires() {
          return [Km, Zm];
        }
      }, class extends Qe {
        static get requires() {
          return [Pf, Df, jf];
        }
        static get pluginName() {
          return "Link";
        }
      }, class extends Qe {
        static get requires() {
          return [hp, gp];
        }
        static get pluginName() {
          return "List";
        }
      }, class extends Qe {
        static get requires() {
          return [vp, Cp, xp, Xh];
        }
        static get pluginName() {
          return "MediaEmbed";
        }
      }, Rg, class extends Qe {
        static get pluginName() {
          return "PasteFromOffice";
        }
        static get requires() {
          return [_h];
        }
        init() {
          const e2 = this.editor, t2 = e2.editing.view.document, i2 = [];
          i2.push(new zp(t2)), i2.push(new Mp(t2)), e2.plugins.get("ClipboardPipeline").on("inputTransformation", (e3, n2) => {
            if (n2._isTransformedWithPasteFromOffice)
              return;
            const o2 = n2.dataTransfer.getData("text/html"), r2 = i2.find((e4) => e4.isActive(o2));
            r2 && (n2._parsedData = Lp(o2, t2.stylesProcessor), r2.execute(n2), n2._isTransformedWithPasteFromOffice = true);
          }, { priority: "high" });
        }
      }, class extends Qe {
        static get requires() {
          return [tw, rw, aw, mw, uw, cw, Xh];
        }
        static get pluginName() {
          return "Table";
        }
      }, class extends Qe {
        static get requires() {
          return [Vg];
        }
        static get pluginName() {
          return "TableToolbar";
        }
        afterInit() {
          const e2 = this.editor, t2 = e2.t, i2 = e2.plugins.get(Vg), n2 = e2.config.get("table.contentToolbar"), o2 = e2.config.get("table.tableToolbar");
          n2 && i2.register("tableContent", { ariaLabel: t2("Table toolbar"), items: n2, getRelatedElement: bw }), o2 && i2.register("table", { ariaLabel: t2("Table toolbar"), items: o2, getRelatedElement: pw });
        }
      }, class extends Qe {
        static get requires() {
          return ["Delete", "Input"];
        }
        static get pluginName() {
          return "TextTransformation";
        }
        constructor(e2) {
          super(e2), e2.config.define("typing", { transformations: { include: ju } });
        }
        init() {
          const e2 = this.editor.model.document.selection;
          e2.on("change:range", () => {
            this.isEnabled = !e2.anchor.parent.is("element", "codeBlock");
          }), this._enableTransformationWatchers();
        }
        _enableTransformationWatchers() {
          const e2 = this.editor, t2 = e2.model, i2 = e2.plugins.get("Input"), n2 = e2.plugins.get("Delete"), o2 = function(e3) {
            const t3 = e3.extra || [], i3 = e3.remove || [], n3 = (e4) => !i3.includes(e4);
            return function(e4) {
              const t4 = new Set();
              for (const i4 of e4)
                if (Vu[i4])
                  for (const e5 of Vu[i4])
                    t4.add(e5);
                else
                  t4.add(i4);
              return Array.from(t4);
            }(e3.include.concat(t3).filter(n3)).filter(n3).map((e4) => Lu[e4] || e4).map((e4) => ({ from: Bu(e4.from), to: Fu(e4.to) }));
          }(e2.config.get("typing.transformations")), r2 = new Iu(e2.model, (e3) => {
            for (const t3 of o2) {
              if (t3.from.test(e3))
                return { normalizedTransformation: t3 };
            }
          });
          r2.on("matched:data", (e3, o3) => {
            if (!i2.isInput(o3.batch))
              return;
            const { from: r3, to: s2 } = o3.normalizedTransformation, a2 = r3.exec(o3.text), c2 = s2(a2.slice(1)), l2 = o3.range;
            let d2 = a2.index;
            t2.enqueueChange((e4) => {
              for (let i3 = 1; i3 < a2.length; i3++) {
                const n3 = a2[i3], o4 = c2[i3 - 1];
                if (o4 == null) {
                  d2 += n3.length;
                  continue;
                }
                const r4 = l2.start.getShiftedBy(d2), s3 = t2.createRange(r4, r4.getShiftedBy(n3.length)), h2 = Hu(r4);
                t2.insertContent(e4.createText(o4, h2), s3), d2 += o4.length;
              }
              t2.enqueueChange(() => {
                n2.requestUndoOnBackspace();
              });
            });
          }), r2.bind("isEnabled").to(this);
        }
      }], Tw.defaultConfig = { toolbar: { items: ["heading", "|", "bold", "italic", "link", "bulletedList", "numberedList", "|", "outdent", "indent", "|", "uploadImage", "blockQuote", "insertTable", "mediaEmbed", "undo", "redo"] }, image: { toolbar: ["imageStyle:inline", "imageStyle:block", "imageStyle:side", "|", "toggleImageCaption", "imageTextAlternative"] }, table: { contentToolbar: ["tableColumn", "tableRow", "mergeTableCells"] }, language: "en" };
    }]).default;
  });
})(ckeditor, ckeditor.exports);
var ClassicEditor = /* @__PURE__ */ getDefaultExportFromCjs(ckeditor.exports);
const editorConfig = {
  fontFamily: {
    options: ['"Montserrat", sans-serif', '"Roboto", sans-serif']
  }
};
const editorData = ref(`
  <h2>The three greatest things you learn from travelling</h2>

	<p>Like all the great things on earth travelling teaches us by example. Here are some of the most precious lessons I\u2019ve learned over the years of travelling.</p>

	<figure class="image image-style-side"><img src="https://images.pexels.com/photos/2335126/pexels-photo-2335126.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=650&w=940" alt="A lone wanderer looking at Mount Bromo volcano in Indonesia.">
		<figcaption>Leaving your comfort zone might lead you to such beautiful sceneries like this one.</figcaption>
	</figure>

	<h3>Appreciation of diversity</h3>

	<p>Getting used to an entirely different culture can be challenging. While it\u2019s also nice to learn about cultures online or from books, nothing comes close to experiencing cultural diversity in person. You learn to appreciate each and every single one of the differences while you become more culturally fluid.</p>

	<blockquote>
		<p>The real voyage of discovery consists not in seeking new landscapes, but having new eyes.</p>
		<p><strong>Marcel Proust</strong></p>
	</blockquote>

	<h3>Improvisation</h3>

	<p>Life doesn't allow us to execute every single plan perfectly. This especially seems to be the case when you travel. You plan it down to every minute with a big checklist; but when it comes to executing it, something always comes up, and you\u2019re left with your improvising skills. You learn to adapt as you go. Here\u2019s how my travel checklist looks now:</p>

	<ul>
		<li>buy the ticket</li>
		<li>start your adventure</li>
	</ul>

	<figure class="image image-style-side"><img src="https://images.pexels.com/photos/2967596/pexels-photo-2967596.jpeg?auto=compress&cs=tinysrgb&dpr=1&w=500" alt="Three Monks walking on ancient temple.">
		<figcaption>Leaving your comfort zone might lead you to such beautiful sceneries like this one.</figcaption>
	</figure>

	<h3>Confidence</h3>

	<p>Going to a new place can be quite terrifying. While change and uncertainty makes us scared, travelling teaches us how ridiculous it is to be afraid of something before it happens. The moment you face your fear and see there was nothing to be afraid of, is the moment you discover bliss.</p>
`);
const _hoisted_1 = { class: "page-content-inner" };
const _hoisted_2 = { class: "columns is-multiline" };
const _hoisted_3 = { class: "column is-12" };
const _hoisted_4 = { class: "columns" };
const _hoisted_5 = { class: "column is-12 content" };
const _sfc_main = /* @__PURE__ */ defineComponent({
  setup(__props) {
    const CKEditor = CKE.component;
    pageTitle.value = "CKEditor";
    useHead({
      title: "CKEditor - \u0627\u0641\u0632\u0648\u0646\u0647\u200C\u0647\u0627 - \u0648\u06CC\u0648\u0626\u0650\u0631\u0648"
    });
    return (_ctx, _cache) => {
      const _component_VBreadcrumb = _sfc_main$1;
      const _component_CKEditorBasicDocumentation = __script;
      return openBlock(), createElementBlock("div", _hoisted_1, [
        createVNode(_component_VBreadcrumb, {
          "with-icons": "",
          separator: "bullet",
          items: [
            {
              label: "\u0648\u06CC\u0648\u0626\u0650\u0631\u0648",
              hideLabel: true,
              icon: "feather:home",
              to: { name: "index" }
            },
            {
              label: "\u0627\u0644\u0645\u0627\u0646\u200C\u0647\u0627",
              to: { name: "elements" }
            },
            {
              label: "\u0627\u0641\u0632\u0648\u0646\u0647\u200C\u0647\u0627"
            },
            {
              label: "CKEditor",
              to: { name: "elements-addons-ckeditor" }
            }
          ]
        }),
        createBaseVNode("div", _hoisted_2, [
          createBaseVNode("div", _hoisted_3, [
            createVNode(_component_CKEditorBasicDocumentation),
            createBaseVNode("div", _hoisted_4, [
              createBaseVNode("div", _hoisted_5, [
                createVNode(unref(CKEditor), {
                  modelValue: unref(editorData),
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(editorData) ? editorData.value = $event : null),
                  editor: unref(ClassicEditor),
                  config: unref(editorConfig)
                }, null, 8, ["modelValue", "editor", "config"])
              ])
            ])
          ])
        ])
      ]);
    };
  }
});
export { _sfc_main as default };
